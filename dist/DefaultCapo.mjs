import { makeSource } from '@helios-lang/compiler-utils';

const CapoMintHelpers_hl = makeSource(
  "\n\nmodule CapoMintHelpers\nimport {\n    mustFindInputRedeemer,\n    mkTv,\n    TODO,\n    REQT,\n    tvCharter\n} from StellarHeliosHelpers\n\nimport {tx, get_current_input} from ScriptContext\n\nimport {\n    getTxCharterData,\n    CapoCtx,\n    mkCapoCtx,\n    DelegateInput,\n    CapoDatum, \n    CapoActivity\n} from CapoHelpers\n\n\nimport {\n    RelativeDelegateLink,\n    AbstractDelegateActivitiesEnum,\n    DelegateLifecycleActivity\n} from CapoDelegateHelpers\n\nfunc hasSeedUtxo(tx: Tx, seedUtxo: TxOutputId\n    // , reason: String\n) -> Bool {\n    REQT(\"It must spend the indicated seed UTXO\");\n\n    if (!tx.inputs.any( (input: TxInput) -> Bool {\n        input.output_id == seedUtxo\n    })) {\n        print(\" - expected seedUtxo: \");\n        print(seedUtxo.show());\n        print(\"\\n\");\n        // + \"\\n\"+seedUtxo.tx_id.show() + \" : \" +seedUtxo.index.show()\n        assert(false, \"missing expected seed input for minting\")\n        // +reason \n    };\n    print( \"  -- has seed -> ok\\n\");\n    true\n}\n\nfunc noOtherActivitiesSupported( _: AbstractDelegateActivitiesEnum) -> Bool {\n    print(\"yikes, expected the delegate to use activity DelegateLifecycleActivities:ReplacingMe or authorizingDelegate...\\n\");\n    print(\"   -- note: for other cases, a context-specific check via validateUutMinting's (\\n\"+\n      \"  ...\\n  checkMintDgtActivity: (AbstractDelegateActivitiesEnum) -> Bool)\\n\"+\n      \") option can be used to steer around this failure.\\n\");\n    assert(false, \"unexpected delegate activity\");\n    false\n}\n\nfunc requiresDelegateAuthorizingMint(\n    delegateLink: RelativeDelegateLink, \n    mph: MintingPolicyHash,     \n    extraMintDelegateRedeemerCheck: Bool = true,\n    checkMintDgtActivity: (AbstractDelegateActivitiesEnum) -> Bool = noOtherActivitiesSupported\n) -> Bool {\n    // authzVal : Value = Value::new(AssetClass::new(mph, delegateLink.uutName.encode_utf8()), 1);\n    authzAc : AssetClass = delegateLink.acAuthorityToken(mph);\n    REQT(\"requires the charter's mint-delegate to authorize this mint activity\");\n    print(\"  -- finding input dgTkn: \" + delegateLink.uutName);\n\n    targetId: TxOutputId = tx.inputs.find_safe((i: TxInput) -> {\n        // print(\"   ?  in \"+i.value.show());\n        i.value.get_safe(authzAc) > 0 // find my authority token\n    }).switch{\n        Some{x} => x.output_id,\n        None => error(\"  ❌❌ missing dgTkn \"+delegateLink.uutName)\n    };\n    print (\"    -- ✅ ➡️  💁found dgTkn ^\");\n    spendsAuthorityUut : ScriptPurpose = tx.redeemers.find_key( \n        (purpose : ScriptPurpose) -> { purpose.switch{ \n            sp: Spending => {\n                // print (\"oid: \" + sp.output_id.show());\n                sp.output_id == targetId\n            }, \n            _ => false \n        } }\n    );\n\n    // r : Data = tx.redeemers.get(  // index redeemers by...\n    //     ScriptPurpose::new_spending(  // [spending, plus ...\n    //     );\n        //!!! Todo replace this with a return of Option[delegate-redeemer}?\n    err : String = \"dgTkn \"+delegateLink.uutName+\" not being spent as expected\"; // \"not spent with an authorizing activity!\")\n    maybeCheckedMintDelegateAuthority : Bool = tx.redeemers.get_safe(\n        spendsAuthorityUut\n    ).switch {\n        None => {\n            error(err)\n        },\n        Some{x} => {\n            activity = AbstractDelegateActivitiesEnum::from_data(x);\n            activity.switch {\n                DelegateLifecycleActivities{DLA} => {\n                    TODO(\"VERIFY we ---------------- don't need the funny redeemer-check skipping\");\n                    if (!extraMintDelegateRedeemerCheck) {\n                        print(\" vvv wherever it is, probably best it uses the checkMintDgtActivity option\");\n                        error(\"where is extraMintDelegateRedeemerCheck=false really needed?\")\n                        //     print(\"  -- ok, dgTkn spent\\n\");\n                        //     print(\"  ---- skip redeemer check\\n\");\n                        //     true\n                    };\n                    DLA.switch {\n                        ReplacingMe => {\n                            print(\"  -- ok, dgTkn spent\\n\");\n                            true\n                        },\n                        Retiring => error(\"DLA::Retiring can't mint!\"),\n                        ValidatingSettings => error(\"DLA::ValidatingSettings can't mint!\")\n                    }\n                },\n                _ => checkMintDgtActivity(activity)\n            }\n        }\n    };\n    delegateDidAuthorize = true; // otherwise, we'd have failed above.\n\n    // NOTE: DOESN'T CHECK that the AUTHORIZING DELEGATE is returned anywhere specific.\n    //    - it's not generally a minting responsibility (however, as an exception the bootstrap charter event DOES \n    //      actually check for valid delegate outputs).  All other cases should have the correct\n    //      delegate outputs checked (e.g. in the Capo's CharterData spend checker).\n    // maybeCheckDelegateOutput : Bool = if (!checkDelegateOutput) {\n    //     print(\"  -- skipping check for expected delegate output \");\n    //     true\n    // } else {\n    //     delegateLink.hasValidOutput(mph)        \n    // };\n    delegateDidAuthorize && maybeCheckedMintDelegateAuthority\n}\n\nfunc requiresMintDelegateApproval(\n    mph: MintingPolicyHash\n) -> Bool {\n    cctx : CapoCtx = mkCapoCtx(mph).needsCharter();\n    print(\"Minter needs mintDgt + mint activity\\n\");\n    REQT(\"EXPECTS the application-specific mintDelegate to explicitly check and approve the full minted value\");\n    \n    // print (\"      ❇️  \"+ \n    //     tx.minted.get_policy(mph).to_list(\n    //         (b : ByteArray, i: Int) -> String { \n    //             i.show() + \"x \" + b.decode_utf8()\n    //         }\n    //     ).join(\" + \") \n    // + \"\\n\");\n\n    print(\"    -- ^ e.g. assert(tx.minted.get_policy(mph) == expectedMintedValue);\\n\");\n    print(\"    ---- (if it's only responsible for one minting policy)\\n\");\n    // if (true) {\n        // todo: enforces minting invariants.\n        TODO(\"must enforce minting invariants\");\n    // }; \n\n    mintDgtInput : DelegateInput = cctx.requiresMintDelegateInput();\n    mintDgtActivity : AbstractDelegateActivitiesEnum = mintDgtInput.genericDelegateActivity();\n\n\n    // TODO restore this: mintDgtInput.requiresValidOutput() && \n    mintDgtActivity.switch {\n        CapoLifecycleActivities{CLA} => CLA.switch {\n            CreatingDelegate => {\n                TODO( \"make this obsolete: generic creatingDelegate (use queuePendingChange and committingPendingChanges in sequence)\");\n                // print(\"  -- minter wants mintDgt + CapoLifecycle (delegate-creation)\\n\");\n\n                mintDgtInput.requiresValidOutput() && \n                true\n            }, \n            queuePendingChange => {\n                print(\"  -- ok: mintDgt using CapoLifecycle.queuePendingChange)\\n\");\n                mintDgtInput.requiresValidOutput() && \n                true\n            },\n            commitPendingChanges => {\n                print(\"  -- ok: mintDgt using CapoLifecycle.commitPendingChanges)\\n\");\n                mintDgtInput.requiresValidOutput() && \n                true\n            },\n            forcingNewSpendDelegate => error(\"invalid forcingNewSpendDelegate activity on mintDgt (escape-hatch reserved for Minter/Capo pair)\"),\n            forcingNewMintDelegate => error(\"invalid forcingNewMintDelegate activity on mintDgt (escape-hatch reserved for Minter/Capo pair)\"),\n            _ => error(\"mint dgt can only approve CapoLifecycleActivities.queuePendingChange or non-CLA activities\")\n            // _ => error(\"no\")// ---- left as a compile-time error if any further variants are added \n        },\n        SpendingActivities => error(\"DelegateInput::SpendingActivity can't mint!\"),\n        DelegateLifecycleActivities{DLA} => {\n            DLA.switch {\n                ReplacingMe => {\n                    TODO( \"relay delegate installation sequence\" \n                        // \"the new delegate should be minted under CapoLifecycleActivities::CreatingDelegate, then installed \\n  ...without the minter's involvement, using its DelegateLifecycle::Installing activity\"\n                    );\n                    print(\"  -- TEMPORARY: the mint delegate is being replaced\\n\");\n                    true\n                },\n                Retiring => error(\"DLA::Retiring can't mint!\"),\n                ValidatingSettings => error(\"DLA::ValidatingSettings can't mint!\")\n            }\n        },\n        MintingActivities => {\n            print(\"  -- app-specific minting; trust mintDgt\\n\");\n            mintDgtInput.requiresValidOutput() && \n                true\n        },\n        BurningActivities => {\n            print(\"  -- app-specific burning; trust mintDgt\");\n            mintDgtInput.requiresValidOutput() && \n                true\n        },\n        CreatingDelegatedData => {\n            print(\"  -- mint for dgData; trust mintDgt\");            \n            mintDgtInput.requiresValidOutput() && \n                true\n        },\n        DeletingDelegatedData => {\n            print(\"  -- burn for dgData; trust mintDgt\");\n            mintDgtInput.requiresValidOutput() && \n                true\n        },\n        UpdatingDelegatedData => error(\"invalid mint-delegate activity for minting; UpdatingDelegatedDatum can't mint\"),\n        MultipleDelegateActivities{ma} => {\n            // assert(false && ma.length > 0, \"empty MultipleDelegateActivities\");\n            mintDgtInput.requiresValidOutput()\n            && ma.map(AbstractDelegateActivitiesEnum::from_data).all(\n                (mintDgtActivity: AbstractDelegateActivitiesEnum) -> Bool {\n                    mintDgtActivity.switch {\n                        CreatingDelegatedData => true, // short version of recursing the full check\n                        DeletingDelegatedData => true, // short version of recursing the full check\n                        MintingActivities => error(\n                            \"mintDgt: MultipleDelegateActivities: nested MintingActivities invalid\"\n                        ),\n                        BurningActivities => error(\n                            \"mintDgt: MultipleDelegateActivities: nested BurningActivities invalid\"\n                        ),\n                        MultipleDelegateActivities => error(\n                            \"mintDgt: MultipleDelegateActivities: nested MultipleDelegateActivities invalid\"\n                        ),\n                        UpdatingDelegatedData => error(\n                            \"mintDgt: MultipleDelegateActivities: nested UpdatingDelegatedData invalid\"\n                        ),\n                        SpendingActivities => error(\n                            \"mintDgt: MultipleDelegateActivities: nested SpendingActivities invalid\"\n                        ),\n                        CapoLifecycleActivities => error(\n                            \"mintDgt: MultipleDelegateActivities: nested CapoLifecycleActivities invalid\"\n                        ),\n                        DelegateLifecycleActivities => error(\n                            \"mintDgt: MultipleDelegateActivities: nested DelegateLifecycleActivities invalid\"\n                        )\n                    }\n                }\n            )\n        }\n    }\n\n\n    // requiresDelegateAuthorizingMint(\n    //     delegateLink: mintDgt, \n    //     mph: mph,\n    // )\n}\n\n//! pre-computes the hash-based suffix for a token name, returning\n//  a function that cheaply makes Uut names with any given purpose, \n// given the initial seed-txn details\nfunc mkUutTnFactory(\n    seed: TxOutputId\n) -> (String) -> String {\n\n    seedTxId : TxId = seed.tx_id;\n    seedIdx : Int = seed.index;\n\n\n    idxBytes : ByteArray = seedIdx.serialize();\n    // assert(idxBytes.length == 1, \"surprise!\");\n\n    //! yuck: un-CBOR...\n    rawTxId : ByteArray = seedTxId.serialize().slice(5,37);\n\n    txoInfo : ByteArray = if (idxBytes.length > 9) { \n        // allows 9 bytes to ensure we can support \n        // the largest possible cbor encoding of txo-index integers, \n        // even though we only expect integers < 256 currently\n        assert(false, \n            //\"expected cbor(txo index) to be at most 9 bytes, got cbor( index=\n            //  + seedIdx.show() + \" ).hex = \" + idxBytes.show()\n            \"cbor(txoId) len > 9 !!\"  \n        );\n        idxBytes // never used\n    } else {\n       ( rawTxId + \"@\".encode_utf8() )+ idxBytes\n    };\n    // assert(txoId.length == 34, \"txId + @ + int should be length 34\");\n    // print( \"******** txoId \" + txoId.show());\n\n    miniHash : ByteArray = txoInfo.blake2b().slice(0,6);\n    // assert(miniHash.length == 6, \"urgh.  slice 5? expected 12, got \"+ miniHash.length.show());\n\n    mhs: String = miniHash.show();\n\n    // returns a function computing a lightweight prefix + miniHash\n    (p: String) -> String {\n        p + \"-\" + mhs\n    }\n}\n\nfunc tnCip68nft222(tn : String) -> ByteArray{\n     #000de140 + tn.encode_utf8()\n}\n\nfunc tnCip68ref100(tn : String) -> ByteArray {\n    #000643b0 + tn.encode_utf8()\n}\n\n/**\n * ensures that minted- and expected-token-names are both\n * sorted in the same way.  The on-chain format requires shorter-first,\n * but we re-sort them (both) because the node doesn't always present them in\n * script-context in that required order.  \n *\n */\n func sortPolicyValuesPredictably(k1 : ByteArray, _v1 : Int, k2 : ByteArray, _v2: Int) -> Bool {\n     k1 < k2\n }\n\n /*\n * ensures that shorter token-names are mentioned before longer ones\n * AND that lexographically smaller names are mentioned first.  This is\n * the canonical ordering and is required for hardware wallets to work.\n */\n\nfunc sortPolicyValuesShortestFirst(k1 : ByteArray, _v1 : Int, k2 : ByteArray, _v2: Int) -> Bool {\n    if (k1.length < k2.length) { \n        true\n    } else if (k1.length > k2.length) {\n        false\n    } else {\n        k1 < k2\n    }\n}\n\n// checks all of the following:\n//  - there's an approving delegate (or we're bootstrapping)\n//  - the mint includes the seed UTXO\n//  - the mint matches the UUTs indicated by the list of purposes\nfunc validateUutMinting(\n    mph: MintingPolicyHash,\n    seed: TxOutputId,\n    purposes: []String,     \n    mkTokenName: (String) -> String = mkUutTnFactory(seed),\n    bootstrapCharter:Value = Value::ZERO,\n    otherMintedValue: Value = Value::ZERO,\n    needsMintDelegateApproval: Bool = true,\n    extraMintDelegateRedeemerCheck: Bool = true,\n    checkMintDgtActivity: (AbstractDelegateActivitiesEnum) -> Bool = noOtherActivitiesSupported\n) -> Bool {\n    isBootstrapping : Bool = !( bootstrapCharter.is_zero() );\n\n    delegateApproval : Bool = if ( isBootstrapping ) { \n        true \n    } else {\n        // not bootstrapping; must honor the mintDelegate's authority\n        CapoDatum::CharterData {\n            _spendDgt,\n            _spendInvariants,\n            _namedDelegates,\n            mintDgt, \n            _mintInvariants, \n            _govAuthority,\n            _manifest,\n            _pendingDelegates\n        } = getTxCharterData(mph);\n\n        if (needsMintDelegateApproval) {\n            //!!! todo: add explicit activity details in authorization\n            requiresDelegateAuthorizingMint(\n                delegateLink: mintDgt, \n                mph: mph, \n                extraMintDelegateRedeemerCheck: extraMintDelegateRedeemerCheck,\n                checkMintDgtActivity: checkMintDgtActivity\n            )\n        } else {\n            true\n        }\n    };\n\n\n    valueMinted: Value = tx.minted;\n\n    // idxBytes : ByteArray = seedIdx.bound_max(255).serialize();\n    // // assert(idxBytes.length == 1, \"surprise!\");\n\n    // //! yuck: un-CBOR...\n    // rawTxId : ByteArray = seedTxId.serialize().slice(5,37);\n\n    // txoId : ByteArray = (rawTxId + \"@\".encode_utf8() + idxBytes);\n    // assert(txoId.length == 34, \"txId + @ + int should be length 34\");\n    // // print( \"******** txoId \" + txoId.show());\n\n    // miniHash : ByteArray = txoId.blake2b().slice(0,6);\n    // // assert(miniHash.length == 6, \"urgh.  slice 5? expected 12, got \"+ miniHash.length.show());\n\n    // tokenName1 = purpose + \".\" + miniHash.show();\n\n    // print(\" purposes: \" + purposes.join(\", \"));\n    expectedValue : Value = bootstrapCharter + otherMintedValue + Value::sum(\n        purposes.map(\n            (purpose: String) -> Value {\n                // print(\"purpose: \" + purpose);\n                mkTv(mph: mph, tn: mkTokenName(purpose) /*, => 1 */)\n            }\n        )\n    );\n\n    if (! valueMinted.contains_policy(mph) ) {\n        mphStr = mph.show();\n        valStr = valueMinted.show();\n        print( \"  -- no mint from our policy \"+ mphStr);\n        print(valStr);\n        print( \"^^  value minted\");\n        error(\"❌❌ validateUutMinting(): no mint from our policy\")\n    };\n\n    // seedTxId = seed.tx_id.show();\n    // seedIdx = seed.index.show();\n    // print(\"\\n  -- uut-minting seed: \" + seedTxId + \"🔹#\"+seedIdx);\n\n    expectedValuesSorted = expectedValue.\n        get_policy(mph).\n        sort(sortPolicyValuesPredictably);\n    expectedValuesSorted.for_each( (tn : ByteArray, i: Int) -> {\n        tnStr = tn.decode_utf8_safe();\n        print( \"    ℹ️ 🐞 expected: \"+ i.show() + \"x \" + tnStr )\n    });\n\n    actualThisPolicyMint = valueMinted.get_policy(mph);\n    actualThisPolicyMintSorted = actualThisPolicyMint.\n        sort(sortPolicyValuesPredictably);\n    // expectedMint : Map[ByteArray]Int = expectedValue.get_policy(mph);\n    if (true) {\n        actualThisPolicyMintSorted.for_each( (tn : ByteArray, i: Int) -> {\n            tnStr = tn.decode_utf8_safe();  \n            print( \"    ℹ️ 🐞   actual: \" + i.show() + \"x \" + tnStr )\n        });\n        print(\"other policy values minted: \\n\");\n        print(Value::from_map(valueMinted.to_map().filter( (b:MintingPolicyHash, _ /* Map[ByteArray]Int */ ) -> Bool {\n            b != mph\n        })).show())\n    };\n\n    // _temp : []ByteArray = actualMint.fold( (l: []ByteArray, b : ByteArray, i: Int) -> {\n    //     l.find_safe((x : ByteArray) -> Bool { x == b }).switch{\n    //         None => l.prepend(b),\n    //         Some /*{x}*/ => error(\"UUT duplicate purpose \"\n    //             // +  x.decode_utf8()\n    //         )\n    //     }\n    // }, []ByteArray{});\n    // assert(true || (temp == temp), \"prevent unused var\");\n\n    \n\n    REQT(\"Ensures the mint for this policy-id is exactly the expected value\");\n    thisPolicyMintOK = actualThisPolicyMintSorted == expectedValuesSorted;\n    assert(thisPolicyMintOK, \"mismatch in UUT mint\");\n    print(\"  -- this-policy mint ok\");\n    assert(hasSeedUtxo(tx, seed), \"no seed\"); //, \"UUT \"+purposes.join(\"+\")\n    print(\"  -- ok: has seed and expected this-policy mint value\");\n\n    otherPoliciesMintOk = if (!otherMintedValue.is_zero()) { true } else {\n        REQT(\"... with an additional mint-value indicated\");\n\n        remainingExpectedMint = if (expectedValue.contains_policy(mph)) {\n            Value::from_map(\n                expectedValue.to_map().delete(mph)\n            )\n        } else { expectedValue };\n\n        if (remainingExpectedMint.is_zero()) { true } else {\n            REQT(\"...with other-policy values expected: \");\n            print( remainingExpectedMint.show() + \"^ other-mint value expected\");\n            REQT(\"It should mint exactly the indicated token names\");\n            REQT(\"Doesn't constrain any mentioned policy's minting of any other tokens\");\n            remainingExpectedMint.to_map().for_each( \n                (otherMph: MintingPolicyHash, expectedTokensThisPolicy: Map[ByteArray]Int) -> {\n                    mintedThisPolicy : Map[ByteArray]Int = valueMinted.get_policy(otherMph);\n\n                    expectedTokensThisPolicy. \n                    for_each( (tokenName: ByteArray, expectedCount: Int) -> {\n                        if(! mintedThisPolicy.get_safe(tokenName).\n                            switch {\n                                None => false,\n                                Some{actualCount} => actualCount == expectedCount\n                            }\n                        ) {\n                            tnString = tokenName.decode_utf8_safe();\n                            error(\n                                \"❌❌ validateUutMinting(): wrong mint for \"+ otherMph.show() + \":\" + tnString\n                            )\n                        }}\n                    )\n                }\n            );\n            true\n        }\n        // ^^ any errors are thrown in here\n    };\n    assert(\n        otherPoliciesMintOk.trace(\"  -- other-expected-mints ok? \"), \n        \"unreachable exception: otherPoliciesMintOk\"\n    );\n\n    print(\" ✅ validateUutMinting:  ok!\\n\");\n\n    delegateApproval && thisPolicyMintOK && otherPoliciesMintOk \n}\n\nenum MinterActivity { \n    mintingCharter { // 0\n        owner: Address\n        //xxx withSettings: Bool\n        // we don't have a responsiblity to enforce delivery to the right location\n        // govAuthority: RelativeDelegateLink   // not needed \n    }\n    mintWithDelegateAuthorizing // 1 - delegate is handling all mints\n\n    // obsoleted by Capo lifecycle activity (queuePendingChange with role=MintInvariant)\n    addingMintInvariant { //2 \n        seed: TxOutputId\n    }\n\n    // obsoleted by Capo lifecycle activity (queuePendingChange with role=SpendInvariant)\n    addingSpendInvariant { //3\n        seed: TxOutputId\n    }\n\n    forcingNewMintDelegate { //4\n        seed: TxOutputId\n    }\n\n    CreatingNewSpendDelegate { //5\n        seed: TxOutputId\n        // when not forcing the new delegate, the old UUT will be replaced:\n        replacingUut: Option[ByteArray]\n    }\n\n}\n\n", {
    project: "stellar-contracts",
    purpose: "module",
    name:  "src/CapoMintHelpers.hl", // source filename
    moduleName:  "CapoMintHelpers",
});

const CapoDelegateHelpers_hl = makeSource(
  "module CapoDelegateHelpers\n\nimport {\n    tx, \n    get_current_input,\n    get_current_validator_hash,\n    get_cont_outputs\n} from ScriptContext\n\nimport {\n    AnyData,\n    mustFindInputRedeemer,\n    mkTv,\n    returnsValueToScript\n} from StellarHeliosHelpers\n\n// todo: add this to RelativeDelegateLink\nenum stakingKeyRequirement {\n    NoStakingKeyAllowed\n    StakingKeyRequired\n    SpecificStakeKeyRequired {\n        stakeCredential: StakingCredential\n    }\n}\n\n// use this activity at Redeemer zero, as enum Redeemer {\n//   DelegateLifecycleActivity { a: DelegateLifecycleActivity }}\n//   ... followed by app-specific redeemer variants\n// }\nenum DelegateLifecycleActivity {\n    ReplacingMe { // replaces this delegate with a different one\n        seed: TxOutputId\n        purpose: String\n    }\n    Retiring\n    ValidatingSettings\n}\n\nenum DelegateRole {\n    MintDgt\n    SpendDgt\n    MintInvariant\n    SpendInvariant\n    DgDataPolicy {\n        name: String\n    }\n    OtherNamedDgt {\n        name: String\n    }\n    BothMintAndSpendDgt\n    HandledByCapoOnly\n}\n\nenum ManifestActivity {\n    retiringEntry {\n        key: String\n    }\n    updatingEntry {\n        key: String  // must already exist\n        tokenName: ByteArray  // must reference or input new & old\n    }\n    addingEntry {\n        key: String  // must not exist\n        tokenName: ByteArray // must reference or input new & old\n    }\n    forkingThreadToken {\n        key: String // must mint new & create a clone of the existing token\n        newThreadCount: Int\n    }\n    burningThreadToken {\n        key: String // must burn the token\n        burnedThreadCount: Int // must match the count of the burned token\n    }\n}\n\nenum PendingDelegateAction {\n    Add {\n        seed: TxOutputId\n        purpose: String\n        idPrefix: String\n        // uutName: String\n        // delegateValidatorHash: Option[ValidatorHash]\n        // config: ByteArray\n    }\n    Remove\n    Replace {\n        seed: TxOutputId\n        purpose: String\n        idPrefix: String\n\n        // uutName: String\n        // delegateValidatorHash: Option[ValidatorHash]\n        // config: ByteArray\n\n        replacesDgt: AssetClass\n    }\n}\n\n// use this activity at Redeemer #1 CapoLifecycleActivities\nenum CapoLifecycleActivity {\n    CreatingDelegate {\n        seed: TxOutputId\n        purpose: String\n    }\n    queuePendingChange \n        // seed: TxOutputId\n        // purpose: String\n        // action: PendingDelegateAction\n\n        // role: DelegateRole\n        // name: Option[String]\n    // }\n    removePendingChange {\n        role: DelegateRole\n    }\n    commitPendingChanges\n    forcingNewSpendDelegate {\n        seed: TxOutputId\n        purpose: String //uut purpose \"spendDgt\"\n    }\n    forcingNewMintDelegate {\n        seed: TxOutputId\n        purpose: String //uut purpose \"mintDgt\"\n    }\n        // manifest-updating activities, ALWAYS at Enum position 5\n    // this is not application-specific.  It's placed into the delegation\n    // layer so that a spend-delegate's manifest-updating logic can be\n    // upgraded while leaving the Capo unchanged.\n    updatingManifest {\n        activity: ManifestActivity\n    }\n\n    \n}\n\n// use this enum to match any redeemer if you don't care about what other\n// variants may be in that delegate, but you know it has to be a delegate with the \n// universal delegate activities at constr#0\nenum AbstractDelegateActivitiesEnum {\n    CapoLifecycleActivities {\n        activity: CapoLifecycleActivity\n    }\n    DelegateLifecycleActivities {\n        activity: DelegateLifecycleActivity\n    }\n    SpendingActivities {\n        activity: Data\n    }\n    MintingActivities {\n        activity: Data\n    }\n    BurningActivities {\n        activity: Data\n    }\n\n    // allows for delegated-data minting activities to be checked generically,\n    // instead of having to create explicit minting/spending activities for each one.\n    // The mint/spend delegate can thus generically support any registered data-type,\n    // enforcing that right delegate is used but not needing to deal with specifics of \n    // their activities.  Requires a typeMap for to resolve dataType to the concrete delegate.\n\n    CreatingDelegatedData {\n        seed: TxOutputId\n        dataType: String\n        // id from seed\n    }\n    UpdatingDelegatedData {\n        // seed not used\n        dataType: String\n        recId: ByteArray\n    }\n    DeletingDelegatedData {\n        // seed not used\n        dataType: String\n        recId: ByteArray\n    }\n    MultipleDelegateActivities {\n        activities: []Data // actually a []DelegateActivitiesEnum\n    }\n}\nenum DgTknDisposition {\n    Returned\n    Created\n}\n\n// data stored in the Capo, representing basic delegate info\n//   about the connection to a delegate.  \nstruct RelativeDelegateLink {\n    uutName: String \n\n    // delegate links without a validator hash are \"arms-length\" delegates,\n    // which means they won't be checked for possible auto-upgrades \n    //  ... to new versions of their code.\n    // it also means that they won't be able to participate \n    //   ... in validation of configuration changes in the Capo.\n    delegateValidatorHash: Option[ValidatorHash]\n    config: ByteArray\n    // !!! todo ???  - for namedDelegates particularly\n    // stakingCred: stakingKeyRequirement\n\n    func getRedeemer(self,  input : TxInput)  -> AbstractDelegateActivitiesEnum {\n        assert( true || /* not executed */ self == self, \"no way s\");// avoid unused variable\n        AbstractDelegateActivitiesEnum::from_data( \n            mustFindInputRedeemer(input)\n        )\n    }\n\n    func tvAuthorityToken(self, mph: MintingPolicyHash) -> Value {\n        mkTv(mph: mph, tn: self.uutName)\n    }\n\n    func acAuthorityToken(self, mph: MintingPolicyHash) -> AssetClass {\n        AssetClass::new(mph, self.uutName.encode_utf8())\n    }\n\n    // func getTv(self, mph: MintingPolicyHash) -> Value {\n    //     assert(false, \"deprecated getTv(); use RDL.tvAuthorityToken instead\");\n    //     mkTv(mph: mph, tn: self.uutName)\n    // }\n    \n    func validatesUpdatedSettings(self,\n        inputs: []TxInput,\n        mph: MintingPolicyHash,\n        inputRequired: Bool\n    ) -> Option[Bool] {\n        self.hasDelegateInput( // fails if req'd input missing\n            inputs: inputs,\n            mph: mph,\n            required: inputRequired\n        ).switch {            \n            None => Option[Bool]::None, // clean \"not found but the caller indicated that's ok\"\n            Some{spendDelegateInput} => {\n                spendDelegateIsValid : Bool = AbstractDelegateActivitiesEnum::from_data( \n                    mustFindInputRedeemer(spendDelegateInput)\n                ).switch {\n                    DelegateLifecycleActivities{a} => {\n                        a.switch {\n                            ValidatingSettings => self.hasValidOutput(mph),\n                            _ => error(\"delegate not ValidatingSettings: \"+ self.uutName)\n                        }\n                    },\n                    _ => error(\"no way n\") // throws if the redeemer isn't #0.\n                };\n\n                assert(spendDelegateIsValid, \"no way o\"); // it threw any error already\n                Option[Bool]::Some{spendDelegateIsValid}\n            }\n        }\n    }\n\n    func hasDelegateInput(self, \n        inputs: []TxInput, \n        mph: MintingPolicyHash,\n        required: Bool = true\n    ) -> Option[TxInput] {\n        uutName : String = self.uutName;\n        self.delegateValidatorHash.switch{\n            // when no special input is needed by the delegate, \n            None => {\n                if (required) {\n                    error(\"❌❌ ➡️ 💁 missing required input with dgTkn \" + uutName)\n                } else {\n                    Option[TxInput]::None\n                }\n            },\n            Some{vh} => {\n                needsAddrWithCred : SpendingCredential = SpendingCredential::new_validator(vh);\n                // if we arrived here, then we have a delegate that's supposed to be at a specific address.\n                // if we can't find an input with that address, it's an error condition.\n                // we need an input with this address, having the expected UUT.\n\n                ac = AssetClass::new(mph, uutName.encode_utf8());\n                // expectedUut : Value = mkTv(mph: mph, tn: uutName);\n\n                print(\"  -- seeking input dgTkn: \"+ uutName);\n                inputs.find_safe((i: TxInput) -> Bool {\n                    i.address.credential == needsAddrWithCred &&\n                    i.value.get_safe(ac) > 0\n                }).switch {\n                    foundGood: Some => {\n                        print (\"  ✅ ➡️  💁 found ^ input dgTkn\" );\n                        foundGood\n                    },\n                    /* notFound: */ None => {\n                        if (required) {\n                            error(\"_❌ ➡️  💁 missing req'd input dgTkn (at script addr) \" + uutName)\n                        } else {\n                            print (\" <- 🚫 ➡️ 💁 no input with ^ dgTkn; not req'd; returning false\\n\");\n                            Option[TxInput]::None\n                        }\n                    }\n                }\n            }        \n        }\n    }\n    \n    // was requiresValidDelegateOutput \n    func hasValidOutput(\n        self, // delegateLink: RelativeDelegateLink, \n        mph: MintingPolicyHash, \n        required: Bool = true,\n        createdOrReturned: DgTknDisposition = DgTknDisposition::Returned\n    ) -> Bool {\n        RelativeDelegateLink{\n            uut,  \n            validatorHash, \n            _ /* configJson */\n        } = self;\n    \n        // v : Value = mkTv(mph, uut);\n        ac = AssetClass::new(mph, uut.encode_utf8());\n\n        cOrR : String = createdOrReturned.switch{\n            Returned => \"returned\",\n            Created => \"created\"\n        };\n        print(\" ⬅️ 🔎 💁 expect dgTkn \"+ cOrR + \": \"+ uut);\n        hasDelegate : Bool = validatorHash.switch{\n            Some{vh} => {\n                print( \"  ... ^ sent to validator: \"+vh.show()+\"\\n\");\n                tx.value_locked_by(vh).get_safe(ac) > 0\n            },\n            None => {\n                print(\"   (to anywhere)\");\n\n                tx.outputs.find_safe((o : TxOutput) -> Bool {\n                    o.value.get_safe(ac) > 0\n                }).switch{\n                    Some => true, \n                    None => false\n                }\n            }\n        };\n    \n        if (!hasDelegate && required) {\n            // this branch has no on-chain cost\n            // throws for a missing input \n            createdOrReturned.switch {\n                Created => error(\"⬅️ ❌ 💁 dgTkn not created: \"+ uut),\n                Returned => { // throws unless the right INPUT is                    \n                    _ = self.hasDelegateInput(tx.inputs, mph, true);\n                    error(\"⬅️ ❌ 💁 dgTkn not returned: \"+ uut )\n                }\n            }\n        } else {\n            // print(uut);\n            if (hasDelegate) {\n                print(\" ⬅️ ✅ 💁 ok:  ^ dgTkn has \"+cOrR+\" a valid output\\n\")\n            } else {\n                print(\" ⬅️ 🚫 💁 no delegate but not req'd; false\")\n            }\n        };\n        hasDelegate\n\n                    // self.hasDelegateInput(tx.inputs, mph, true).switch {\n                    //     Some => {\n                    //         // throws if it's spent, but not returned correctly:\n                    //         error(\"⬅️ ❌ 💁 dgTkn not returned: \"+ uut )\n                    //     },\n                    //     _ => error(\"no way p\")\n                    // }\n\n    }\n    \n    // config: Data\n}\n\n\nstruct PendingDelegateChange {\n    action: PendingDelegateAction\n    role: DelegateRole\n    // name: Option[String] // moved to DelegateRole variants for named delegates/dgDataPolicy\n    dgtLink: Option[RelativeDelegateLink]\n\n    func isValid(self) -> Bool {\n        self.role.switch {\n            BothMintAndSpendDgt => error(\n                \"DelegateRole::BothMintAndSpendDgt not applicable in a PendingDelegateChange struct\"\n            ),\n            _ => true\n        }\n    }\n}\n\nenum PendingCharterChange {\n    delegateChange {\n        change: PendingDelegateChange\n    }\n    otherManifestChange {\n        activity: ManifestActivity\n        /**\n         * indicates delegates that are needed to validate a pending change\n         * @remarks\n         * not every manifest change has to be validated by delegates, \n         * ... but those that do can enforce:\n         *   (a) creating this list of delegates that must validate\n         *   (b) that the list becomes empty before the change is committed.\n         *   (c) OR that any remaining delegates are validating the committed data\n         * ... as part of the txn completing the change.\n         *\n         * This helps ensure that the change is validated by the right delegates,\n         *  ... without needing all the validation to be done in a single transaction\n         */ \n         remainingDelegateValidations: []DelegateRole\n    }\n}\n\n// data stored in isDelegate Datum (in the delegate's script)\n// ... links back to the capo info\nstruct DelegationDetail {\n    capoAddr: Address\n    mph: MintingPolicyHash\n    tn: ByteArray\n\n    func acAuthorityToken(self) -> AssetClass {\n        AssetClass::new(self.mph, self.tn)\n    }\n    func tvAuthorityToken(self) -> Value {\n        Value::new(\n            AssetClass::new(self.mph, self.tn), 1\n        )\n    }\n}\n\n// Delegates can define additional Datum in their enums,\n// but this first Datum is essential\nenum BASE_DELEGATE_Datum {\n    Cip68RefToken {  \n        cip68meta: AnyData\n        cip68version: Int\n        otherDetails: Data\n    }\n\n    IsDelegation {\n        dd: DelegationDetail\n    }\n    // same variant-index and structure as Capo's DelegatedData\n    capoStoredData {\n        data: AnyData\n        version: Int\n        otherDetails: Data \n    }\n}\n\nfunc mustReturnValueToScript(\n    value : Value, \n    tokenName: ByteArray = #\n) -> Bool {\n    if (!returnsValueToScript( value)) {\n        print(\"failed matching value: \");\n        print(value.show());\n        print(\"\\n\");\n        error(\" ❌ dgTkn not returned: \" + tokenName.decode_utf8_safe())\n        // error(\"the authZor token MUST be returned\")\n    } else { \n    true\n    }\n}\n\n//!!! call with existing delegate Datum.serialize()\nfunc unmodifiedDelegation(oldDD : ByteArray) -> Bool {\n    o : []TxOutput = get_cont_outputs();\n    //    print(\"::::::::::::::::::::::::::::::::: hi \"+o.head.datum.inline.serialize().show());\n\n    assert(o.head.datum.inline.serialize() == oldDD,\n    // \"delegation datum must not be modified\"\n    \"modified dgtDtm\"\n);\n    true\n    // MintDelegateDatum::IsDelegation{\n    //     ddNew, _\n    // } = MintDelegateDatum::from_data( \n        \n    // );\n\n    //! the datum must be unchanged.\n    // ddNew == dd \n}\n\nfunc requiresNoDelegateInput(\n    delegateLink: RelativeDelegateLink, \n    mph: MintingPolicyHash\n) -> Bool {\n    // v : Value = mkTv(mph: mph, tn: delegateLink.uutName);\n    ac : AssetClass = delegateLink.acAuthorityToken(mph);\n    if (tx.inputs.any((i: TxInput) -> Bool {\n        i.value.get_safe(ac) > 0\n    })) {\n        error(\"must not have dgTkn input: \"+delegateLink.uutName)\n    } else {\n        print(\"ok: no dgTkn input: \"+delegateLink.uutName);\n        true\n    }\n}\n\n// just some convenience stuff to lead people to the right place\nstruct delegateLink_hasValidOutput_asMethod {\n    placeHolder: String \n}\n\n// func requiresValidDelegateOutput(\n//     delegateLink: delegateLink_hasValidOutput_asMethod,\n//     mph: MintingPolicyHash, \n//     required: Bool = true\n// ) -> Bool {\n         ///                  vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv\n//     assert(false, \"replaced by delegateLink.hasValidOutput(...)\");\n//     assert(delegateLink==delegateLink, \"no way q\");\n//     assert(mph==mph, \"no\");\n//     assert(required==required, \"no way r\");\n//     true\n// }\n// :ladybug emoji: \"🐞xy\"\n\n// !!! this could be really nice but it's difficult to use it in practice.\n// type-aliasing would be amazing.\nenum SomeDelegateDatum[T] {\n    Cip68RefToken {  \n        // NOTE: this datum contains reference details for a user-facing token minted according to the cip-68 standard \n        //  - the asset name (in the Value of this UTXO) MUST be:  #000643b0 + tokenName\n        //     - this asset name can serve user-side tokens using the CIP-68 \"222\", \"333\" or other token types.\n        //     - the user-side asset name with its (222/333/etc) CIP-67 prefix and \n        //       ... its remaining tokenName will be matched to this asset name (#000643b0 +tokenName)\n        //       ... to locate this reference datum; this datum content will be interpreted\n        //       ... according to the semantics implied by the user-side asset-name prefix.\n        //\n        //  - The attached 'meta' field in this Datum variant contains the relevant data, depending on the token type\n        //    - for \"222\" tokens, the meta field should contain the following fields:\n        //        - \"name\" : String\n        //        - \"description\" : String \n        //        - \"files\" :   // {mediaType, src (url), name?, ... otherFields)\n        //        - \"image\": String  // image url: https://, ar://, ipfs:// or data:// (RFC2397 data)\n        //    - for \"333\" tokens, the meta field should contain the following fields:\n        //        - \"name\" : String\n        //        - \"description\" : String \n        //        - \"ticker\" : String\n\n        //        - \"url\": String  // project URL\n        //        - \"logo\": String  // image url: https://, ar://, ipfs:// or data:// (RFC2397 data)\n        //                    - it must have a mime type `image/png`, `image/jpeg` or `image/svg+xml`\n        //        - \"decimals\" : Int\n\n        meta: AnyData\n        version: Int\n        otherDetails: Data // can be Unit () or anything else\n    }\n\n    IsDelegation {\n        dd: DelegationDetail\n    }\n    // same variant-index as Capo's DelegatedData\n    capoStoredData {\n        data: T\n        version: Int\n        otherDetails: Data \n    }\n\n    // func validateSettings(self, _settings: ProtocolSettings) -> Bool{\n    //   ... get the settings from the manifest via ccts\n    //     assert(false, \"not valid (stubbed)\");\n    //     // settings.serialize() != self.serialize() &&\n    //     true\n    // }    \n}\n", {
    project: "stellar-contracts",
    purpose: "module",
    name:  "src/delegation/CapoDelegateHelpers.hl", // source filename
    moduleName:  "CapoDelegateHelpers",
});

const StellarHeliosHelpers_hl = makeSource(
  "module StellarHeliosHelpers\n\nimport {\n    tx, \n    get_current_input,\n    get_current_validator_hash\n} from ScriptContext\n\n// keep this as-is.  Make RealnumSettingsValueV2 or something else if it needs to change\nstruct RealnumSettingsValueV1 {\n    name: String\n    microInt: Int // \"Real\" semantics, times 1_000_000\n}\n\nfunc didSign(a: Address) -> Bool {\n    pkh : PubKeyHash = a.credential.switch{\n        PubKey{h} => h,\n        Validator => error(\"trustee can't be a contract\")\n        // _ => error(\"trustee can't be a contract\")\n    };\n    // print(\"checking if trustee signed: \" + pkh.show());\n\n    tx.is_signed_by(pkh)\n}\n\nfunc TODO(task: String) -> () {\n    // 🟥  😳💦 red checkbox, face, sweat droplets\n    print(\"  🟥  😳💦  TODO: \" + task + \"\\n\")\n}\n\nfunc TRACE(id: ByteArray, message: String) -> () {\n    // todo: how to prevent the id from being optimized out?\n    print(id.decode_utf8_safe());\n    print(message)\n}\n\nfunc REQT(reqt: String, assertion : Bool=true) -> () {\n    // ❗red exclamation mark\n    print(\"❗ \"+ reqt);\n    assert(assertion, \"  ❌❌ ^ failed: \" + reqt)\n}\nfunc bREQT(reqt: String, assertion : Bool=true) -> Bool {\n    REQT(reqt, assertion);\n    true\n}\n\n//! represents the indicated token name as a Value\nfunc mkTv(\n    mph: MintingPolicyHash, \n    tn: String=\"\", \n    tnBytes: ByteArray=tn.encode_utf8(),\n    count : Int = 1\n) -> Value {\n    assert(tnBytes.length > 0, \"missing reqd tn or tnBytes\");\n    Value::new(\n        AssetClass::new(mph, tnBytes), \n        count\n    )\n}\n\n//! returns the charter-token from our minter, as a Value\nfunc tvCharter(mph: MintingPolicyHash)  -> Value {\n    mkTv(mph: mph, tn: \"charter\")\n}\n\nfunc returnsValueToScript(value : Value) -> Bool {\n    input : TxInput = get_current_input();\n    input.value.contains(value) &&\n    tx.outputs.any( (txo : TxOutput) -> Bool {\n        txo.address == input.address &&\n        txo.value.contains(value)\n    } )\n}\n\n\nfunc getOutputWithValue(v : Value) -> TxOutput {\n    tx.outputs.find((txo: TxOutput) -> { txo.value >= v })\n}\n\nstruct outputAndDatum[T] {\n    output: TxOutput\n    datum: T\n    rawData: Data\n}\n\nfunc getSingleAssetValue(input: TxInput) -> Value{\n    inputMap : Map[MintingPolicyHash]Map[ByteArray]Int = input.value.get_assets().to_map();\n    assert( inputMap.length == 1, \n        \"multiple assets\"\n        // \"getSingleAssetValue needs single-asset input\"\n    );\n\n    inputTokens : Map[ByteArray]Int = inputMap.head_value;\n    assert(inputTokens.length == 1, \n        \"multiple tokens\"\n        // \"getSingleAssetValue needs single-token input\"\n    );\n\n    input.value.get_assets()\n}\n\n// func outputDatum[T](newTxo : TxOutput) -> T {\n//     T::from_data(newTxo.datum.inline)\n// }\n\nfunc getOutputForInput(input: TxInput) -> TxOutput {\n    inputValue : Value = getSingleAssetValue(input);\n\n    getOutputWithValue(inputValue)\n}\n\n//! retrieves the redeemer for a specific input\nfunc mustFindInputRedeemer(\n    txInput: TxInput    \n) -> Data {\n    targetId : TxOutputId = txInput.output_id;\n    redeemers : Map[ScriptPurpose]Data = tx.redeemers;\n    spendsExpectedInput : ScriptPurpose = redeemers.find_key( \n        (purpose : ScriptPurpose) -> { purpose.switch{ \n            sp: Spending => {\n                // print (\"oid: \" + sp.output_id.show());\n                sp.output_id == targetId\n            }, \n            _ => false \n        } }\n    );\n    redeemers.get(spendsExpectedInput)\n}\n\n// XXX this doesn't work because using a field of this type\n//   causes the compiler to believe there would be two enum wrappers,\n//   one for this Solo variant, and another for the T type.\n// Instead, the off-chain code needs to construct the wrapper,\n// but the field needs to pretend there is no wrapper.\n\n// enum NestedTaggedStruct[T] {\n//     Solo{ thing: T }\n\n//     func unwrap(self) -> T {\n//         print(\"NestedTaggedStruct: unwrap\");\n\n//         self.switch {\n//             Solo{ thing } => {\n//                 print(\"NestedTaggedStruct: unwrapped thing\");\n//                 thing\n//             },\n//             _ => error(\"NestedTaggedStruct: unwrap: unknown variant\")\n//         }\n//     }\n// }\n \n// field-names style of struct, arbitrary & extensible\n// field list, can be interpreted by any script that defines a \n// field-names style of struct with its own fields & data types.\nstruct AnyData {\n    id: ByteArray \"@id\"  // same as the UUT name for this data\n    type: String \"tpe\"\n\n    // can have other fields; receiver will interpret their target types.\n}\n\nfunc fromCip68Wrapper(value: Data) -> Data {\n    value.switch {\n        // IntData, ByteArrayData, MapData, ListData and ConstrData\n        ConstrData{_anyIndex, fields} => {\n            fields.head.switch {\n                MapData => fields.head,\n                _ => error(\"bad cast from ConstrData{_, ...fields} to mStruct: first field must be a map\")\n            }\n        },\n        _ => error(\"bad cast to mStruct from non-ConstrData\")\n    }\n}\n\nfunc getTimeRange(granularity: Duration = Duration::HOUR) -> TimeRange {\n    validity : TimeRange = tx.time_range\n    assert(\n        validity.end - validity.start \n            <= granularity,\n        \"txn duration must be at most \"+granularity.show() + \"ms\"\n    );\n    validity\n}\n\nfunc startsExactlyAt(\n    tr: TimeRange,\n    t: Time\n) -> Bool{\n    t == tr.start\n}\n\n// use [optional: tcx.futureData() and] txn.validFor(), then tcx.txnEndTime()\n// to synchronize an off-chain variable with the validity.end seen here.\nfunc endsExactlyAt(\n    tr: TimeRange,\n    t: Time\n) -> Bool{\n    t == tr.end\n}\n\nfunc startsAfter(\n    tr: TimeRange,\n    t : Time\n) -> Bool{\n    tr.start > t\n}\n\nfunc endsBefore(\n    tr: TimeRange,\n    t : Time\n) -> Bool{\n    tr.end < t\n}\n\nfunc now(granularity: Duration = Duration::HOUR) -> Time {\n    validity : TimeRange = getTimeRange(granularity);\n    validity.start\n}        \n\n", {
    project: "stellar-contracts",
    purpose: "module",
    name:  "src/StellarHeliosHelpers.hl", // source filename
    moduleName:  "StellarHeliosHelpers",
});

const CapoHelpers_hl = makeSource(
  "module CapoHelpers \n\nimport {\n    mkTv,\n    tvCharter,\n    mustFindInputRedeemer,\n    outputAndDatum,\n    fromCip68Wrapper,\n    AnyData,\n    REQT,\n    TODO\n} from StellarHeliosHelpers\n\nimport {tx, get_current_input} from ScriptContext\n// import {\n//     TypeMap\n// } from TypeMapMetadata\n\nimport { \n    RelativeDelegateLink,\n    AbstractDelegateActivitiesEnum,\n    CapoLifecycleActivity,\n    DgTknDisposition as DgTkn,\n    DelegateRole,\n    PendingCharterChange    \n} from CapoDelegateHelpers\n\nenum UtxoSource {\n    RefInput\n    Input\n\n}\n\nenum dgd_DataSrc {\n    Unk\n    Input { utxo: TxInput }\n    Output { txo: TxOutput }\n    Both {\n        utxo: TxInput\n        txo: TxOutput\n    }\n    // Reference { ref: TxInput }\n}\n\n/**\n * Future: we can require for named tokens to be chartered explicitly\n * by the protocol before they can be minted using this structure.  However,\n * This would only be worthwhile if this structure provides a clear benefit,\n * in terms of reliable enforcement of policy constraints such as supply limits.\n * \n * For now, we leave it out (govAuthority can authorize arbitrary token minting),\n * with a placeholder on the roadmap for a future extension to add\n * constraint expression + enforcement.  In that future moment, we can \n * adopt this kind of extension to the manifest, or we can use a specific type of\n * dgDataPolicy for this purpose, with this structure as a prototype to be pushed\n * down into its internal structure.\n */\nstruct MftDetails {\n    // the token name is mapped to this ManifestEntryType\n    maxSupply: Option[Int]\n    // supplyMintingRecords: []SupplyMintingRecord // points to an aggregate receipt \n\n    func validate(self) -> Bool {\n        REQT(\"MintsFungibleToken: has forward-looking/placeholder structure for future constraint enforcement\");\n\n        self.maxSupply.switch {\n            Some => error(\"maxSupply not yet supported\"),\n            None => true\n        } \n        // && (\n        //     self.supplyMintingRecords.length > 0\n        // ).trace(\"empty supplyMintingRecords? \")\n    }\n}    \n\nenum ManifestEntryType {\n    // the name (entry's key) is simply a reference to a specific token \n    // (typically a specific kind of dgData record \n    //  ...using application-specific convention)\n    NamedTokenRef \n    // the referenced token controls a specific type of dgData record,\n    // ... indicated by the entry's key.  With refCount, it inventories multiple \n    // ... thread tokens, each held by the delegate contract, for parallelism.\n    DgDataPolicy {\n        policyLink: RelativeDelegateLink\n        idPrefix: String\n        refCount: Int\n    }\n    // the referenced token inventories thread-tokens for a specific delegate role\n    //  ... the key is expected to match that delegate role (\n    //    mintDgt, spendDgt, mintInvar, spendInvar,\n    //    govDgt, or ‹name› of otherNamedDelegate)\n    // the first thread doesn't ever require a manifest entry,\n    // ... and the first forked thread makes an entry with refCount = 2\n    DelegateThreads {\n        role: DelegateRole \n        refCount: Int\n    }\n    // the referenced token is a merkle-root of a membership-proof-tree\n    MerkleMembership \n\n    // the referenced token is a merkle-root of a state-root-tree\n    MerkleStateRoot    \n\n    /** the referenced token name has been chartered as an \"official\" \n     * asset class as part of this protocol.  See notes above for roadmap guidance.\n     */\n    // xxxMintsFungibleToken {\n    //     mftDetails: MftDetails\n    // }\n\n    // func validate(self) -> Bool {\n    //     self.switch {\n    //         MintsFungibleToken{mftDetails} => mftDetails.validate(),\n    //         _ => true\n    //     }\n    // }\n}\n\n/*\n * The UtxoManifest is a data structure that references a set of UUTs\n * that are important to the operation of a Capo (and its family of contract \n * scripts).  It is used to maintain positive control over these operational\n * UUTs, inventorying them and giving every transaction a way to easily\n * reference their data for validation, operation, and reporting.\n *\n * A prime use-case for the capo's Manifest is for storing protocol-settings \n * data (\"settings\").  Any application will need its own defined data structures\n * for settings, but the \"settings\" key is reserved for this general purpose.\n * The protocol ensures that every collaborating script (\"delegate\") has a\n * chance to validate any new settings before the (updated settings or the \n * delegate, during installation) are activated.\n *\n * An additional case for manifest entries is for UUTs used as \"thread tokens\",\n * where multiple separate contract utxos are used to manage independent\n * threads of parallel operation for a single contract.  This provides a scalability\n * mechanism.\n */\nstruct CapoManifestEntry {\n    // key: String // redundant / same as its map-key\n    entryType: ManifestEntryType \"tpe\"\n    tokenName: ByteArray \"tn\"\n    mph: Option[MintingPolicyHash] // default = Capo's MPH\n    \n    func validate(self) -> Bool {\n        // 3 bytes plus encoding overhead\n        print(\"foo\".serialize().length.show() + \"<-- 3 chars has this serialized length\");\n        // assert(self.key.serialize().length > 5, \"key too short\");\n        // assert(\"settings\" == self.key, \"manifest only supports 'settings' for now\");\n\n        assert(self.tokenName.length > 0, \"no token name\");\n        // assert(self.refCount == 1, \"only one ref allowed for now\");\n        // assert(!self.isThreadToken, \"thread tokens not yet supported\");\n        self.mph.switch {\n            Some => error(\"custom mph not yet supported\"),\n            _ => true\n        }\n    }\n}\n\n// func mkTokenShow(mph: MintingPolicyHash) -> (Value) -> String {\n//     (v: Value) -> String {\n//         others : String = Value::from_map(\n//             v.get_assets().to_map().filter( (someMph: MintingPolicyHash, _) -> Bool {\n//                 mph != someMph\n//             })\n//         ).show();\n//         ada : String = (\n//             (\n//                 (0.0 + v.get_lovelace()) / 1_000.0\n//             ).round() / 1_000.0\n//         ).show() + \" ADA\";\n//         mine : String = v.get_policy(mph).fold[[]String]( (previous: []String, tokenName: ByteArray, c: Int) -> []String {\n//             tn = tokenName.decode_utf8();\n//             []String{\n//                 c.show(), \"×💴 \", tn\n//             } + previous\n//         }, []String{}).join(\" + \");\n//         // v.assets()\n\n//         mine + \" + \" + ada  + others\n//     }\n// }\n\n/**************************************************************\n      ************************************************************\n      ************************************************************\n      *******************                      *******************\n      *******************                      *******************\n      *******************        CapoDatum     *******************\n      *******************                      *******************\n      *******************                      *******************\n      ************************************************************\n      ************************************************************\n      ************************************************************\n*/      \n\nenum CapoDatum {\n    CharterData {\n        spendDelegateLink: RelativeDelegateLink\n        spendInvariants: []RelativeDelegateLink\n        otherNamedDelegates: Map[String]RelativeDelegateLink\n        mintDelegateLink: RelativeDelegateLink\n        mintInvariants: []RelativeDelegateLink\n        govAuthorityLink: RelativeDelegateLink\n        manifest: Map[String]CapoManifestEntry\n        pendingChanges: []PendingCharterChange\n        // typeMapUut: Option[ByteArray]   // optional reference to a UUT having TypeMapInfo datum\n    }\n    ScriptReference\n    // settings are now just a distinguished case of delegated data\n    // ... for contracts that use settings,\n    // ... instead of being a special type of Datum\n    // SettingsData {\n    //     data:  Map[String]Data\n    // }\n\n    // same variant-index as delegate's capoStoredData:\n    DelegatedData {  // the Capo redirects control of these to the spend delegate\n        data: Map[String]Data // matches pattern of AnyData + other fields // the spend delegate may redirect control further, depending on what it sees in there\n        version: Int // for CIP-68 compatibility\n        otherDetails: Data // abstract additional info\n    }\n\n    func hasCharterRefInput(\n        self,\n        mph : MintingPolicyHash\n    ) -> Option[CapoDatum::CharterData] {\n        assert(false, \"deprecated use of hasCharterRefInput(); use CapoCtx instead.\");\n\n        assert( // avoid \"unused variable self\" error\n            true || ( /* never executed */\n                self.serialize() != mph.serialize()\n            ), \"never thrown\"\n        );\n        assert(false, \"unused?\"); // see standalone getRefCharterData()\n        \n        // chVal : Value = tvCharter(mph);\n        charterAc : AssetClass = AssetClass::new(mph, \"charter\".encode_utf8());\n        hasCharter = (txin : TxInput) -> Bool { txin.value.get_safe(charterAc) > 0 };\n\n        tx.ref_inputs.find_safe(hasCharter).switch{\n            Some{txin} => Option[CapoDatum::CharterData]::Some{\n                CapoDatum::from_data( \n                    txin.datum.inline\n                ).switch{\n                    c : CharterData => c,\n                    _ => error(\"wrong enum\")\n                }\n            },\n            None => Option[CapoDatum::CharterData]::None\n        }\n    }\n\n    func countUpdatedThings(self, oldDatum: CapoDatum) -> Int {\n        self.switch {\n            CharterData{ \n                nextSpendDelegate, \n                nextSpendInvariants, \n                nextNamedDelegates, \n                nextMintDelegate, \n                nextMintInvariants, \n                nextGovDelegate, \n                nextManifest,\n                _nextPendinghanges\n            } => {\n                CharterData {\n                    oldSpendDelegate,\n                    oldSpendInvariants,\n                    oldNamedDelegates,\n                    oldMintDelegate,\n                    oldMintInvariants,\n                    oldGovDelegate,\n                    oldManifest,\n                    _oldPendingChanges\n                } = oldDatum;\n                changedSpendDgt : Bool = ( nextSpendDelegate.serialize() != oldSpendDelegate.serialize() );\n                changedSpendInvariants : Bool = ( nextSpendInvariants != oldSpendInvariants );\n                changedNamedDelegate : Bool = ( nextNamedDelegates.serialize() != oldNamedDelegates.serialize() );\n\n                changedMintDgt : Bool = ( nextMintDelegate.serialize() != oldMintDelegate.serialize() );    \n                changedMintInvariants : Bool =  ( nextMintInvariants != oldMintInvariants );\n                changedGovDelegate : Bool = ( nextGovDelegate.serialize() != oldGovDelegate.serialize() );\n                changedManifest : Bool = ( nextManifest.serialize() != oldManifest.serialize() );\n    \n                if ((changedSpendDgt).trace(\" -- spendDgt changed? \") ) { 1 } else { 0 } +\n                if ((changedSpendInvariants).trace(\" -- spendInvs changed? \") ) { 1 } else { 0 } +\n                if (changedNamedDelegate.trace(\" -- namedDgt changed? \") ) { 1 } else { 0 }+\n                if ((changedMintDgt).trace(\" -- mintDgt changed? \") ) { 1 } else { 0 } +\n                if ((changedMintInvariants).trace(\" -- mintInvs changed? \") ) { 1 } else { 0 } +\n                if ((changedGovDelegate).trace(\" -- govDgt changed? \")) { 1 } else { 0 } +\n                if ((changedManifest).trace(\" -- manifest changed? \") ) { 1 } else { 0 }\n            },\n            _ => error(\"only CharterData datum can count updated things\")\n        }\n    }\n\n    // func mustFindSettingsOutput(self, mph: MintingPolicyHash, inAddr: Address) -> outputAndDatum[CapoDatum::SettingsData] {\n    //     settingsVal : Value = mkTv(mph: mph, tnBytes: self.switch {\n    //         ct: CharterData => {\n    //             print( \" ⬅️ 🔎 finding settings output: \"+ ct.settingsUut.decode_utf8() + \"\\n\");\n    //             ct.settingsUut\n    //         },\n    //         _ => error(\"mustFindSettings - only valid on CharterData datum\")\n    //     });\n        \n    //     notFound = Option[outputAndDatum[CapoDatum::SettingsData]]::None;\n    //     foundSettings: []outputAndDatum[CapoDatum::SettingsData] = \n    //         tx.outputs.map_option[\n    //             outputAndDatum[CapoDatum::SettingsData]\n    //         ](\n    //              (output: TxOutput) -> Option[outputAndDatum[CapoDatum::SettingsData]] {\n    //                 if ( output.address != inAddr ) {\n    //                     // print(\"not the right address\");\n    //                     notFound\n    //                 } else {\n    //                     rawDatum : Data = output.datum.inline;\n    //                     CapoDatum::from_data(\n    //                         rawDatum\n    //                     ).switch {\n    //                         settings: SettingsData => {\n    //                             Option[\n    //                                 outputAndDatum[CapoDatum::SettingsData]\n    //                             ]::Some{\n    //                                 outputAndDatum[CapoDatum::SettingsData] {\n    //                                     output, settings, rawDatum\n    //                                 }\n    //                             }\n    //                         },\n    //                         _ => {\n    //                             // print(\"found non-SettingsData\");\n    //                             notFound\n    //                         }\n    //                     }\n    //                 }\n    //             }\n    //         );\n\n    //     assert(foundSettings.length < 2, \"too many settings outputs\") ;\n    //     assert(foundSettings.length == 1, \"no settings output\");\n\n    //     settingsOutput : TxOutput = foundSettings.head.output;\n    //     assert(\n    //         // already checked above.\n    //         // settingsOutput.address == charter.owner &&\n    //         settingsOutput.value.contains(settingsVal),\n    //             \"settings output not found in contract with expected UUT\"\n    //     );\n    //     assert(settingsVal.contains(settingsOutput.value.get_assets()), \n    //         \"excess value in settings output: \"+(settingsOutput.value - settingsVal).show()\n    //     );\n    //     print(\"\\n ⬅️ ✅ found CapoDatum::SettingsData\\n\");\n    //     foundSettings.head\n    //     // ^^ fails if there's no settings output to the right address\n\n    // }\n}\n\nenum cctx_CharterInputType {\n    Unk\n    RefInput { \n        datum: CapoDatum::CharterData\n        utxo: TxInput\n    }\n    Input { \n        datum: CapoDatum::CharterData \n        utxo: TxInput \n    }\n    // Minting {\n    //     datum: CapoDatum::CharterData\n    //     address: Address\n    // }\n}    \n\n/**************************************************************\n      ************************************************************\n      ************************************************************\n      *******************                      *******************\n      *******************                      *******************\n      *******************      CapoActivity    *******************\n      *******************                      *******************\n      *******************                      *******************\n      ************************************************************\n      ************************************************************\n      ************************************************************\n*/      \n\nenum CapoActivity {\n    capoLifecycleActivity { // variant 0 mostly delegated to spendDgt\n        activity: CapoLifecycleActivity\n    }\n    usingAuthority // variant 1\n    retiringRefScript // variant 2\n    addingSpendInvariant // variant 3\n    spendingDelegatedDatum // variant 4\n\n    // // possibly move this into CapoLifecycleActivity:\n    // updatingManifest { // variant 5 always delegated to spendDgt\n    //     activity: ManifestActivity\n    // }\n    updatingCharter // deprecated variant 5\n}\n\nfunc getRefCharterUtxo(mph : MintingPolicyHash) -> TxInput {\n    // chVal : Value = tvCharter(mph);\n    charterAc : AssetClass = AssetClass::new(mph, \"charter\".encode_utf8());\n    hasCharter = (txin : TxInput) -> Bool { txin.value.get_safe(charterAc) > 0 };\n    print(\"getting ref_input for charter\\n\");\n    charterUtxo : TxInput = tx.ref_inputs.find_safe(hasCharter).switch{\n        Some{ch} => ch,\n        //!!! todo adjust this message: Missing required charter in ref_inputs\n        None => {\n            error(\"Missing charter in required ref_inputs (use tcxWithCharterRef(tcx) in txn building functions)\")\n        }\n    };\n\n    charterUtxo\n}\n\nfunc getRefCharterData(mph : MintingPolicyHash) -> CapoDatum::CharterData {\n    charterUtxo : TxInput = getRefCharterUtxo(mph);\n    ctd : CapoDatum::CharterData = CapoDatum::CharterData::from_data( \n        charterUtxo.datum.inline\n    );\n\n    ctd\n}\n\n//! retrieves a required Capo Charter datum for the indicated minting-policy - \n// ... either from the txn's reference inputs  or inputs.\n// prefer mkCapoCtx.needsCharter() for \"get from anywhere\" semantics\n// and cctx.getCharterData() to get the datum\n//  (... or mkCapoCtx.withCharterRef() to require unchanged charter)\n//  (... or mkCapoCtx.withCharterInput() to require the charter to be spent & maybe updated)\nfunc getTxCharterData(\n    mph : MintingPolicyHash,\n    refInputs : []TxInput = tx.ref_inputs\n) -> CapoDatum::CharterData {\n    // chVal : Value = tvCharter(mph);\n    charterAc : AssetClass = AssetClass::new(mph, \"charter\".encode_utf8());   \n    hasCharter = (txin : TxInput) -> Bool { txin.value.get_safe(charterAc) > 0 };\n\n    charterUtxo : TxInput = refInputs.find_safe(hasCharter).switch{\n        Some{ch} => ch,\n        None => tx.inputs.find_safe(hasCharter).switch{\n            Some{ch} => ch,\n            None => error(\"Missing charter inputs / ref_inputs\")\n        }\n    };\n    ctd : CapoDatum::CharterData = CapoDatum::CharterData::from_data( \n        charterUtxo.datum.inline\n    );\n\n    ctd\n}\n\nfunc mustHaveGovAuthority(\n    mph : MintingPolicyHash,\n    charterData : CapoDatum::CharterData = getTxCharterData(mph)\n) -> Bool {\n    charterData.govAuthorityLink.hasValidOutput(mph)\n}\n\n/**************************************************************\n      ************************************************************\n      ************************************************************\n      *******************                      *******************\n      *******************                      *******************\n      *******************     DelegateInput    *******************\n      *******************                      *******************\n      *******************                      *******************\n      ************************************************************\n      ************************************************************\n      ************************************************************\n*/\n\n/**\n * A high-level helper for delegates, enabling various kinds of\n * validation and delegation-related operations.  Although this\n * is defined as related to an \"Input\", this object provides a gateway\n * for any script to involve that delegate policy in the abstract, by\n * virtue of having included that input in the transaction.\n * Callers should expect that the other policy will\n * do its responsibilities and may use this object to enforce that\n * the other policy is **triggered** in expected ways.\n */\nstruct DelegateInput {\n    link: RelativeDelegateLink\n    role: DelegateRole\n    idPrefix: Option[String]\n    input: Option[TxInput]\n    mph: MintingPolicyHash\n\n    func genericDelegateActivityAsData(self) -> Data {\n        i : TxInput = self.input.unwrap();\n        inputData : Data = mustFindInputRedeemer(i);\n        inputData.switch {\n            ConstrData{index, fields} => {\n                // ladybug emoji: \"🐞\"\n                print(\"    --🐞 generic delegate activity at index \"+ index.show() );\n                fields.head.switch {\n                    ConstrData{index2, _fields2} => {\n                        print(\"    --🐞 nested activity at index \"+ index2.show() )\n                    }\n                }\n                // doesn't get optimized out:\n                // inpIdStr = i.output_id.tx_id.show() + \"🔹#\" + i.output_id.index.show();\n                // valStr = i.value.show();\n                // print(\"    ---- from input id:\" + inpIdStr + \" = \"+valStr)\n            } \n        };\n        inputData\n    }\n\n    func genericDelegateActivity(self) -> AbstractDelegateActivitiesEnum {\n        AbstractDelegateActivitiesEnum::from_data(\n            self.genericDelegateActivityAsData()\n        )\n    }    \n\n    /**\n     * Throws an error message including the delegation token id,\n     * if the assertion is false.\n     */\n     func assert(self, assertionOk : Bool, msg: String) -> () {\n        assert(true || /* never executed */ self.serialize() == self.serialize(), msg);\n        if(assertionOk) { assert(true, \"\" ) } else {\n            self.error(msg)\n        }\n     }\n\n    /**\n     * Throws an error message including the delegation token id.\n     */     \n    func error(self, msg: String) -> () {\n        assert(true || /* never executed */ self.serialize() == self.serialize(), msg);\n        // warning emoji: \"⚠️\"\n        print(\"⚠️ ⚠️ ⚠️ error executing policy for dgTkn: \"+ self.link.uutName);\n        print(\"     ---- with input value: \"+ self.input.unwrap().value.show());\n        // print( mkTokenShow(self.mph)(\n        //         (self.input.unwrap().value)\n        //     )\n        // );\n        print(\"\\n\");\n        assert(false, msg)\n    }\n\n    func withSpendingActivity(self) -> DelegateInput {\n        self.genericDelegateActivity().switch {\n            SpendingActivities => self,\n            _ => {\n                self.error(\"non-spend activity!\");\n                error(\"\")\n            }\n        }\n    }\n\n    func withMintingActivity(self) -> DelegateInput {\n        self.genericDelegateActivity().switch {\n            MintingActivities => self,\n            _ => {\n                self.error(\"non-mint activity!\"); \n                error(\"\") \n            }\n        }\n    }\n\n    func updatingManifest(self) -> DelegateInput {\n        self.role.switch {\n            SpendDgt => {\n                print(\"checking presence of SpendDgt: updatingManifest activity\");\n                self.genericDelegateActivity().switch {                    \n                    CapoLifecycleActivities{cla} => cla.switch {\n                        updatingManifest => self,\n                        _ => {\n                            self.error(\"not using required updatingManifest activity\");\n                            error(\"\") // unreachable\n                        }\n                    },\n                    _ => {\n                        self.error(\"updatingManifest: only valid for CapoLifecycleActivities\");\n                        error(\"unreachable\")\n                    }\n                }\n            },\n            _ => {\n                self.error(\"updatingManifest: only valid for SpendDgt\");\n                error(\"unreachable\")\n            }\n        }\n    }\n\n    func withUniqueSeededMintingActivity(self, seed: TxOutputId) -> DelegateInput {\n        // tnFactory : (String) -> String = mkUutTnFactory(seed);\n\n        REQT(\"withUniqSeededMinting: ensures the delegate is unchanged, so callers needn't.\");\n        self.genericDelegateActivity().switch {\n            MintingActivities{ma} => {\n                ma.switch {\n                    ConstrData{_index, fields} => {\n                        // assert(index==index, \"no way\"); // unused field can't be _\n                        assert(\n                            seed == TxOutputId::from_data(fields.get(0)),\n                            \"seed mismatch\"\n                        )\n                    },\n                    _ => error(\"no way\")\n                };\n                self.delegateUnchanged()\n            },\n            MultipleDelegateActivities{activities} => {\n                // can do one or more minting activities, but each one needs to be bound to a separate seed\n                assert(activities.length > 0, \"no minting activities found\");\n                foundWithThisSeed : []Data = activities.filter( (a : Data) -> Bool {\n                    AbstractDelegateActivitiesEnum::from_data(a).switch {\n                        MintingActivities{ma} => {\n                            ma.switch {\n                                ConstrData{index, fields} => {\n                                    assert(index==index, \"no way c\"); // unused field can't be _ in switch\n                                    seed == TxOutputId::from_data(fields.head) &&\n                                    true\n                                },\n                                _ => error(\"no way d\")\n                            }\n                        },\n                        _ => false\n                    }\n                });\n                REQT(\"one of the delegate multi-activities must be minting with this seed\");\n                self.assert(foundWithThisSeed.length > 0, \"no minting activity found for seed!\");\n                REQT(\"only one of a multi-activity for a given seed is allowed\");\n                self.assert(foundWithThisSeed.length == 1, \"multiple minting activities found for seed\");\n\n                self.delegateUnchanged()\n            },\n            _ => {\n                self.error(\"non-mint activity!\");\n                error(\"\")\n            }\n        }\n    }\n\n    func withUniqueDDSpendingActivity(self, recId: ByteArray) -> DelegateInput {\n        self.role.switch {\n            DgDataPolicy => print(\"ok, checking spending activity for a DgData Policy\"),\n            _ => error(\"withUniqueDDSpendingActivity: only valid for DgDataPolicy\")\n        };\n\n        REQT(\"withUniqueDDSpendingActivity: checks presence of delegated-data controller's spending activity for recId\");\n        strId : String = recId.decode_utf8();\n        print(\"    -- recId: \"+ strId);\n\n        TODO(\"TEST THIS v\");\n        REQT(\"spendDgt must be acting on the matching record-id\");\n        REQT(\"ensures the delegate is unchanged, so callers needn't also check that\"); \n\n        self.genericDelegateActivity().switch {\n            SpendingActivities{sa} => {\n                sa.switch {\n                    ConstrData{index, fields } => {\n                        assert(index==index, \"no way e\"); // unused field can't be _\n                        foundRecId: ByteArray = ByteArray::from_data(fields.head);\n                        if(recId != foundRecId) {\n                            print(\"  -- expected: Spending:\"+strId);\n                            print(\"  -- actual: Spending:\"+foundRecId.show());\n                            self.error(\"recId mismatch\")\n                        } else {\n                            print (\"  -- ok: DD controller spending activity for \"+strId)\n                        }\n                    },\n                    _ => error(\"no way f\")\n                };\n                self.delegateUnchanged()\n            },\n            MultipleDelegateActivities{activities} => {\n                print( \"    -- multiple activities found\\n\" );\n                self.assert(activities.length > 0, \"no spending activities found\");\n                // can do one or more spending activities, but each one needs to be bound to a separate recId\n                actsOnThisRecord : []Data = activities.filter( (a : Data) -> Bool {\n                    AbstractDelegateActivitiesEnum::from_data(a).switch {\n                        CreatingDelegatedData => {\n                            self.error(\n                                \"dgInput: withSpendingActivity: CreatingDelegatedData invalid\"\n                            );\n                            error(\"\")\n                        },\n                        UpdatingDelegatedData => {\n                            self.error(\n                                \"dgInput: withSpendingActivity: UpdatingDgData invalid; use a Spending variant in the delegated-data policy\"\n                            );\n                            error(\"\")\n                            // \" not the delegate controller's activities (use SpendingDelegatedData for that)\"\n                        },\n                        DeletingDelegatedData => {\n                            self.error(\n                                \"dgInput: withSpendingActivity: DeletingDelegatedData invalid\" \n                                // is only valid in context of a mintDgt- when destroying a data record\n                            );\n                            error(\"\")\n                        },\n                        SpendingActivities{sa} => {\n                            // assert(false && sa.serialize() == sa.serialize(), \"no way g\");\n                            // false\n                            sa.switch {\n                                ConstrData{index, fields} => {\n                                    assert(index==index, \"no way h\"); // unused field can't be _\n                                    foundRecId: ByteArray = ByteArray::from_data(fields.head);\n                                    if(recId != foundRecId) {\n                                        print(\"  -- expected: Spending: \"+strId);\n                                        print(\"\\n  -- actual: Spending: \"+foundRecId.show());\n                                        self.error(\"recId mismatch\");\n                                        error(\"\")\n                                    } else { true }\n                                },\n                                _ => {\n                                    self.error(\"wrong structure for spending activity\");\n                                    error(\"\")\n                                }\n                            }\n                        },\n                        \n                        _ => false\n                    }\n                });\n                REQT(\"one of the delegate data-controller multi-activities must treat this recId\");\n                self.assert(\n                    (actsOnThisRecord.length > 0).trace(\"dgt acting on this recId? \")\n                    , \"no spending activity found for recId: \"+strId\n                );\n                REQT(\"only one of a multi-activity for a given recId is allowed\");\n                self.assert(\n                    (actsOnThisRecord.length == 1).trace(\"exactly one activity? \")\n                    , \"multiple spending activities found for recId: \"+strId\n                );\n                self.delegateUnchanged()\n            },\n            _ => {\n                self.error(\"non-spend activity!\");\n                error(\"\")\n            }\n        }\n    }\n\n    func requiresValidOutput(self, createdOrReturned : DgTkn=DgTkn::Returned) -> Bool {\n        // TODO - would want this to be able to call our assert/error methods\n        self.link.hasValidOutput(\n            mph: self.mph, \n            required: true,\n            createdOrReturned: createdOrReturned\n        )\n    }\n\n    func getActivity[ACTIVITY](self) -> ACTIVITY {\n        ACTIVITY::from_data(\n            mustFindInputRedeemer(self.input.unwrap())\n        )\n    }\n\n    func getDatum[DATUM](self) -> DATUM {\n        DATUM::from_data(\n            self.input.unwrap().datum.inline\n        )\n    }\n\n    func delegateUnchanged(self) -> DelegateInput {\n        DelegateInput{link, _role, _idPrefix, input, mph} = self;\n\n        RelativeDelegateLink{\n            uut,\n            validatorHash,\n            _configJson\n        } = link;\n        targetValue : Value = link.tvAuthorityToken(mph);\n        returnedUnchanged : Bool = validatorHash.switch {\n            Some{vh} => {\n                // print(\" ⬅️ 🔎 💁 expect dgTkn \"+uut + \" sent to vh \" + vh.show());\n                self.assert(\n                    tx.value_locked_by(vh)   .\n                    contains(\n                        targetValue\n                    ), \n                    \"dgTkn not returned: \"+ uut\n                );\n                tx.outputs.find_safe((o : TxOutput) -> Bool {\n                    o.datum.serialize() == input.unwrap().datum.serialize()\n                }).switch {\n                    Some => {\n                        print(\" -- good, the dgTkn is unchanged: \"+uut);\n                        true\n                    }, \n                    None => {\n                        self.error(\"dgt modified\");\n                        error(\"\")\n                    }\n                }\n            },\n            None => {\n                self.error(\"unchOut - no vh\"); // this method not valid on non-contract delegate tokens\n                error(\"\")\n                // todo maybe make it valid by enforcing return to the input address?\n            }\n        };\n        assert(returnedUnchanged, \"no\"); // already thrown\n        assert(link.hasValidOutput(mph), \"no\"); // thrown inside the method\n\n        self\n    }\n    // syntax sugar.  Implied is that that any other function calls will trip errors,\n    func orFail(self) -> Bool {\n        // assert(true || /* never executed */ self.serialize() == self.serialize(), \"no way i\");\n        _t = self;\n        true\n    }\n}\n\n// func genericDelegateActivity(\n//     link: RelativeDelegateLink,\n//     input: TxInput\n// ) -> DelegateActivity[AbstractDelegateActivitiesEnum] {\n//     DelegateActivity[AbstractDelegateActivitiesEnum]::new{\n//         link,\n//         input,\n//         // datum: Option[DATUM]::None,\n//         activity: Option[AbstractDelegateActivitiesEnum]::None\n//     }\n// }\n\n\n/**************************************************************\n      ************************************************************\n      ************************************************************\n      *******************                      *******************\n      *******************                      *******************\n      *******************     DgDataDetails    *******************\n      *******************                      *******************\n      *******************                      *******************\n      ************************************************************\n      ************************************************************\n      ************************************************************\n*/      \n\n\nstruct DgDataDetails {\n    dataSrc: dgd_DataSrc\n    // filteredInputs: []TxInput\n    id: ByteArray\n    type: String\n    mph: MintingPolicyHash\n    // inputs: []TxInput\n\n    // see CapoCtx::updatingDgData(id)\n    func updating(id : ByteArray, input: TxInput, output : TxOutput, mph : MintingPolicyHash) -> DgDataDetails {\n        DgDataDetails{\n            dataSrc: dgd_DataSrc::Both{input, output},\n            id: id,\n            type: \"\",\n            mph: mph\n        }\n    }\n    \n    // see CapoCtx::creatingDgData(id)\n    func creating(id : ByteArray, output : TxOutput, mph : MintingPolicyHash\n    ) -> DgDataDetails {\n        DgDataDetails{\n            dataSrc: dgd_DataSrc::Output{output},\n            id: id,\n            type: \"\",\n            mph: mph\n        }\n    } \n\n    func uutValue(self) -> Value {\n        Value::new(\n            AssetClass::new(self.mph, self.id), \n            1\n        )\n    }\n\n    // func withOutput(id : ByteArray, input: []TxInput, output : TxOutput) -> DgDataDetails {\n    //     DgDataDetails{\n    //         dataSrc: dgd_DataSrc::Output{output},\n    //         // filteredInputs: []TxInput{},\n    //         id: id,\n    //         type: \"\"\n    //         // inputs: inputs\n    //     }\n    // }\n\n    // func withInput(self) -> DgDataDetails {\n    //     assert(self.id.length > 0, \"no id; try cctx.updatingDgDat (id)\");\n    //     self.dataSrc.switch {\n    //         Input => self,\n    //         Both => self,\n    //         _ => {\n    //             oneInput: []TxInput = self.filterInputs();\n    //             assert(1 == oneInput.length, \"yikes! too many inputs\");\n    //             dataSrc : dgd_DataSrc = self.dataSrc.switch {\n    //                 Unk => dgd_DataSrc::Input{oneInput.head},\n    //                 Output{txo} => dgd_DataSrc::Both{oneInput.head, txo},\n    //                 _ => error(\"no way j \") // already returned self\n    //             };\n\n    //             DgDataDetails{\n    //                 dataSrc: dataSrc,\n    //                    // filteredInputs: oneInput,\n    //                 id: self.id,\n    //                 type: self.type,\n    //                 inputs: self.inputs\n    //             }\n    //         }\n    //     }\n    // }\n\n    func input(self) -> TxInput {\n        // assert(1 == self.filteredInputs.length, \"use withId(id)\");\n        // assert(self.id.length > 0, \"use withId(id) or cctx.updatingDgData(id).withInput()\");\n\n        // self.inputs.head\n        self.dataSrc.switch {\n            Input{utxo} => utxo,\n            Both{utxo, _} => utxo,\n            _ => error(\"no input data; use findInput() first\")\n        }\n    }\n\n    func output(self) -> TxOutput {\n        self.dataSrc.switch {\n            Output{txo} => txo,\n            Both{_, txo} => txo,\n            _ => error(\"no output data\")\n        }\n    }\n\n    // doesn't work - something about the way the IR is generated?\n    //   - seems like it might be the list operations, \n    //   - or scoping of the fields of type []TxInput?\n    //\n    // func findInput(self) -> DgDataDetails {\n    //     self.dataSrc.switch {\n    //         Input => self,\n    //         Both => self,\n    //         _ => {\n    //             targetId : ByteArray = self.id;\n    //             isEmpty : Bool = targetId.length == 0;\n    //             print(\"finding input dgData id: \"+self.id.decode_utf8());\n    //             utxo: TxInput = self.inputs.find_safe( (txin : TxInput) -> Bool {\n    //                 rec : AnyData = AnyData::from_data(\n    //                     txin.datum.inline\n    //                 );\n    //                 rec.type.starts_with(self.type)\n    //                 && (isEmpty || rec.id == targetId)\n    //             }).switch {\n    //                 Some{x} => x,\n    //                 None => error(\"❌ no input dgData\")\n    //             };\n    //             newSrc: dgd_DataSrc = self.dataSrc.switch {\n    //                 Output{txo} => dgd_DataSrc::Both{utxo, txo},\n    //                 Unk => dgd_DataSrc::Input{utxo},\n    //                 _ => error(\"no way k\") // unreachable\n    //             };\n\n    //             DgDataDetails{\n    //                 dataSrc: newSrc,\n    //                 // filteredInputs: [utxo],\n    //                 id: self.id,\n    //                 type: self.type,\n    //                 inputs: self.inputs\n    //             }\n    //         }\n    //     }\n    // }\n\n\n    // func filterInputs(self) -> []TxInput {\n    //     self.inputs\n    //     // targetId : ByteArray = self.id;\n    //     // isEmpty : Bool = targetId.length == 0;\n    //     // self.inputs.filter( (txin : TxInput) -> Bool {\n    //     //     rec : AnyData = AnyData::from_data(\n    //     //         txin.datum.inline\n    //     //     );\n\n    //     //     rec.type.starts_with(self.type)\n    //     //     && (isEmpty || rec.id == targetId)\n    //     // })\n    // }\n\n    // func withFilteredInputs(self) -> DgDataDetails {\n    //     //!!! causes IR assertion error\n    //     // if (self.filteredInputs.is_empty()) {\n    //     // if (self.filteredInputs.length == 0) {\n    //     if(true) {\n    //             self\n    //         // DgDataDetails {\n    //         //     dataSrc: self.dataSrc,\n    //         //     filteredInputs: self.filterInputs(),\n    //         //     id: self.id,\n    //         //     type: self.type,\n    //         //     inputs: self.inputs\n    //         // }\n\n    //     // dataSrc: dgd_DataSrc\n    //     // filteredInputs: []TxInput\n    //     // id: ByteArray\n    //     // type: String\n    //     // inputs: []TxInput\n    \n    //     } else {\n    //         self\n    //     }\n    // }\n\n    func inputData(self) -> Data {\n        self.input().datum.inline.switch {\n            ConstrData{_, fields} => fields.head,\n            _ => error(\"expected ConstrData{mStruct} for DgData input\")\n        }\n        // self.dataSrc.switch {\n        //     Input{utxo} => utxo.datum.inline,\n        //     Both{utxo, _} => utxo.datum.inline,\n        //     _ => error(\"no input data\")\n        // }\n    }\n\n    func outputData(self) -> Data {\n        self.output().datum.inline.switch {\n            ConstrData{_, fields} => fields.head,\n            _ => error(\"expected ConstrData{mStruct} for DgData output\")\n        }\n\n        // self.dataSrc.switch {\n        //     Output{txo} => txo.datum.inline,\n        //     Both{_, txo} => txo.datum.inline,\n        //     _ => error(\"no output data\")\n        // }\n    }\n    \n    // func mustHaveUut(self, uut: String) -> Bool {\n    //     // todo\n    //     false\n    // }\n}\n\n/**************************************************************\n      ************************************************************\n      ************************************************************\n      *******************                      *******************\n      *******************                      *******************\n      *******************        CapoCtx       *******************\n      *******************                      *******************\n      *******************                      *******************\n      ************************************************************\n      ************************************************************\n      ************************************************************\n*/      \n\nstruct CapoCtx {\n    mph: MintingPolicyHash\n    charter: cctx_CharterInputType\n\n    func mkTv(self,\n        tn: String = \"\",\n        tnBytes : ByteArray = tn.encode_utf8(),\n        count : Int = 1\n    ) -> Value {\n        assert(tnBytes.length > 0, \"missing reqd tn\");\n        Value::new(\n            AssetClass::new(self.mph, tnBytes), \n            count\n        )\n    }\n\n    func mkAc(self, \n        tn: String = \"\",\n        tnBytes : ByteArray = tn.encode_utf8()\n    ) -> AssetClass {\n        AssetClass::new(self.mph, tnBytes)\n    }\n\n    // use this or updatingDgData() instead of getDDOutput()\n    func creatingDgData(\n        self,\n        recId : String=\"\", \n        recIdBytes : ByteArray = recId.encode_utf8()\n    ) -> DgDataDetails {\n        output : TxOutput = self.delegatedTxOutput(recIdBytes);\n        DgDataDetails::creating(recIdBytes, output, self.mph)\n    }\n\n    func updatingDgData(\n        self,\n        recId : String=\"\", \n        recIdBytes : ByteArray = recId.encode_utf8()\n    ) -> DgDataDetails {\n        output : TxOutput = self.delegatedTxOutput(recIdBytes);\n        input : TxInput = self.delegatedDataTxInput(recIdBytes: recIdBytes);\n        DgDataDetails::updating(recIdBytes, input, output, self.mph)\n    }\n    \n    func getCharterRedeemer(self) -> CapoActivity {\n        e : String = \"requires charter as input\";\n        self.charter.switch {\n            Unk => error(e),\n            RefInput => error(e),\n            Input{_, utxo} => {\n                activity : CapoActivity = CapoActivity::from_data(\n                    mustFindInputRedeemer(utxo)\n                );\n                // error-factory:\n                wrongActivity = () -> CapoActivity { \n                    if (true) { error(\"non-CharterData activity\") } else { \n                        // unreachable\n                        CapoActivity::usingAuthority\n                    } \n                };\n                // returns any activity valid for the CharterData utxo:\n                activity.switch {\n                    retiringRefScript => wrongActivity(),\n                    // updatingSettings => wrongActivity(),\n                    // retiringSettings => wrongActivity(),                    \n                    spendingDelegatedDatum => wrongActivity(),\n                    usingAuthority => activity,\n                    updatingCharter => activity, //todo: make this obsolete\n                    addingSpendInvariant => activity,\n                    capoLifecycleActivity => activity\n\n                    // _ => // leaving other potential variants out to generate compile errors if they're added\n                }\n            }\n        }\n    }\n\n    func findManifestEntry(self, key: String) -> Option[CapoManifestEntry] {\n        print(\"    -- looking for capo's manifest entry: \"+key);\n        charterData : CapoDatum::CharterData = self.getCharterData();\n        charterData.manifest.get_safe(key)\n    }\n\n    func mustFindManifestEntry(self, key: String) -> CapoManifestEntry {\n        self.findManifestEntry(key).switch {\n            Some{entry} => entry,\n            None => error(\"missing required manifest entry: \" + key)\n        }\n    }\n\n    func findManifestTokenName(self, key: String, required: Bool = true) -> Option[ByteArray] {\n        oe = self.findManifestEntry(key);\n        oe.switch {\n            None => {\n                assert(!required, \"missing required manifest entry: \" + key);\n                Option[ByteArray]::None\n            }, \n            Some{e} => Option[ByteArray]::Some{e.tokenName}\n        }\n    }\n\n    func getSettingsId(self, required : Bool = true) -> Option[ByteArray] {\n        self.findManifestTokenName(\"currentSettings\", required)\n    }\n\n    func getManifestedData(self, key: String,\n        which : UtxoSource = UtxoSource::RefInput\n    ) -> Data {\n        print(\"  -- finding manifest symbol \"+ key);\n        manifestEntry : CapoManifestEntry = self.mustFindManifestEntry(key);\n        tokenName : ByteArray = manifestEntry.tokenName;\n        manifestAc = AssetClass::new(self.mph, tokenName);\n        // manifestValue : Value = mkTv(mph: self.mph, tnBytes: tokenName);\n        tnStr = tokenName.decode_utf8();\n        print(\"     ... with input dgData token name: \"+ tnStr);\n        // print(\"     with value: \"+manifestValue.show()+\"\\n\");\n\n        inputs: []TxInput = which.switch {\n            RefInput => tx.ref_inputs,\n            Input => tx.inputs\n        };\n        utxo : TxInput = inputs.find_safe((txin : TxInput) -> Bool {\n            txin.value.get_safe(manifestAc) > 0\n        }).switch{\n            Some{txin} => {\n                print (\"  ✅ ➡️  📀💁 found ^ input dgData utxo\" );\n                txin\n            },\n            None => {                \n                error(\n                    \"_❌ ➡️ 📀💁💣💥💣💥💣💥  missing required \"+\n                    which.switch{RefInput => \"ref_input\", Input => \"input\"}+\n                    \" for manifest's '\"+key+\"' data=\"+tnStr+\n                    \"\\n   -- this probably indicates capo.tcxWithSettingsRef(tcx, ...) was not called\"\n                    // lifecycle management should always ensure a good linkage between\n                    // the capo's manifest entry and the matching utxo having that uut.\n                )\n            }\n        };\n\n        utxo.datum.inline.switch {\n            ConstrData{_, fields} => {\n                // print(\"utxo: \"+ utxo.output_id.show());\n                // print(\"manifested data fields = \"+fields.length.show());\n                fields.head.switch {\n                    MapData => {\n                        // print(\"mapData found\");\n                        fields.head\n                    },\n                    _ => error(\"expected MapData for manifested data: \"+ key)\n                }\n            },\n            _ => error(\"expected ConstrData{‹any›, mStruct} for manifested data: \"+ key)\n        }\n    }\n\n    func getNextManifestDatum[DATUM_TYPE](self, key: String) -> DATUM_TYPE {\n        DATUM_TYPE::from_data(\n            self.getNextManifestedDatumRaw(key)\n        )\n    }\n\n    func getNextManifestedDatumRaw(self, key: String) -> Data {\n        charterData : CapoDatum::CharterData = self.getCharterData();\n        manifestEntry : CapoManifestEntry = charterData.manifest.get_safe(key).switch{\n            Some{entry} => entry,\n            None => error(\"missing required manifest entry: \" + key)\n        };\n        manifestAc = AssetClass::new(self.mph, manifestEntry.tokenName);\n        // manifestValue : Value = mkTv(mph: self.mph, tnBytes: manifestEntry.tokenName);\n        utxo : TxOutput = tx.outputs.find_safe((txo : TxOutput) -> Bool {\n            txo.value.get_safe(manifestAc) > 0\n        }).switch{\n            Some{txo} => txo,\n            None => error(\"missing required '\"+key+\"' manifest entry in outputs\")\n        };\n\n        utxo.datum.inline.switch {\n            ConstrData{_, fields} => fields.head,\n            _ => error(\"expected ConstrData{mStruct} for manifested data: \"+ key)\n        }\n    }\n\n    // func getRefSettingsUtxo(self) -> TxInput {\n    //     charterData : CapoDatum::CharterData = self.getCharterData();\n    //     settingsValue : Value = mkTv(mph: self.mph, tnBytes: charterData.settingsUut);\n    //     hasSettings = (txin : TxInput) -> Bool { txin.value.contains(settingsValue) };\n\n    //     print(\"getting ref_input for settings\\n\");\n    //     settingsUtxo : TxInput =  tx.ref_inputs.find_safe(hasSettings).switch{\n    //         Some{s} => s,\n    //         //!!! todo adjust this message: Missing required charter in ref_inputs\n    //         None => error(\"Missing settings in required ref_inputs (use capo.addSettingsRef(tcx, 'refInput') in txn builder)\")\n    //     };\n    \n    //     settingsUtxo\n    // }\n\n    func requiresGovAuthority(self) -> CapoCtx {\n        REQT(\"it must have the Capo's govAuthority approval\");\n        \n        assert(\n            self.getCharterData().govAuthorityLink.hasValidOutput( \n                self.mph  \n            ), /*always true*/\n            \"no way m\"\n        ); \n\n        self\n    }\n\n    // func getSettings[SettingsTYPE](self) -> SettingsTYPE {\n    //     settings : TxInput = self.getRefSettingsUtxo();\n\n    //     SettingsTYPE::from_data(settings.datum.inline)\n    // }\n\n    func requiresNamedDelegateInput(self, dgtName: String) -> DelegateInput {\n        self.getCharterData().otherNamedDelegates.get_safe(dgtName).switch{\n            None => error(\"missing required delegate with name: \" + dgtName),\n\n            Some{dgtLink} => {\n                self.requiresDelegateInput(dgtLink, DelegateRole::OtherNamedDgt{dgtName})\n            }\n        }\n    }\n\n    func requiresDgDataPolicyInput(self, typeName: String, required: Bool = true) -> DelegateInput {\n        REQT(\"  -- requiresDgDataPolicyInput(): locates the manifest's data-policy for this record-type\");\n\n        self.getCharterData().manifest.get_safe(typeName).switch{\n            None => error(\"missing data-policy manifest for record-type '\" + typeName + \"'\"),\n            Some{entry} => {\n                ( dgtLink : RelativeDelegateLink, idPrefix: String ) = entry.entryType.switch {\n                    DgDataPolicy{policyLink, idPrefix, _refCount} => ( policyLink, idPrefix ),\n                    _ => error(\"manifest entry is not a data policy: \"+typeName)\n                };\n                REQT(\"requires the delegated-data policy for type=\"+typeName);\n                self.requiresDelegateInput(\n                    dgtLink, \n                    DelegateRole::DgDataPolicy{typeName}, \n                    required,\n                    Option[String]::Some{idPrefix}\n                )\n            }\n        }\n    }\n\n    func nowActingAsMintDgt(self, required: Bool = true) -> Bool {\n        input : TxInput = get_current_input();\n        acMintDgt : AssetClass = self.getCharterData().mintDelegateLink.acAuthorityToken(self.mph);\n        isUsingMintDgt = (\n            input.value.get_safe(acMintDgt) > 0\n        ).trace(\"    -- acting on mintDgt-* token right now? \");\n        // isMintDgt : Bool = (\n        //     self.requiresMintDelegateInput(required: required).input.switch {\n        //         Some{i} => i == input,\n        //         None => false\n        //     }\n        // ).trace(\"    -- acting on mintDgt-* right now? \");\n        assert(\n            isUsingMintDgt || !required\n            , \"not acting as mint delegate!\"\n        );\n        isUsingMintDgt\n    }\n\n    func nowActingAsSpendDgt(self, required: Bool = true) -> Bool {\n        input : TxInput = get_current_input();\n        acSpendDgt : AssetClass = self.getCharterData().spendDelegateLink.acAuthorityToken(self.mph);\n        isUsingSpendDgt = (\n            input.value.get_safe(acSpendDgt) > 0\n        ).trace(\"    -- acting on spendDgt-* token right now? \");\n        // isSpendDgt : Bool = (\n        //     self.requiresSpendDelegateInput(required: required).input.switch {\n        //         Some{i} => i == input,\n        //         None => false\n        //     }\n        // ).trace(\"    -- acting on spendDgt-* right now? \");\n        assert(\n             isUsingSpendDgt || !required\n            , \"not acting as spend delegate!\"\n        );\n        isUsingSpendDgt\n    }\n\n    func requiresMintDelegateInput(self, required: Bool = true) -> DelegateInput {\n        dgtLink : RelativeDelegateLink = self.getCharterData().mintDelegateLink;\n        self.requiresDelegateInput(\n            dgtLink: dgtLink, \n            role: DelegateRole::MintDgt,\n            required: required\n        )\n    }\n\n    func requiresSpendDelegateInput(self, required: Bool = true) -> DelegateInput {\n        dgtLink : RelativeDelegateLink = self.getCharterData().spendDelegateLink;\n\n        self.requiresDelegateInput(\n            dgtLink: dgtLink, \n            role: DelegateRole::SpendDgt,\n            required: required\n        )\n    }\n\n    // internal / low-level function\n    func getCharterData(self) -> CapoDatum::CharterData {\n        self.charter.switch {\n            RefInput{datum, _} => datum,\n            Input{datum, _} => datum,\n            _ => error(\"CapoCtx.getCharterData(): unknown charter strategy; use result of withCharterInput(), withCharterRef(), or needsCharter() to resolve charter datum first\")\n        }\n    }\n\n    func getNextCharterData(self) -> CapoDatum::CharterData {\n        charterAc : AssetClass = AssetClass::new(self.mph, \"charter\".encode_utf8());\n        capoAddr : Address = self.address();\n        self.charter.switch {\n            Input => {\n                charterData : CapoDatum::CharterData = CapoDatum::from_data(\n                    tx.outputs.find( (txo: TxOutput) -> Bool {\n                        txo.address == capoAddr &&\n                        txo.value.get_safe(charterAc) > 0\n                    }).datum.inline\n                );\n                charterData\n            },\n            _ => error(\"CapoCtx.getNextCharterData(): invalid except with charter strategy Input\")\n        }\n    }\n\n    func resolveCharterUtxo(self) -> TxInput {\n        self.charter.switch {\n            RefInput{_, utxo} => utxo,\n            Input{_, utxo} => utxo,\n            // Minting => error(\"can't get utxo during minting; be satisfied with the .address()!\"),\n            _ => error(\"CapoCtx.resolveCharterUtxo(): unknown charter strategy; use result of withCharterInput(), withCharterRef(), or needsCharter() to resolve charter utxo first\")\n        }\n    }\n\n    // internal / low-level function\n    func requiresDelegateInput(self, \n        dgtLink: RelativeDelegateLink, \n        role: DelegateRole,\n        required: Bool = true,\n        idPrefix: Option[String] = Option[String]::None\n    ) -> DelegateInput {\n        DelegateInput{\n            dgtLink,\n            role,\n            idPrefix,\n            dgtLink.hasDelegateInput(\n                inputs: tx.inputs, \n                mph: self.mph,\n                required: required\n            ),\n            self.mph\n        }\n    }\n\n    func address(self) -> Address {\n        addr : Address = self.resolveCharterUtxo().address;\n                // print(\"Capo addr: \" + addr.show());\n        addr    \n    }\n\n    func delegatedDataRef(self,\n        recId: String=\"\",\n        recIdBytes: ByteArray=recId.encode_utf8()\n    ) -> TxInput {\n        hasDD : (TxInput) -> Bool = self.mkDelegatedDataPredicate(\n            id: recIdBytes\n        );\n\n        recIdStr = recIdBytes.decode_utf8();\n        print(\"  -- expecting refDD \"+ recIdStr);\n        tx.ref_inputs.find_safe(hasDD).switch {\n            None => {\n                error(\"❌❌ 📎 ^ refDD: not found\\n\")\n            },\n            Some{txin} => {\n                print(\"✅ 📎 ^ refDD: ok\\n\");\n\n                txin\n            }\n        }\n    }\n\n    func delegatedDataTxInput(self, \n        recId: String=\"\",\n        recIdBytes: ByteArray=recId.encode_utf8()\n    ) -> TxInput {\n        hasDD : (TxInput) -> Bool = self.mkDelegatedDataPredicate(\n            id: recIdBytes\n        );\n\n        recIdStr = recIdBytes.decode_utf8();\n        print(\"  -- expecting inDD \" + recIdStr);\n\n        tx.inputs.find_safe(hasDD).switch {\n            None => {\n                error(\"❌❌ 📎 ^ inDD: not found\\n\")\n            },\n            Some{txin} => {\n                print(\"    ✅ 📎 ^ inDD: ok\\n\");\n\n                txin\n            }\n        }\n    }\n                \n    func mkDelegatedDataPredicate(self, typeName: String=\"\", id: ByteArray=#) -> (TxInput) -> Bool {\n        capoAddr : Address = self.address();\n        assert( \n            id.length > 0 \n            || typeName.serialize().length > 0, \n            \"data predicate must have id or typeName\"\n        );\n        (txin : TxInput) -> Bool {\n            if(txin.address == capoAddr) {\n                data : Data = txin.datum.inline;\n\n                CapoDatum::from_data(data).switch {\n                    DelegatedData => {\n                        x = AnyData::from_data(fromCip68Wrapper(data));\n                        true \n                        && (typeName == \"\" || x.type == typeName) \n                        && (id == # || x.id == id)\n                    },\n                    _ => false\n                }\n            } else { false }\n        }\n    }\n\n    func mkDelegatedDataOutputPredicate(self, typeName: String, id: ByteArray=#) -> (TxOutput) -> Bool {\n        capoAddr : Address = self.address();\n        // print(\"capoAddr: \"+ capoAddr.show());\n        // print(\"seeking type \"+ typeName);\n        (txo : TxOutput) -> Bool {\n            // print(\"txo.address: \"+ txo.address.show());\n            if(txo.address == capoAddr) {\n                data : Data = txo.datum.inline;\n                CapoDatum::from_data(data).switch {\n                    DelegatedData => {\n                        x : AnyData = AnyData::from_data(fromCip68Wrapper(data));\n                        // print( \"found type \" + x.type );\n                        // print( \"found id \" + x.id.decode_utf8() );\n                        // isMatch : Bool = \n                        x.type == typeName && (id == # || x.id == id)\n                        // print( \"isMatch: \" + isMatch.show() );\n                        // isMatch\n                    },\n                    _ => {\n                        // print (\"not DelegatedData\");\n                        false\n                    }\n                }\n            } else { \n                // print (\"not in capoAddr\");\n                false\n             }\n        }\n    }\n\n\n    // func toDelegatedData(self, typeName: String) -> (TxInput) -> Option[Data] {\n    //     capoAddr : Address = self.resolveCharterUtxo().address;\n    //     none : Option[Data]::None = Option[Data]::None;\n    //     (txin : TxInput) -> Option[Data] {\n    //         if(txin.address == capoAddr) {\n    //             data : Data = txin.datum.inline;\n    //             CapoDatum::from_data(data).switch {\n    //                 DelegatedData => {\n    //                     x : AnyData = AnyData::from_data(data);\n    //                     if (x.type == typeName) {\n    //                         Option[Data]::Some{data}\n    //                     } else {\n    //                         none\n    //                     }\n    //                 },\n    //                 _ => none\n    //             }\n    //         } else { none }\n    //     }\n    // }\n\n    // func foldDelegatedData_lazy[RT]( self, \n    //     typeName: String, \n    //     reducer: (\n    //         Data, () -> RT\n    //     ) -> RT, \n    //     final: RT\n    // ) -> RT {\n    //     // filter : (TxInput) -> Bool = self.delegatedDataFilter(typeName);\n    //     hasDD : (TxInput) -> Option[Data] = self.toDelegatedData(typeName);\n    //     // capoAddr : Address = self.resolveCharterUtxo().address;\n    //     tx.inputs.fold_lazy[RT](\n    //         (txin : TxInput, myNext: () -> RT) -> RT {\n    //             hasDD(txin).switch {\n    //                 Some{data} => reducer(data, myNext),\n    //                 None => myNext()\n    //             }\n    //         }, final\n    //     )\n    // }\n\n    // func filterDelegatedData(self, type: String, filter: (Data) -> Bool) -> []TxInput {\n    //     //NOT: hasDD : (TxInput) -> Bool = self.delegatedDataFilter(type);\n    //     // use toDelegatedData:\n        \n    //     hasDD : (TxInput) -> Option[Data] = self.mkDelegatedDataPredicate(type);\n    //     tx.inputs.filter( (txin : TxInput) -> Bool {\n    //         hasDD(txin).switch { \n    //             Some{data} => filter(data),\n    //             None => false\n    //         }\n    //     })\n    // }\n\n    // func findDelegatedData[T](self, \n    //     type: String, \n    //     transform: (Data) -> Option[T],\n    //     optional: Bool = false\n    // ) -> []T {\n    //     //not hasDD : (TxInput) -> Bool = self.delegatedDataFilter(type);\n    //     // use toDelegatedData:\n    //     hasDD : (TxInput) -> Option[Data] = self.toDelegatedData(type);\n    //     none : Option[T]::None = Option[T]::None;\n    //     result : []T = tx.inputs.map_option[T]( (txin : TxInput) -> Option[T] {\n    //         hasDD(txin).switch { \n    //             Some{data} => {\n    //                 transform(data)\n    //             },\n    //             None => none\n    //         }\n    //     });\n    //     if (!optional && (result.length == 0)) {\n    //         error(type + \": no match\")\n    //     };\n\n    //     result\n    // }\n\n    // func findDelegatedDataUtxos(self, \n    //     type: String, \n    //     filter: (Data, TxInput) -> Bool,\n    //     id: ByteArray=#,\n    //     optional: Bool = false\n    // ) -> []TxInput {\n    //     //not hasDD : (TxInput) -> Bool = self.delegatedDataFilter(type);\n    //     // use toDelegatedData:\n    //     hasDD : (TxInput) -> Bool = self.mkDelegatedDataPredicate(type, id);\n    //     none : Option[TxInput]::None = Option[TxInput]::None;\n    //     result : []TxInput = tx.inputs.map_option[TxInput]( (txin : TxInput) -> Option[TxInput]{\n    //         if (hasDD(txin)\n    //             Some{data} => {\n    //                 if (filter(data, txin)) {\n    //                     Option[TxInput]::Some{txin}\n    //                 } else {\n    //                     none\n    //                 }\n    //             },\n    //             None => none\n    //         }\n    //     });\n    //     if (!optional && (result.length == 0)) {\n    //         error(type + \": no match\")\n    //     };\n\n    //     result\n    // }\n\n    func mustOutputDelegatedData(self, newDataId : ByteArray, dataTypePurpose : String) -> Bool{\n        REQT(\"   -- validates that the new record is stored in the Capo address\");\n\n        dgData : Data = self.delegatedTxOutput(newDataId).datum.inline;\n        dgDatum : CapoDatum = CapoDatum::from_data(dgData);\n\n        REQT(\"   -- validates that the new record matches the type-name indicated in the dgDataPolicy manifest\");\n        dgDatum.switch {\n            DelegatedData => {\n                data : AnyData = AnyData::from_data(fromCip68Wrapper(dgData));\n                recIdStr = newDataId.decode_utf8();\n                if (data.id != newDataId) {\n                    print(\"  -- expected id: \"+recIdStr);\n                    actualIdStr = data.id.decode_utf8();\n                    error(\"❌❌ 📎 outDD: wrong id: \"+actualIdStr)\n                } else {\n                    if (data.type != dataTypePurpose) {\n                        print(\"  -- expected type: \"+ dataTypePurpose);\n                        error(\"❌❌ 📎 outDD: bad type: \"+data.type)\n                    } else {\n                        print(\"✅ 📎 outDD: ok: ^ outDD to Capo: \"+recIdStr);\n                        true\n                    }\n                }\n            },\n            _ => {\n                error(\"output not delegated data\")\n            }\n        }\n    }        \n\n    // func delegatedOutputData(self, \n    //     recId: ByteArray\n    // ) -> Data {\n    //     self.delegatedTxOutput(recId).datum.inline\n    // }\n\n    func delegatedTxOutput(self, \n        recId: ByteArray\n    ) -> TxOutput {\n        recIdStr = recId.decode_utf8();\n        ac = AssetClass::new(self.mph, recId);\n        capoAddr = self.address();\n        tx.outputs.find_safe(\n            (txout : TxOutput) -> Bool {\n                // print(\"?? txOut\" + txout.value.show());\n                // print(\"@addr\" + txout.address.show());\n                true\n                && (txout.value.get_safe(ac) == 1)\n                    .trace(\"  -- output has value? \")\n                && (txout.address == capoAddr)\n                    .trace(\"     -- found output... is it at the right capoAddr? \")\n            }\n        ).switch{\n            None => {\n                error(\"❌❌ 📎 ^ outDD: not found: \" + recIdStr)\n            },\n            Some{txout} => {\n                print(\"     ✅ 📎 ^ outDD: found \"+ recIdStr);\n                txout\n            }\n        }\n    }\n\n    // func XXXmustFindDelegatedDatum[T](self, mph: MintingPolicyHash, tnBytes: ByteArray, inAddr: Address) -> outputAndDatum[T] {\n    //     notFound = Option[outputAndDatum[T]]::None;\n    //     idTokenValue = mkTv(mph: mph, tnBytes: tnBytes);\n    //     print( \" ⬅️ 🔎 finding DelegatedData output: \"+ //xxx no decode in print! tnbBytes.decode_utf8() + \"\\n\");\n\n    //     foundDelegatedData: []outputAndDatum[T] = \n    //         tx.outputs.map_option[\n    //             outputAndDatum[T]\n    //         ](\n    //             (output: TxOutput) -> Option[outputAndDatum[T]] {\n    //                 if ( output.address != inAddr ) {\n    //                     notFound\n    //                 } else if (!output.value.contains(idTokenValue)) {\n    //                     notFound\n    //                 } else {\n    //                     rawDatum : Data = output.datum.inline;\n    //                     CapoDatum::from_data(\n    //                         rawDatum\n    //                     ).switch {\n    //                         dd: DelegatedData => {\n    //                             Option[\n    //                                 outputAndDatum[T]\n    //                             ]::Some{\n    //                                 outputAndDatum[T] {\n    //                                     output, dd, rawDatum\n    //                                 }\n    //                             }\n    //                         },\n    //                         _ => {\n    //                             notFound\n    //                         }\n    //                     }\n    //                 }\n    //             }\n    //         );\n    //     assert(foundDelegatedData.length < 2, \"too many delegated data outputs\") ;\n    //     assert(foundDelegatedData.length == 1, \"no delegated data output\");\n    //     assert(idTokenValue.contains(foundDelegatedData.value.get_assets()), \n    //         \"excess value in delegated-data output: \"+(settingsOutput.value - settingsVal).show()\n    //     );\n\n    //     print(\"\\n ⬅️ ✅ found DelegatedData\\n\");\n    //     foundDelegatedData.head\n    // }\n\n\n    \n    // doesn't care where the charter info comes from - refinput or input, both OK\n    func needsCharter(self) -> CapoCtx {\n        REQT(\"requires the charter to be available in the transaction (input or ref)\");\n\n        charter : cctx_CharterInputType = self.charter;\n        charter.switch {\n            RefInput => self,\n            Input => self,\n            Unk => {\n                CapoCtx{mph, _} = self;\n                charterAc : AssetClass = AssetClass::new(mph, \"charter\".encode_utf8());\n                hasCharter = (txin : TxInput) -> Bool { txin.value.get_safe(charterAc) > 0 };\n\n                tx.ref_inputs.find_safe(hasCharter).switch{\n                    None => {\n                        print(\"CapoCtx needsCharter(): no charter ref; must be in inputs...\\n\");\n\n                        self.withCharterInput()\n                    },\n                    Some{charterUtxo} => {\n                        print(\"CapoCtx needsCharter(): found charter ref\\n\");\n\n                        datum : CapoDatum::CharterData = CapoDatum::CharterData::from_data( \n                            charterUtxo.datum.inline\n                        );\n                        CapoCtx{mph, cctx_CharterInputType::RefInput{datum, charterUtxo}}\n                    }\n                }\n                // _ => self\n            }\n        }\n    }\n\n    func withCharterInput(self) -> CapoCtx {\n        REQT(\"requires the charter to be spent in the inputs\");\n\n        charter : cctx_CharterInputType = self.charter;\n        charter.switch {\n            Input => self,\n            RefInput => error(\"CapoCtx.withCharterInput(): charter is from ref!\"),\n            Unk => {\n                CapoCtx{mph, _} = self;\n\n                charterAc : AssetClass = AssetClass::new(mph, \"charter\".encode_utf8());\n                hasCharter = (txin : TxInput) -> Bool { txin.value.get_safe(charterAc) > 0 };\n        \n                print(\"    -- CapoCtx finding charter in inputs\\n\");\n                charterUtxo: TxInput = tx.inputs.find_safe(hasCharter).switch{\n                    Some{ch} => ch,\n                    None => error(\"Missing required charter input\")\n                };\n                datum : CapoDatum::CharterData = CapoDatum::CharterData::from_data( \n                    charterUtxo.datum.inline\n                );\n                // datum : CapoDatum::CharterData = getTxCharterData(self.mph);\n                CapoCtx{mph, cctx_CharterInputType::Input{datum, charterUtxo}}\n                // self.copy(charter: cctx_CharterInputType::Input{charterUtxo, datum})\n            }\n        }\n    }\n\n    // func nowMinting(self, address: Address, output: TxOutput) -> Bool {\n    //     self.charter.switch {\n    //         Input => error(\"CapoCtx.nowMinting(): charter is from inputs!\"),\n    //         RefInput => error(\"CapoCtx.nowMinting(): charter is from ref!\"),\n    //         Unk => {\n    //             CapoCtx{mph, _} = self;\n    //             datum: CapoDatum::CharterData = CapoDatum::CharterData::from_data( \n    //                 output.datum.inline\n    //             );\n    //             CapoCtx{mph, cctx_CharterInputType::Minting{datum, address}}\n    //     }\n    // }\n\n    func withCharterRef(self) -> CapoCtx {\n        REQT(\"requires the charter to be referenced in the txn, but unspent\");\n\n        charter : cctx_CharterInputType = self.charter;\n        charter.switch {\n            RefInput => self,\n            Input => error(\"CapoCtx.withCharterRef(): charter is from inputs!\"),\n            Unk => {\n                CapoCtx{mph, _} = self;\n                utxo : TxInput = getRefCharterUtxo(mph);\n                datum : CapoDatum::CharterData = CapoDatum::CharterData::from_data( \n                    utxo.datum.inline \n                );\n            \n                CapoCtx{mph, cctx_CharterInputType::RefInput{datum, utxo}}\n\n                // self.copy(charter: cctx_CharterInputType::RefInput{datum})\n            }\n        }\n    }\n\n    func allDelegatesAreValidatingSettings(self) -> Bool {\n        charterData = self.getCharterData();\n        mph = self.mph;\n        // REQT( \"gov authority must be present to update settings\");\n        // hasGovAuthority : Bool = mustHaveGovAuthority(\n        //     mph: mph,\n        //     charterData: charterData // already resolved\n        // );\n\n        CapoDatum::CharterData{\n            _spendDelegate,\n            spendInvariants,\n            otherNamedDelegates,\n            _mintDelegate,\n            mintInvariants,\n            govDelegate,\n            manifest,\n            _pendingDelegates\n        } = charterData;\n\n        // REQT(\"the current Settings must be spent and updated\");\n        // settingsDgtLink : RelativeDelegateLink = manifest.get_safe(\"settings\").switch {\n        //     None => error(\"'settings' delegate must be present to do updatingSettings activity\"),\n        //     Some{dgt} => dgt.dgDataPolicy.unwrap()\n        // };\n        \n        // //!!! note, this is a hard-coded version of requiring the settings policy script:\n        // settingsDgtInput = settingsDgtLink.hasDelegateInput(\n        //     inputs: tx.inputs,\n        //     mph: mph\n        // ).unwrap();\n        // settingsDelegateIsValid : Bool = AbstractDelegateActivitiesEnum::from_data( \n        //     mustFindInputRedeemer(settingsDgtInput)\n        // ).switch {\n        //     SpendingActivities => true,\n        //     _ => error(\n        //         \"settings delegate must be updating the settings with its SpendingActivities variant\"\n        //     )\n        // };\n        // _nextSettings : Data = self.getNextManifestedDatumRaw(\"settings\");\n        // isUpdatingSettings : Bool = true;\n        \n        inputs: []TxInput = tx.inputs;\n        //!!! actually requiring delegates' SettingsValidation starts here.\n        REQT(\"   -- only the spend delegate calls this function\");\n        spendDelegateIsValidating : Bool = self.nowActingAsSpendDgt();\n        REQT(\"  -- spend delegate requires the other delegates validate (except mint delegate == same as spend delegate)\");\n\n        // govAuthority is checking the settings\n        REQT( \"govDelegate MAY contribute to settings validation\");\n        govDelegateMaybeValidating : Bool = \n            govDelegate.validatesUpdatedSettings(\n                inputs: inputs,\n                mph: mph,\n                inputRequired: false\n            ).switch{\n                Some => true,\n                None => {\n                    print(\"  -- govAuthority isn't a script-based validator; doesn't validate new settings\\n\");\n                    true\n                }\n            };\n        checkOneInvariant : (RelativeDelegateLink) -> Bool = \n        (oneDgt: RelativeDelegateLink) -> Bool {\n            REQT( \"invariant must validate settings\");\n            oneDgt.validatesUpdatedSettings(\n                inputs: inputs,\n                mph: mph,\n                inputRequired: true\n            ).unwrap()\n        };\n        // spendInvariants are checking the settings\n        REQT( \"spend invariants must validate settings\");\n        spendInvariantsAreValidating : Bool = spendInvariants.all( \n            checkOneInvariant\n        );\n        // mintInvariants are checking the settings\n        REQT( \"mint invariants must validate settings\");\n        mintInvariantsAreValidating : Bool = mintInvariants.all( \n            checkOneInvariant\n        );\n        REQT(\"dgDataControllers must validate settings\");\n        // dgDataControllers are checking the settings\n\n        dgDataPoliciesAreValidating :Bool = manifest.all( \n            (key: String, entry: CapoManifestEntry) -> Bool {\n                entry.entryType.switch{\n                    DgDataPolicy{policyLink, _idPrefix, _refCount} => {\n                        policyLink.validatesUpdatedSettings(\n                            inputs: inputs,\n                            mph: mph,\n                            inputRequired: true\n                        ).unwrap()\n                    },\n                    _ => {\n                        print(\"  -- ignoring manifest entry (not a data policy): \" + key);\n                        true\n                    }\n                }\n            }\n        );\n\n        // namedDelegates are checking the settings\n        REQT( \"named delegates must validate settings\");        \n        namedDelegatesAreValidating : Bool = otherNamedDelegates.fold( \n            REQT( \"  - each other-named-delegate must validate settings\");\n            (ok: Bool, key: String, dgt: RelativeDelegateLink) -> Bool {\n                print(\"  - other-named-delegate: \" + key);\n                print(\"\\n\");\n                ok && dgt.validatesUpdatedSettings(\n                    inputs: inputs,\n                    mph: mph,\n                    inputRequired: true\n                ).unwrap()\n            }, true\n        );\n\n        // hasGovAuthority &&\n        // settingsDelegateIsValid &&\n        // isUpdatingSettings &&\n        dgDataPoliciesAreValidating &&\n        spendDelegateIsValidating &&\n        govDelegateMaybeValidating &&\n        spendInvariantsAreValidating &&\n        mintInvariantsAreValidating &&\n        namedDelegatesAreValidating \n    }\n\n    func dgtRolesForLifecycleActivity(self, activity: CapoLifecycleActivity) -> DelegateRole {\n        assert(true || /*never executed*/ self == self, \"prevent unused var\");\n\n        activity.switch {\n            forcingNewSpendDelegate => error(\"the forcingNewSpendDelegate escape-hatch activity is always handled directly by the Capo\"),\n            forcingNewMintDelegate => error(\"the forcingNewMintDelegate escape-hatch activity is always handled directly by the Capo\"),\n\n            updatingManifest => {\n                REQT(\"... for updating the Capo manifest...\");\n                DelegateRole::SpendDgt\n            },\n\n            queuePendingChange => {\n                REQT(\"... for queuing a pending dgt-change...\");\n                DelegateRole::MintDgt\n            },\n            removePendingChange => {\n                REQT(\"... for removing a pending dgt-change entry...\");\n                DelegateRole::SpendDgt\n            },\n            commitPendingChanges => {\n                REQT(\"... for committing pending dgt-changes...\");\n                 DelegateRole::BothMintAndSpendDgt\n            },\n\n            CreatingDelegate => {\n                REQT(\"... for creating a new delegate (deprecated path)...\");\n                TODO(\"deprecate use of CLA::CreatingDelegate\");\n                DelegateRole::MintDgt\n            }\n\n            // we want explicit handling of each case; don't use a default match here.\n            // _ => error(\"DO NOT CATCH DEFAULT CASE HERE\")\n        }\n    }\n\n    // syntax sugar.  Implied is that that any other function calls will trip errors,\n    func orFail(self) -> Bool {\n        assert(true || /* never executed */ self.serialize() == self.serialize(), \"crazy talk\");\n        true\n    }\n    \n}\n\nfunc mkCapoCtx(mph: MintingPolicyHash) -> CapoCtx {\n    CapoCtx{\n        mph, cctx_CharterInputType::Unk\n    }\n}\n\n", {
    project: "stellar-contracts",
    purpose: "module",
    name:  "src/CapoHelpers.hl", // source filename
    moduleName:  "CapoHelpers",
});

const TypeMapMetadata_hl = makeSource(
  "module TypeMapMetadata\n\n// a type definition for a schema\n\nstruct TypeInfo {\n    schemaVariety: String  // e.g. \"json-schema\"\n    schemaContent: String    \n}\n\nenum TypeRefImportDetails {\n    ImportType {  // imports external types and keeps their names\n        typeName: String // use \"*\" to import all types\n    }\n    ImportAs {  // imports a single external type with a local name\n        mapToRemoteNames: Map[String]String  // maps local names to remote names\n        // keys are LOCAL names.  Values are REMOTE names.\n    }\n}\n\nstruct TypeMapRef {\n    importDetails: TypeRefImportDetails  \"imp\"\n    utxoRef: Option[TxOutputId] \"utxo\"  // the referenced utxo is EXPECTED to have {typeMapFlag, TypeMapInfo}\n    variety: String \"trv\"// indicates RESOLUTION semantics for the referenced type-information.\n        // the variety MAY also indicate interpretation semantics for the referenced type-information.\n        // if variety  is \"CIP-123\", use the utxoRef here, and interpret the result as a {{}}-flagged CIP-123 TypeMapInfo\n        // other varieties MAY use the utxoRef, depending on their semantics\n        // other varieties MAY use the ref string to generically point to the external type\n    ref: String \"ref\"\n}\n\nstruct TypeMap {\n    localTypes: Map[String]TypeInfo\n    inheritFlag: String // = \"||\" ; may be the empty string if there are no inherited types\n    inherit: []TypeMapRef\n}\n", {
    project: "stellar-contracts",
    purpose: "module",
    name:  "src/TypeMapMetadata.hl", // source filename
    moduleName:  "TypeMapMetadata",
});

const Capo_hl = makeSource(
  "spending Capo\n\n// needed in helios 0.13: defaults\nconst mph : MintingPolicyHash = MintingPolicyHash::new(#1234)\nconst rev : Int = 1\n\n// import {\n//     tvCharter\n// } from CapoHelpers\n\nimport {\n    tx, \n    get_current_input,\n    get_current_validator_hash\n} from ScriptContext\n\nimport { \n    AbstractDelegateActivitiesEnum,\n    CapoLifecycleActivity,\n    DgTknDisposition as DgTkn,\n    requiresNoDelegateInput,    \n    RelativeDelegateLink\n} from CapoDelegateHelpers\n\nimport {\n    TODO,\n    REQT,\n    bREQT,\n    mustFindInputRedeemer,\n    outputAndDatum,\n    AnyData,\n    tvCharter,\n    mkTv,\n    didSign\n} from StellarHeliosHelpers\n\nimport {\n    getTxCharterData,\n    mkCapoCtx,\n    mustHaveGovAuthority,\n    CapoDatum,\n    CapoActivity\n} from CapoHelpers\n\nimport {\n    mkUutTnFactory,\n    validateUutMinting\n} from CapoMintHelpers\n\n// import {\n//     ProtocolSettings\n// } from ProtocolSettings\n\nfunc requiresAuthorization(ctd: CapoDatum::CharterData) -> Bool {\n    ctd.govAuthorityLink.hasValidOutput(mph)\n}\n\nfunc getCharterOutput(tx: Tx) -> TxOutput {\n    charterTokenValue : Value = Value::new(\n        AssetClass::new(mph, \"charter\".encode_utf8()), \n        1\n    );\n\n    tx.outputs.find_safe(\n        (txo : TxOutput) -> Bool {\n            txo.value >= charterTokenValue\n        }\n    ).switch {\n        None => error(\"this could only happen if the charter token is burned.\"),\n        Some{o} => o\n    }\n}\n\nfunc preventCharterChange(datum: CapoDatum::CharterData) -> Bool {\n    charterOutput : TxOutput = getCharterOutput(tx);\n\n    cvh : ValidatorHash = get_current_validator_hash();\n    myself : SpendingCredential = SpendingCredential::new_validator(cvh);\n    if (charterOutput.address.credential != myself) {\n        error(\"charter token must be returned to the contract \")\n        // actual : String = charterOutput.address.credential.switch{\n        //     PubKey{pkh} => \"pkh:🔑#\" + pkh.show(),\n        //     Validator{vh} => \"val:📜#:\" + vh.show()\n        // };\n        // error(\n        //     \"charter token must be returned to the contract \" + cvh.show() +\n        //     \"... but was sent to \" +actual\n        // )\n    } else { \n        print(\"ok\\n\")\n    };\n\n    newDatum : CapoDatum = CapoDatum::from_data( \n        charterOutput.datum.inline\n    );\n    if (datum.serialize() != newDatum.serialize()) {\n        error(\"invalid update to charter settings\") \n    } else {\n        true\n    }\n}\n\nfunc checkpoint(s: String) -> Bool {\n    print(\"checkpoint: \" + s);\n    print(\"\\n\");\n    true\n}\n\nfunc main(datum: Data, activity: CapoActivity) -> Bool {\n    // now: Time = tx.time_range.start;\n    print(\"🚥❓Capo\\n\");\n\n    input : TxInput = get_current_input();\n    // showMyTokens : (Value) -> String = mkTokenShow(mph);\n    print(\"  -- Capo: checks spend of \" + input.value.show())\n    \n    capoDatum : CapoDatum = CapoDatum::from_data(datum);\n    allDatumSpecificChecks: Bool = capoDatum.switch {\n        // checks that unsupported activities for a datum are rejected promptly \n        // +special things we want to always guard against for specific Datum types:\n        ctd : CharterData => {\n            invalid : String = \"invalid activity on CharterData\";\n            activity.switch {\n                updatingCharter => true,  // more activity-checks happen below.\n                capoLifecycleActivity => true, // more checks below.\n                // addingSpendInvariant => error(\"todo: support spendInvariants\"),\n                // addingMintInvariant => error(\"todo: support mintInvariants\"),\n                spendingDelegatedDatum => error(invalid),\n                _ => {\n                    print(\"this charter activity isn't allowed to change the charter\");\n                    preventCharterChange(ctd)  // throws if bad                \n                    // ... plus activity-specific checks below.\n                }\n            }\n        },\n        // SettingsData => activity.switch {\n        //     updatingSettings => true,  // more checks below.\n        //     retiringSettings => error(\"there is no use case for this activity, unless it's part of a complete teardown\"),\n        //     _ => error(\"invalid activity on SettingsData\")\n        // },\n        ScriptReference => activity.switch {\n            retiringRefScript => true,\n            _ => error(\"invalid activity on ScriptReference\")            \n        },\n        DelegatedData => {\n            REQT(\"j6bmfv: all and ONLY DelegatedData datums must be spent with the Capo's spendingDelegatedDatum activity\");\n            // vvv part one of j6bmfv\n            activity.switch {\n                spendingDelegatedDatum => true,  // more checks below.\n                _ => error(\"invalid activity on DelegatedData\")\n            }\n        }\n        // maybe bring this back in v2\n        //, TypeMapInfo => activity.switch {\n        //     updatingTypeMap => true,\n        //     _ => error(\"invalid activity on TypeMapInfo\")\n        // }\n\n        // ❗no default case, to ensure that all variants are always covered.\n        // _ => true\n    };\n\n    // the normal case for validation is to use CapoDatum-specific checks.  \n    // however, this section allows activity-specific checks to be included, so extensions aren't painted into a corner.\n    allActivitySpecificChecks : Bool = activity.switch {\n        // checks for higher-frequency cases first\n        spendingDelegatedDatum => {\n            charterData : CapoDatum::CharterData = getTxCharterData(\n                mph: mph\n            );\n            // NOT all delegated-data policies need gov authority!\n            // hasGovAuthority = charterData.govAuthorityLink.hasValidOutput(mph);\n\n            // this is part two of j6bmfv\n            REQT(\"j6bmfv: all and ONLY DelegatedData datums must be spent with the Capo's spendingDelegatedDatum activity\");\n            print( \"  ...with activity spendingDelegatedDatum\\n\");\n            // check that the datum is a DelegatedData variant\n            datumId : ByteArray = capoDatum.switch{\n                DelegatedData => {\n                    datum.switch {\n                        ConstrData{_index, fields} => {\n                            AnyData::from_data(fields.head).id\n                        },\n                        _ => error(\"unreachable\")\n                    }\n                },\n                _ => {\n                    error(\n                        \"activity spendingDelegatedDatum used on mismatched datum type\"\n                    )\n                }\n            };\n            REQT(\"guards against updating a record if its id doesn't match its token-name\");\n            datumAc : AssetClass = AssetClass::new(mph, datumId);\n            hasMatchingValue : Bool = input.value.get_safe(datumAc) > 0;                        \n\n            TODO(\"deal with DeletingDelegatedData activity (ensure spendDgt AND mintDgt do their parts)\");\n            // Note: CreatingDelegatedData activity doesn't involve the Capo at all; instead,\n            // the minter creates a UUT for the data, on authority of the mintDgt;\n            // ... and the mintDgt requires the presence of the corresponding dgDataPolicy (with its MintingActivity);\n            // ... then the dgDataPolicy checks the validity of the new data, and requires that\n            // ... the new data is created as a DelegatedData record in the Capo address.\n\n            cctx = mkCapoCtx(mph).needsCharter();\n            // ?? is this checking the same things as the rest of the code below?\n            checkThingOne = cctx.requiresSpendDelegateInput()\n                // .withUniqueDDSpendingActivity(datumId)\n                .requiresValidOutput();\n            TODO(\"VERIFY the above versus the below!\");\n\n            // the below stuff was already tested\n\n            spendDelegate: RelativeDelegateLink = charterData.spendDelegateLink;\n            \n            // consider allowing this as a refInput, with other stuff to enable more parallelism for populations\n            spendDelegateInput: TxInput = spendDelegate.hasDelegateInput(\n                //!!!!!! todo: audit for usages of hasDelegateInput - do we need to pass inputs as an arg?\n                inputs: tx.inputs,\n                mph: mph\n            ).unwrap();\n\n            delegateReturned: Bool = spendDelegate.hasValidOutput(mph).trace(\" -- delegate returned ok? \");\n\n            spendDgtInputRedeemer: Data = mustFindInputRedeemer(spendDelegateInput);\n            print(\"  -- vvvvv REDUNDANT checks for delegate activity (right?)\\n\");\n            getSpendingRecId : (Data) -> ByteArray = (dgSpendActivity : Data) -> ByteArray {\n                dgSpendActivity.switch {\n                    ConstrData{index, fields} => {\n                        assert(true || index==index, \"unreachable\"); // prevent unused variable warning\n                        fields.head.switch {\n                            ByteArrayData{recId} => {\n                                print(\"  -- found recId: \" + recId.show());\n                                recId\n                            },\n                            _ => error(\"spending activity must have a record-id as first field\")\n                        }\n                    },\n                    _ => error(\"unreachable\")\n                }\n            };\n            uniqMatchingSpendDgtActivity : Bool = AbstractDelegateActivitiesEnum::from_data(\n                spendDgtInputRedeemer\n            ).switch {\n                SpendingActivities{sa} => {\n                    assert(false,\n                        \"expected the Spend delegate to use *DelegatedData* activities\\n\"+\n                        \"  ... to describe the operations that are being performed by next-level \"+\n                        \"  ... DgData Policy delegates\"\n                    );\n                    // unwrap the abstract Data from sa, expecting an Enum \n                    // ... with a first data-field having the token-name \n                    // ... that matches with the delegated-data record `id`\n                    recId : ByteArray = getSpendingRecId(sa);\n                    assert(recId == datumId, \"spendDgt SpendingActivity must act on the correct record-id\");\n                    true\n                },\n                UpdatingDelegatedData{/*dataType*/ _ , recId} => {\n                    // todo: expect that this record-id matches the token in the current UTxO.\n                    assert(recId == datumId, \"spendDgt UpdDgData must act on the correct record-id\");\n                    print(\"  -- ok: activity matches data being updated\");\n                    true\n                },\n                MultipleDelegateActivities{activities} => {\n                    found: []Data = activities.filter(\n                        (act: Data) -> Bool {\n                            AbstractDelegateActivitiesEnum::from_data(act).switch {\n                                SpendingActivities{sa} => {                                    \n                                    // unwrap / check record-id\n                                    assert(false,\n                                        \"expected the Spend delegate to use *DelegatedData* activities\\n\"+\n                                        \"  ... to describe the operations that are being performed by next-level \"+\n                                        \"  ... DgData Policy delegates\"\n                                    );\n                                    recId : ByteArray = getSpendingRecId(sa);\n                                    recId == datumId\n                                },\n                                UpdatingDelegatedData{\n                                    /* dgDataType*/ _ , recId\n                                } => {\n                                    // verify token name match\n                                    recId == datumId\n                                },\n                                _ => false\n                            }\n                        }\n                    );\n                    TODO(\"TEST THIS v\");\n                    print(\"recId: \" + datumId.show());\n                    REQT(\"spendDgt must be acting on the matching record-id\");\n                    assert(  // fails a test having a spending activity, but on wrong recId\n                        ( found.length > 0 ).trace( \"found activity for this recId? \")\n                    , \"❗ no spend delegate activity on this dgData\");\n                    TODO(\"TEST THIS too v\");\n                    REQT(\"spendDgt fails with multiple activities for the same recId\");\n                    assert(  // fails a test having multiple spending activities on the same rec id\n                        (found.length == 1).trace(\"has exactly one matching activity? \")\n                        , \"❗IMPOSSIBLE (caught by DelegateInput.withDDSpendingActivity())\"+\n                            \" spend delegate tried to act in multiple ways on the same token\"\n                    );\n                    checkThingOne && true\n                },\n                _ => {\n                    spendDgtInputRedeemer.switch {\n                        ConstrData{index, fields} => {\n                            print(\"unexpected redeemer: \" + index.show() );\n                            print(\"\\n\");\n                            assert(true || /* never executed */ fields.length > 0, \"unreachable\");\n                            error(\"spend delegate not triggered with a Spending activity\")\n                        },\n                        _ => error(\"unreachable\")\n                    }\n                }\n            };\n            print(\"  -- ^^^^^ REDUNDANT checks for delegate activity\\n\");\n\n            true\n            && hasMatchingValue\n            && uniqMatchingSpendDgtActivity\n            && delegateReturned \n        },\n        updatingCharter => {\n            print( \"  ...with activity updatingCharter\\n\");\n            TODO(\"make this obsolete by implementing capoLifecycleActivity\");\n            charterOutput : TxOutput = getCharterOutput(tx);\n            newCtDatum = CapoDatum::CharterData::from_data( \n                charterOutput.datum.inline\n            );\n\n            oldCtDatum : CapoDatum::CharterData = capoDatum.switch {\n                octd: CharterData => octd,\n                _ => error(\"wrong use of updatingCharter action for non-CharterData datum\")                \n            };\n            CapoDatum::CharterData{                \n                spendDelegate, \n                spendInvariants,\n                otherNamedDelegates,\n                mintDelegate, \n                mintInvariants,\n                nextGovDelegate,\n                nextManifest,\n                nextPendingPolicies\n            } = newCtDatum;\n\n            CharterData{\n                oldSpendDelegate, \n                oldSpendInvariants, \n                oldOtherNamedDelegates,\n                oldMintDelegate, \n                oldMintInvariants,\n                oldGovDelegate,\n                oldManifest,\n                oldPendingPolicies\n                // oldTypeMapUut\n            } = capoDatum; // or oldCtDatum - same error result either way\n\n            mustNotModifyMintInvariants : Bool =  ( mintInvariants == oldMintInvariants );\n            mustNotModifySpendInvariants : Bool = ( spendInvariants == oldSpendInvariants );\n            mustNotModifyManifest : Bool = ( nextManifest.serialize() == oldManifest.serialize() );\n            unchangedGovDelegate : Bool = ( nextGovDelegate.serialize() == oldGovDelegate.serialize() );\n\n            hasNeededGovDelegate : Bool =  true ||\n            checkpoint(\"must be validated by existing govDelegate\") && \n            nextGovDelegate.hasValidOutput( mph) && (\n                unchangedGovDelegate || oldGovDelegate.hasDelegateInput( \n                    inputs: tx.inputs, \n                    mph: mph,\n                    required: true\n                ).switch {\n                    None => error(\"unreachable\"),\n                    Some => true\n                }\n            );\n\n            unchangedSpendDgt : Bool = ( spendDelegate.serialize() == oldSpendDelegate.serialize() );\n            unchangedMintDgt : Bool = ( mintDelegate.serialize() == oldMintDelegate.serialize() );\n            // print(\" oldMintDgt: \" + oldMintDelegate.serialize().show());\n            // print(\"\\n\");\n            // print(\" newMintDgt: \" + mintDelegate.serialize().show());\n            // print(\"\\n\");\n            \n            changedAnyNamedDelegate : Bool = ( otherNamedDelegates.serialize() != oldOtherNamedDelegates.serialize() );\n            mustNotChangePendingPolicies = (nextPendingPolicies.serialize() == oldPendingPolicies.serialize());\n            // mustNotModifySettings : Bool = ( settingsUut == oldSettingsUut );\n            // mustNotModifyTypeInfo : Bool = ( typeMapUut == oldTypeMapUut );\n\n            if (true) {\n                print(\"is spendDgt unchanged? \" + unchangedSpendDgt.show());\n                print(\"  - old: \"+ oldSpendDelegate.uutName + \" => \"+ \n                    oldSpendDelegate.delegateValidatorHash.switch{\n                        Some{v} => v.show(), None => \" (any addr)\"\n                });\n                oldSDConfigStr = oldSpendDelegate.config.decode_utf8_safe();\n                print(\"       + cfg \" + oldSDConfigStr);\n                print(\"  - new: \"+ spendDelegate.uutName + \" => \"+ \n                    spendDelegate.delegateValidatorHash.switch{\n                        Some{v} => v.show(), None => \" (any addr)\"\n                });\n                newSDConfigStr = spendDelegate.config.decode_utf8_safe();\n                print(\"       + cfg \" + newSDConfigStr);\n                // print(\" - old: \" + oldSpendDelegate.serialize().show());\n                // print(\" - new: \" + spendDelegate.serialize().show());\n\n                print(\" -- is mintDgt unchanged?  \" + unchangedMintDgt.show());\n                print(\"  - old: \"+ oldMintDelegate.uutName + \" => \"+ \n                    oldMintDelegate.delegateValidatorHash.switch{\n                        Some{v} => v.show(), None => \" (any addr)\"\n                });\n                oldMDConfigStr = oldMintDelegate.config.decode_utf8_safe();\n                print(\"       + cfg \" + oldMDConfigStr);\n                print(\"  - new: \"+ mintDelegate.uutName + \" => \"+ \n                    mintDelegate.delegateValidatorHash.switch{\n                        Some{v} => v.show(), None => \" (any addr)\"\n                });\n                newMDConfigStr = mintDelegate.config.decode_utf8_safe();\n                print(\"       + cfg \" + newMDConfigStr);\n                print(\"\")\n                // print(\" - old: \" + oldMintDelegate.serialize().show());\n                // print(\" - new: \" + mintDelegate.serialize().show());\n\n                // print(\" -- is config unchanged? \" + mustNotModifySettings.show());\n                // print(\"\\n  - old: \"+ oldSettingsUut.decode_utf8_safe());\n                // print(\"\\n  - new: \"+ settingsUut.decode_utf8_safe());\n                // print(\"\\n\")\n            };\n            // assert(mustNotModifySettings, \"cannot change settings uut\");\n            // assert(mustNotModifyTypeInfo, \"cannot change typeInfo uut\");\n\n\n            // the high-level use-cases that can update charter are all mutually exclusive.  Count them\n            // and ensure that only one is present.\n            countUpdatedThings : Int = newCtDatum.countUpdatedThings(capoDatum);\n                // if ((!unchangedGovDelegate).trace(\"\\n -- govDgt changed? \")) { 1 } else { 0 } +\n                // if ((!unchangedSpendDgt).trace(\"\\n -- spendDgt changed? \") ) { 1 } else { 0 } +\n                // if ((!unchangedMintDgt).trace(\"\\n -- mintDgt changed? \") ) { 1 } else { 0 } +\n                // if (changedAnyNamedDelegate.trace(\"\\n -- namedDgt changed? \") ) { 1 } else { 0 };\n\n            assert(countUpdatedThings == 1, \n                \"expected exactly one item updated in charter, got \"+countUpdatedThings.show() + \"\"\n            );            \n\n            // mustNotModifySettings &&\n            // mustNotModifyTypeInfo &&\n            hasNeededGovDelegate &&\n            bREQT(\"must not change the manifest\", \n                mustNotModifyManifest\n            ) &&\n            checkpoint(\"1\") &&\n            if (unchangedMintDgt) {\n                // unchanged mintDgt must not be included in the tx\n                checkpoint(\"2b\") &&\n                mintDelegate.hasDelegateInput(\n                    inputs: tx.inputs, \n                    mph: mph,\n                    required: false\n                ).switch {\n                    None => {\n                        // was requiresNoDelegateInput(mintDelegate, mph)\n                        //  - it's ok to have it not included.\n                        true\n                    },\n                    Some{mintDgtInput} => {\n                        delegateActivity: AbstractDelegateActivitiesEnum = \n                            mintDelegate.getRedeemer(mintDgtInput);\n                        print(\"mint delegate input found\\n\");\n                        delegateActivity.switch {\n                            CapoLifecycleActivities{CLA} => CLA.switch {\n                                CreatingDelegate => {\n                                    print(\"TEMPORARY: allowing delegate creation while **updatingCharter**\\n\");\n\n                                    TODO(\"move delegate-creation to be separate from updatingCharter\");\n                                    TODO(\" ?? use capo ActivatingXxxxDelegate activity when adopting delegate\");\n\n                                    mintDelegate.hasValidOutput(mph)\n                                },\n                                _ => error(\"must use capoLifecycleActivity directly in Capo, not with generic updatingSettings\")\n                                // no other variants exist (yet).\n                                // _ => error(\"invalid use of mint delegate during charter update\")\n                            },\n                            _ => error(\"invalid use of mint delegate during charter update\")\n                        }\n                    }\n                }\n            } else {\n                //  the new one has to go to the right place\n                REQT(\"the updated mintDgt token must be deposited to its own script address\");\n                mintDelegate.hasValidOutput(mph)\n            } && \n            if ( unchangedSpendDgt) {\n                // unchanged spendDgt must not be included in the tx\n                checkpoint(\"4b\") &&\n                requiresNoDelegateInput(spendDelegate, mph)\n            } else {\n                REQT(\"the updated spendDgt token must be deposited to its own script address\");\n                checkpoint(\"4a\") &&\n                spendDelegate.hasValidOutput(mph)\n            } &&\n            checkpoint(\"5\") &&\n            if (!changedAnyNamedDelegate) { true } else {\n                checkpoint(\"5b\") && \n                otherNamedDelegates.fold( (ok: Bool, name : String, dgt : RelativeDelegateLink) -> Bool {\n                    ok && \n                    oldOtherNamedDelegates.get_safe(name).switch {\n                        None => {\n                            print (\" - adopting named delegate: \" + name);\n                            print(\"\\n\");\n                            true\n                        },\n                        Some{oldDgt} => { \n                            if (oldDgt.serialize() == dgt.serialize()) {\n                               // unchanged named delegate must not be included in the tx\n                                requiresNoDelegateInput(dgt, mph)\n                            } else {\n                                TODO(\"the old named delegate must be retired, or be force-replaced (in a different activity?)\");\n                                //  the new one has to go to the right place\n                                dgt.hasValidOutput(\n                                    mph, required: true, \n                                    createdOrReturned: DgTkn::Created)\n                            }\n                        }\n                    }\n                }, true)\n            } &&\n            mustNotChangePendingPolicies &&\n            mustNotModifyMintInvariants &&\n            mustNotModifySpendInvariants &&\n            requiresAuthorization(oldCtDatum) &&\n            checkpoint(\"6\")\n        },\n        capoLifecycleActivity{myCLActivity} => {\n            print( \"  ...with activity capoLifecycleActivity\\n\");\n\n            oldCtDatum : CapoDatum::CharterData = capoDatum.switch {\n                octd: CharterData => octd,\n                _ => error(\"wrong use of updatingCharter action for non-CharterData datum\")                \n            };\n\n            charterOutput : TxOutput = getCharterOutput(tx);\n            newCtDatum : CapoDatum::CharterData = CapoDatum::CharterData::from_data( \n                charterOutput.datum.inline\n            );\n            REQT(\"all capoLifecycleActivities require the govAuthority\");\n            cctx = mkCapoCtx(mph).\n                withCharterInput().\n                requiresGovAuthority();\n\n            myCLActivity.switch {\n                forcingNewMintDelegate{seed, purpose} => {\n                    // we handle it directly\n                    REQT(\"when forcingNewMintDelegate, ONLY the mintDelegate is updated\");\n                    assert(\n                        oldCtDatum.mintDelegateLink.serialize() != \n                        newCtDatum.mintDelegateLink.serialize(), \n                        \"must update mintDelegate\"\n                    );\n                    assert(\n                        oldCtDatum.countUpdatedThings(newCtDatum) == 1, \n                        \"must not update anything except mintDelegate\"\n                    );                    \n                    assert(oldCtDatum.mintDelegateLink.uutName != newCtDatum.mintDelegateLink.uutName,\n                        \"new mintDelegate token must be different from the old one\"\n                    );\n                    tnFactory = mkUutTnFactory(seed);\n                    REQT(\"the new mintDgt must have the new dgTkn\");\n                    expectedTn = tnFactory(purpose);\n                    assert(\n                        newCtDatum.mintDelegateLink.uutName == expectedTn,\n                        \"wrong mintDelegate token name '\"+ \n                            newCtDatum.mintDelegateLink.uutName +\n                            \"' added to charter; should be: \"+ expectedTn\n                    );\n\n                    REQT(\"the new mintDelegate must be present in its own script address\");\n                    newCtDatum.mintDelegateLink.hasValidOutput(mph, true, \n                        DgTkn::Created\n                    ) &&\n                    bREQT(\"Ensures the new mintDgt-* uut is minted with a seed\") &&\n                    validateUutMinting(\n                        mph: mph,\n                        seed: seed,\n                        purposes: []String{purpose},\n                        mkTokenName: tnFactory,\n                        needsMintDelegateApproval: false \n                    )\n                },\n                forcingNewSpendDelegate{seed, purpose} => {\n                    // we handle it directly\n                    REQT(\"when forcingNewSpendDelegate, ONLY the spendDelegate is updated\");\n                    assert(\n                        oldCtDatum.spendDelegateLink.serialize() != newCtDatum.spendDelegateLink.serialize(), \n                        \"must update spendDelegate\"\n                    );\n                    assert(\n                        oldCtDatum.countUpdatedThings(newCtDatum) == 1, \n                        \"must not update anything except spendDelegate\"\n                    );\n\n                    assert(oldCtDatum.spendDelegateLink.uutName != newCtDatum.spendDelegateLink.uutName,\n                        \"new spendDelegate token must be different from the old one\"\n                    );\n                    tnFactory = mkUutTnFactory(seed);\n                    REQT(\"the new spendDgt must have the new dgTkn\");\n                    expectedTn = tnFactory(purpose);\n                    assert(\n                        newCtDatum.spendDelegateLink.uutName == expectedTn,\n                        \"wrong spendDelegate token name '\"+ \n                            newCtDatum.spendDelegateLink.uutName +\n                            \"' added to charter; should be: \"+ expectedTn\n                    );\n\n\n                    REQT(\"the new spendDelegate must be present in its own script address\");\n                    newCtDatum.spendDelegateLink.hasValidOutput(mph, true, \n                        DgTkn::Created\n                    ) &&\n                    bREQT(\"Ensures the new spendDgt-* uut is minted with a seed\") &&\n                    validateUutMinting(\n                        mph: mph,\n                        seed: seed,\n                        purposes: []String{purpose},\n                        mkTokenName: tnFactory,\n                        needsMintDelegateApproval: false\n                    )\n                },\n                _ => {\n                    matchesActivity = (dgtActivity: AbstractDelegateActivitiesEnum) -> Bool {\n                        dgtActivity.switch {\n                            CapoLifecycleActivities{cla} => {\n                                bREQT(\n                                    \"  - the delegate's activity must match the capo's lifecycle activity\",\n                                    (cla == myCLActivity)\n                                )\n                            },\n                            _ => error(\"delegate must use CapoLifecycleActivities\")                            \n                        }\n                    };\n                    needsMintDgt = () -> Bool {\n                        REQT(\"  - enforces presence of the mint delegate\");\n                        mintDgt = cctx.requiresMintDelegateInput();\n                        assert(mintDgt.requiresValidOutput(), \"<-- that fails, this doesn't\");\n                        matchesActivity(mintDgt.genericDelegateActivity())\n                    };\n                    needsSpendDgt = () -> Bool {\n                        REQT(\"  - enforces presence of the spend delegate\");\n                        spendDgt = cctx.requiresSpendDelegateInput();\n                        assert(spendDgt.requiresValidOutput(), \"<-- that fails, this doesn't\");\n                        matchesActivity(spendDgt.genericDelegateActivity())\n                    };\n                    cctx.dgtRolesForLifecycleActivity(myCLActivity).switch {\n                        HandledByCapoOnly => error(\"unreachable\"),\n                        MintDgt => {\n                            needsMintDgt()\n                        },\n                        SpendDgt => {\n                            needsSpendDgt()\n                        },\n                        BothMintAndSpendDgt => {\n                            needsMintDgt() &&\n                            needsSpendDgt()\n                        },\n                        _ => error(\"dgtRolesForLifecycleActivity should indicate only mint/spend/both delegate-roles\")\n                    },\n\n                    TODO(\"review updatingManifest case\");\n                    // updatingManifest => {\n                    //     // the spend delegate must be triggered with its updatingManifest activity\n                    //     // (exactly the same as our updatingManifest)\n                    //     cctx.requiresSpendDelegateInput()\n                    //         .updatingManifest()\n                    //         .requiresValidOutput()\n                    // }, \n    \n                    // REQT(\"for normal lifecycle activities, the spendDelegate's activity must match the capo's lifecycle activity\");\n                    // assert(\n                    //     delegateCLActivity.serialize() == myCLActivity.serialize(),\n                    //     \"the spendDelegate's CapoLifecycleActivity must match the capo's\"\n                    // );\n                    true\n                }\n            }\n        },\n        retiringRefScript => {\n            print( \"  ...with activity retiringRefScript\\n\");\n            // the ref script is being spent:\n            isSpendingRefScript : Bool = capoDatum.switch{\n                ScriptReference => true,\n                _ => error(\"wrong use of retiringRefScript action for non-ScriptRef datum\")\n            };\n\n            hasGovAuthority : Bool = mustHaveGovAuthority(mph);\n\n            isSpendingRefScript && \n            hasGovAuthority &&\n            true\n            // no other constraints; the ref script could be re-created or\n            // replaced with a new one, or simply destroyed.\n        },\n\n        usingAuthority => {\n            print( \"  ...with activity usingAuthority\\n\");\n            capoDatum.switch {\n                 // throws if bad\n                ctd : CharterData => requiresAuthorization(ctd),\n                _ => error(\"wrong use of usingAuthority action for non-CharterData datum\")\n            }\n        },\n\n        // updatingSettings => {\n        //     // FUT: possibly move this to the spend-delegate layer\n        //     print( \"  ...with activity updatingSettings\\n\");\n        //     _isRelevantDatum : Bool = capoDatum.switch {\n        //         // SettingsData => true,\n        //         CharterData => true,\n        //         _ => error(\"wrong use of updatingSettings action; must use only on CharterData\")\n        //     };\n\n        //     // it requires the govAuthority to be present \n        //     REQT( \"gov authority must be present to update settings\");\n        //     hasGovAuthority : Bool = mustHaveGovAuthority(\n        //         mph: mph,\n        //         charterData: charterData // already resolved\n        //     );\n\n        //     CapoDatum::CharterData{\n        //         spendDelegate,\n        //         spendInvariants,\n        //         namedDelegates,\n        //         mintDelegate ,\n        //         mintInvariants,\n        //         govDelegate,\n        //         manifest\n        //     } = capoDatum;\n\n        //     REQT(\"the current Settings must be spent and updated\");\n        //     settingsDgtLink : RelativeDelegateLink = namedDelegates.get_safe(\"settings\").switch {\n        //         None => error(\"'settings' delegate must be present to do updatingSettings activity\"),\n        //         Some{dgt} => dgt\n        //     };\n\n        //     settingsDgtInput = settingsDgtLink.hasDelegateInput(\n        //         inputs: tx.inputs,\n        //         mph: mph\n        //     ).unwrap();\n        //     settingsDelegateIsValid : Bool = AbstractDelegateActivitiesEnum::from_data( \n        //         mustFindInputRedeemer(settingsDgtInput)\n        //     ).switch {\n        //         SpendingActivities => true,\n        //         _ => assert(\"settings delegate must be updating the settings with its SpendingActivities variant\")\n        //     };\n        //     _nextSettings : Data = cctx.getNextManifestedDatumRaw(\"settings\");\n        //     isUpdatingSettings : Bool = true;\n\n        //     // ?? can we iterate inputs along with delegates, to reduce the overhead\n        //     //    ... of multiple passes over the tx inputs?\n        //     //  option 1: pay for iterating N inputs, \n        //     //    - times a switch{} for delegate-matching\n        //     //    -    ... and invariants-iteration\n        //     //    -    ... and namedDelegates-iteration\n        //     //    - Plus a \"is-anything-missing\" check over delegates/invariants/namedDelegates\n        //     // option 2: switch and iterate over delegates, invariants, namedDelegates\n        //     //    - times a switch for input-finding\n        //     //    - ... and no separate is-anything-missing checks.\n        //     // ^^^ option 2 has to be cheaper.\n\n        //     inputs: []TxInput = tx.inputs;\n\n        //     REQT( \"spend delegate must validate settings\");\n        //     spendDelegateIsValidating : Bool = \n        //         spendDelegate.validatesUpdatedSettings(\n        //             inputs: inputs,\n        //             mph: mph,\n        //             inputRequired: true\n        //         ).unwrap();\n\n        //     REQT(\"mint delegate must validate settings\");\n        //     mintDelegateIsValidating : Bool = \n        //         mintDelegate.validatesUpdatedSettings(\n        //             inputs: inputs,\n        //             mph: mph,\n        //             inputRequired: true\n        //         ).unwrap();\n\n        //     // govAuthority is checking the settings\n        //     REQT( \"govDelegate MAY contribute to settings validation\");\n        //     govDelegateMaybeValidating : Bool = \n        //         govDelegate.validatesUpdatedSettings(\n        //             inputs: inputs,\n        //             mph: mph,\n        //             inputRequired: false\n        //         ).switch{\n        //             Some => true,\n        //             None => {\n        //                 print(\"  -- govAuthority isn't a script-based validator; doesn't validate new settings\\n\");\n        //                 true\n        //             }\n        //         };\n        //     checkOneInvariant : (RelativeDelegateLink) -> Bool = \n        //     (oneDgt: RelativeDelegateLink) -> Bool {\n        //         REQT( \"invariant must validate settings\");\n        //         oneDgt.validatesUpdatedSettings(\n        //             inputs: inputs,\n        //             mph: mph,\n        //             inputRequired: true\n        //         ).unwrap()\n        //     };\n        //     // spendInvariants are checking the settings\n        //     REQT( \"spend invariants must validate settings\");\n        //     spendInvariantsAreValidating : Bool = spendInvariants.all( \n        //         checkOneInvariant\n        //     );\n        //     // mintInvariants are checking the settings\n        //     REQT( \"mint invariants must validate settings\");\n        //     mintInvariantsAreValidating : Bool = mintInvariants.all( \n        //         checkOneInvariant\n        //     );\n        //     // namedDelegates are checking the settings\n        //     REQT( \"named delegates must validate settings\");\n        //     namedDelegatesAreValidating : Bool = namedDelegates.fold( \n        //         REQT( \"  - each named delegate must validate settings\");\n        //         (ok: Bool, key: String, dgt: RelativeDelegateLink) -> Bool {\n        //             print(\"  - named delegate: \" + key);\n        //             print(\"\\n\");\n        //             ok && dgt.validatesUpdatedSettings(\n        //                 inputs: inputs,\n        //                 mph: mph,\n        //                 inputRequired: true\n        //             ).unwrap()\n        //         }, true\n        //     );\n\n        //     isRelevantDatum &&\n        //     settingsDelegateIsValid &&\n        //     isUpdatingSettings &&\n        //     spendDelegateIsValidating &&\n        //     mintDelegateIsValidating &&\n        //     govDelegateMaybeValidating &&\n        //     spendInvariantsAreValidating &&\n        //     mintInvariantsAreValidating &&\n        //     namedDelegatesAreValidating &&\n        //     hasGovAuthority\n        // },\n        // retiringSettings => {\n        //     print( \"  ...with activity retiringSettings\\n\");\n        //     error(\"implement me\")\n        // },\n        _ => error(\"unhandled activity\")\n    };\n\n    assert(allDatumSpecificChecks, \"some datum-check failed\");\n    assert(allActivitySpecificChecks, \"some redeeemer-check failed\");\n\n    //! retains mph in parameterization\n    assert(\n        ( allDatumSpecificChecks && allActivitySpecificChecks ) ||\n            // this should never execute (much less fail), yet it also shouldn't be optimized out.\n             mph.serialize() /* never */ == mph.serialize(), \n        \"unreachable\"\n    ); \n    print(\"\\n🚥🟢 Capo validator: ok!\\n\\n\");\n\n    allDatumSpecificChecks && \n    allActivitySpecificChecks\n    // tx.serialize() != datum.serialize()\n}\n", {
    project: "stellar-contracts",
    purpose: "spending",
    name:  "src/DefaultCapo.hl", // source filename
    moduleName:  "Capo",
});

export { Capo_hl as C, StellarHeliosHelpers_hl as S, TypeMapMetadata_hl as T, CapoMintHelpers_hl as a, CapoDelegateHelpers_hl as b, CapoHelpers_hl as c };
//# sourceMappingURL=DefaultCapo.mjs.map
