import { makeSource } from '@helios-lang/compiler-utils';

const BasicDelegate_hl = makeSource(
  "spending BasicDelegate\n\nconst rev : Int = 1\nconst instance : ByteArray = #67656e6572616c // -> \"general\"\nconst delegateName : String // = \"ðŸ’©  noName Delegate : ( \"\nconst isMintDelegate : Bool = false\nconst isSpendDelegate : Bool = false\nconst isDgDataPolicy : Bool = false\nconst requiresGovAuthority : Bool = true\n\nimport {\n    tx, \n    get_current_input,\n    get_current_validator_hash\n} from ScriptContext\n\nimport {\n    DelegateRole,\n    DelegationDetail,\n    DgTknDisposition as DgTkn,\n    ManifestActivity,\n    PendingCharterChange,\n    PendingDelegateChange,\n    PendingDelegateAction,\n    RelativeDelegateLink\n} from CapoDelegateHelpers\n\n// import {\n//     ProtocolSettings\n// } from ProtocolSettings\n\nimport {\n    getTxCharterData,\n    mkCapoCtx,\n    CapoCtx,\n    // mkTokenShow,\n    CapoDatum,\n    CapoManifestEntry,\n    ManifestEntryType\n    // CapoActivity\n} from CapoHelpers\n\nimport {\n    mkUutTnFactory,\n    validateUutMinting\n} from CapoMintHelpers\n\nimport {\n    fromCip68Wrapper,\n    outputAndDatum,\n    returnsValueToScript,\n    TODO,\n    REQT,\n    bREQT\n    // tvCharter\n} from StellarHeliosHelpers\n\nimport {\n    DelegateActivity,\n    DelegateDatum,\n    BurningActivity,\n    MintingActivity,\n    SpendingActivity\n} from specializedDelegate\n\n// formerly was in Capo core contract script\n// func allDelegatesAreValidatingSettings() -> Bool {\n//         // print( \"  ...with activity updatingSettings\\n\");\n//         // _isRelevantDatum : Bool = capoDatum.switch {\n//         //     // SettingsData => true,\n//         //     CharterData => true,\n//         //     _ => error(\"wrong use of updatingSettings action; must use only on CharterData\")\n//         // };\n//         // !!! move to SettingsDelegate?  or keep as a baseline check?\n//         // it requires the govAuthority to be present \n//         REQT( \"gov authority must be present to update settings\");\n//         hasGovAuthority : Bool = mustHaveGovAuthority(\n//             mph: mph,\n//             charterData: charterData // already resolved\n//         );\n\n//         CapoDatum::CharterData{\n//             spendDelegate,\n//             spendInvariants,\n//             otherNamedDelegates,\n//             mintDelegate,\n//             mintInvariants,\n//             govDelegate,\n//             manifest\n//         } = capoDatum;\n\n//         //!!! note, this is a hard-coded version of requiring the settings policy script:\n//         REQT(\"the current Settings must be spent and updated\");\n//         settingsDgtLink : RelativeDelegateLink = otherNamedDelegates.get_safe(\"settingsPol\").switch {\n//             None => error(\"'settings' delegate must be present to do updatingSettings activity\"),\n//             Some{dgt} => dgt\n//         };\n\n//         settingsDgtInput = settingsDgtLink.hasDelegateInput(\n//             inputs: tx.inputs,\n//             mph: mph\n//         ).unwrap();\n//         settingsDelegateIsValid : Bool = AbstractDelegateActivitiesEnum::from_data( \n//             mustFindInputRedeemer(settingsDgtInput)\n//         ).switch {\n//             SpendingActivities => true,\n//             _ => assert(\"settings delegate must be updating the settings with its SpendingActivities variant\")\n//         };\n//         _nextSettings : Data = cctx.getNextManifestedDatumRaw(\"settings\");\n//         isUpdatingSettings : Bool = true;\n        \n//         inputs: []TxInput = tx.inputs;\n\n//         //!!! actually requiring delegates' SettingsValidation starts here.\n//         REQT( \"spend delegate must validate settings (wait, that's myself.  Call validate directly?\");\n\n//         spendDelegateIsValidating : Bool = \n//             spendDelegate.validatesUpdatedSettings(\n//                 inputs: inputs,\n//                 mph: mph,\n//                 inputRequired: true\n//             ).unwrap();\n\n//         REQT(\"mint delegate must validate settings\");\n//         mintDelegateIsValidating : Bool = \n//             mintDelegate.validatesUpdatedSettings(\n//                 inputs: inputs,\n//                 mph: mph,\n//                 inputRequired: true\n//             ).unwrap();\n\n//         // govAuthority is checking the settings\n//         REQT( \"govDelegate MAY contribute to settings validation\");\n//         govDelegateMaybeValidating : Bool = \n//             govDelegate.validatesUpdatedSettings(\n//                 inputs: inputs,\n//                 mph: mph,\n//                 inputRequired: false\n//             ).switch{\n//                 Some => true,\n//                 None => {\n//                     print(\"  -- govAuthority isn't a script-based validator; doesn't validate new settings\\n\");\n//                     true\n//                 }\n//             };\n//         checkOneInvariant : (RelativeDelegateLink) -> Bool = \n//         (oneDgt: RelativeDelegateLink) -> Bool {\n//             REQT( \"invariant must validate settings\");\n//             oneDgt.validatesUpdatedSettings(\n//                 inputs: inputs,\n//                 mph: mph,\n//                 inputRequired: true\n//             ).unwrap()\n//         };\n//         // spendInvariants are checking the settings\n//         REQT( \"spend invariants must validate settings\");\n//         spendInvariantsAreValidating : Bool = spendInvariants.all( \n//             checkOneInvariant\n//         );\n//         // mintInvariants are checking the settings\n//         REQT( \"mint invariants must validate settings\");\n//         mintInvariantsAreValidating : Bool = mintInvariants.all( \n//             checkOneInvariant\n//         );\n//         // namedDelegates are checking the settings\n//         REQT( \"named delegates must validate settings\");\n//         namedDelegatesAreValidating : Bool = otherNamedDelegates.fold( \n//             REQT( \"  - each named delegate must validate settings\");\n//             (ok: Bool, key: String, dgt: RelativeDelegateLink) -> Bool {\n//                 print(\"  - named delegate: \" + key);\n//                 print(\"\\n\");\n//                 ok && dgt.validatesUpdatedSettings(\n//                     inputs: inputs,\n//                     mph: mph,\n//                     inputRequired: true\n//                 ).unwrap()\n//             }, true\n//         );\n\n//         isRelevantDatum &&\n//         settingsDelegateIsValid &&\n//         isUpdatingSettings &&\n//         spendDelegateIsValidating &&\n//         mintDelegateIsValidating &&\n//         govDelegateMaybeValidating &&\n//         spendInvariantsAreValidating &&\n//         mintInvariantsAreValidating &&\n//         namedDelegatesAreValidating &&\n//         hasGovAuthority\n// }\n\nfunc checkOneActivity(\n    dgtionDatum: DelegateDatum::IsDelegation, \n    activity: DelegateActivity,\n    dd : DelegationDetail = dgtionDatum.dd,\n    baseCctx: CapoCtx = mkCapoCtx(dd.mph)\n) -> Bool {\n    print(\"ðŸ’ checking activity:\\n\");\n\n    result = if (true) {\n        if( true ) {\n            checkNonDelegatedActivities: Bool = activity.switch {\n                MultipleDelegateActivities{activities} => {\n                    // NOTE: the Capo ensures that each SPENT UTxO is addressed by EXACTLY ONE SpendDgt activity.\n                    // When executed in a mint/spend delegate, the policy below ensures \n                    // ... that each requested activity is matched by a UTxO in the transaction, \n                    // ... guaranteeing 1:1 coverage of activities & UTxOs.\n\n                    // Those are executed in parts (one set of activities applicable to mintDgt-* token,\n                    //   ... and the other governed by a spendDgt-* token.  It is common that the exact\n                    //   ... same contract script executes both, unless it has a special need to\n                    //   ... separate the code for those two; regardless, each is enforced in\n                    //   ... a separate execution (different utxos, different activity/redeemer each).\n\n                    // For now, only *DelegatedData activities are valid in mint/spend multi-activities.\n\n                    // Special: DeletingDelegatedDatum requires a Spend validation as well as a Burn validation,\n                    //   ... so it will be present in both the mintDgt and spendDgt multi-activities.\n\n                    cctx : CapoCtx = baseCctx.withCharterRef();\n\n                    mintDgtCheck : Bool = if (!isMintDelegate) {\n                        true \n                    } else if (!cctx.nowActingAsMintDgt(required: false)) {\n                        true\n                    } else {\n                        activities.all( (rawActivity: Data) -> Bool {\n                            a : DelegateActivity = DelegateActivity::from_data(rawActivity);\n\n                            // probably can't fail here:\n                            // assert(isMintDelegate, \"ack! non-MintDelegate can't act as mintDgt\");\n                            print(\"  -- mintDgt checking multi-activity\");\n                            REQT(\"in the mint delegate, only {Create,Delete}DelegatedData activities are valid in multi-activities\");\n\n                            a.switch {\n                                // in the Mint and Spend delegates, these nested activities are expected to re-delegate \n                                // to delegated-data controllers, which will use Mint/Spend/Burn activities on the data-controller tokens.\n                                CreatingDelegatedData/*{TxOutputId{seedTxn, seedIdx}, dDataTypeName} */=> {\n                                    // Note: CreatingDelegatedData activity doesn't involve the Capo at all!\n                                    // Instead, the minter creates a UUT for the data, on authority of the mintDgt;\n                                    // ... and the mintDgt requires the presence of the corresponding dgDataPolicy (with its MintingActivity);\n                                    // ... then the dgDataPolicy checks the validity of the new data, and requires that\n                                    // ... the new data is created as a DelegatedData record in the Capo address.\n\n                                    // assert(isMintDelegate && cctx.nowActingAsMintDgt(),\n                                    //     \"CreatingDelegatedData only ok in mintDgt\"\n                                    //     // \" ... use MintingActivities in a delegated-data controller\"\n                                    // );\n                                    // recursion checks for the needed input/output and DgDataController MintingActivity\n                                    checkOneActivity(dgtionDatum, a, dd, cctx)\n                                },\n                                DeletingDelegatedData => {\n                                    // assert(isMintDelegate, \"DeletingDelegatedData only ok in mintDgt\" ); // \" ... use BurningActivities in a delegated-data controller\"\n                                    // cctx.nowActingAsMintDgt() &&\n    \n                                    // recursion checks for the needed input/burn                                \n                                    checkOneActivity(dgtionDatum, a, dd, cctx)\n                                },\n                                UpdatingDelegatedData => error(\n                                    \"UpdatingDelegatedData only ok at level-1 spendDgt\"\n                                ),\n                                DelegateLifecycleActivities => error(\"multi:DelegateLifecycleActivities not ok\"),\n                                CapoLifecycleActivities => error(\"multi:CapoLifecycleActivities not ok\"),\n                                MultipleDelegateActivities => error(\"multi:multi: nesting not ok\"),\n    \n                                _ => error(\"multi:non-minting activities are invalid for mintDgt\")\n                            }\n                        })\n                    };\n\n                    spendDgtCheck : Bool = if (!isSpendDelegate) {\n                        true \n                    } else if (!cctx.nowActingAsSpendDgt(required: false)) {\n                        true\n                    } else {\n                        // probably can't fail here:\n                        // assert(isSpendDelegate, \"ack! non-SpendDelegate can't act as spendDgt\");\n                        activities.all( (rawActivity: Data) -> Bool {\n                            a : DelegateActivity = DelegateActivity::from_data(rawActivity);\n                            print(\"  -- spendDgt checking multi-activity\");\n                            REQT(\"in the spend delegate, only {Updating,Deleting}DelegatedData activities are valid in multi-activities\");\n                            a.switch {\n                                // in the Mint and Spend delegates, these nested activities are expected re-delegate to delegated-data controllers,\n                                // which will use Mint/Spend/Burn activities on the data-controller tokens.\n                                UpdatingDelegatedData{_typeName, _recId} => {\n                                    assert(isSpendDelegate && cctx.nowActingAsSpendDgt(),\n                                        \"UpdatingDelegatedData only ok at level-1 spendDgt\"\n                                        // \" ... a delegated-data-controller will use one of its SpendingActivities to govern capoStoredData's spend\"\n                                    );\n                                    // the recursion always checks for the input-datum, so we\n                                    // don't need to check it here.\n                                    // _inputDD = cctx.delegatedDataTxInput(recIdBytes: recId);\n                                    checkOneActivity(dgtionDatum, a, dd, cctx)\n                                },\n                                CreatingDelegatedData => error(\n                                    \"CreatingDelegatedData only ok in mintDgt\"\n                                ),\n                                DeletingDelegatedData => {\n                                    error(\"TODO: validate spending the datum for burn\")\n                                },\n                                DelegateLifecycleActivities => error(\"multi:DelegateLifecycleActivities not ok\"),\n                                CapoLifecycleActivities => error(\"multi:CapoLifecycleActivities not ok\"),\n                                MultipleDelegateActivities => error(\"multi:multi: nesting not ok\"),\n                                _ => error(\"multi: non-spending activities are invalid for spendDgt\")\n                            }\n                        })\n                    };\n                \n                    dgDataPolicyCheck : Bool = if (isMintDelegate || isSpendDelegate) {\n                        assert(!isDgDataPolicy, \"ack! mint/spend delegate can't be a delegated-data policy!\");\n                        true \n                    } else {\n                        TODO(\"assert isDgDataPolicy\"); // assert(isDgDataPolicy, \"invalid use of multiActivity by non-DgDataPolicy\");\n                        activities.all( (rawActivity: Data) -> Bool {\n                            a : DelegateActivity = DelegateActivity::from_data(rawActivity);\n\n                            print(\"  -- dgDataPolicy checking multi-activity\");\n                            // WHEN this code is supporting a DgDataPolicy (with its own specializedDelegate module),\n                            //   the multi-activity expects Minting/Spending/Burning activities, not *DelegatedData activities.\n                            REQT(\"in DgDataPolicy, only Minting/Burning/Spending activities are valid\");\n                            a.switch {\n                                UpdatingDelegatedData => error(\n                                    \"UpdatingDelegatedData only ok at level-1 spendDgt (use a SpendingActivity in dgDataPolicy)\"\n                                ),\n                                CreatingDelegatedData => error(\n                                    \"CreatingDelegatedData only ok in mintDgt (use a MintingActivity in dgDataPolicy)\"\n                                ),\n                                DeletingDelegatedData => error(\n                                    \"DeletingDelegatedData only ok at mint/spend dgt (use BurningActivity in dgDataPolicy)\"\n                                ),\n                                // in the delegated-data controllers, we have to support these multi-activities.\n                                // this will pass through the individual activity to be individually validated by the specialized delegate \n                                // module that governs the data-controller's UUT, in its additionalDelegateValidation() function.\n                                SpendingActivities => checkOneActivity(dgtionDatum, a, dd, cctx),\n                                MintingActivities => checkOneActivity(dgtionDatum, a, dd, cctx),\n                                BurningActivities => {\n                                    assert(false, \"TODO: support multi:BurningActivities for dgDataPolicy or other delegate\") ;\n                                    checkOneActivity(dgtionDatum, a, dd, cctx)\n                                },\n                                DelegateLifecycleActivities => error(\"multi:DelegateLifecycleActivities not ok\"),\n                                CapoLifecycleActivities => error(\"multi:CapoLifecycleActivities not ok\"),\n                                MultipleDelegateActivities => error(\"multi:multi: nesting not ok\")\n                                // _ => error(\"multi: invalid other activity for non-mint/spend delegate\")\n                            }\n                        })\n                    };\n\n                    mintDgtCheck && spendDgtCheck && dgDataPolicyCheck\n                },\n                //   guards that the authority token is returned to this script.\n                // specialized minting delegates should likely perform additional checks.\n                DelegateLifecycleActivities{innerActivity} => innerActivity.switch {\n                    // reassigning the authority token to a new minting delegate\n                    ReplacingMe{seed, purpose} => {\n                        // should burn the old UUT, mint the new UUT, and update the Charter\n                        // with the new mint authority\n\n                        //xxx -   tx.minted.get_safe( dd.acAuthorityToken() ) == 0 &&\n                        //xxx -   !returnsValueToScript( dd.tvAuthorityToken())\n\n                        BURNED: Int = -1;\n                        otherMintedValue: Value = Value::new(\n                            AssetClass::new(dd.mph, dd.tn), \n                            BURNED\n                        );\n                    \n                        tnStr : String = dd.tn.decode_utf8_safe();\n                        print(\"checking ReplacingMe on \"+purpose + \": \"+ tnStr);\n                        REQT(\"needs the charter to be approving the the new mint-delegate\");\n                        TODO(\"  ^^^ should queue the new delegate in pendingChanges\");\n\n                        cctx : CapoCtx = baseCctx.withCharterInput();\n                        isUpdatingCharter : Bool = cctx.getCharterRedeemer().switch {\n                            // THE CHARTER UPDATE ITSELF WILL CHECK THAT THERE'S A VALID DELEGATE OUTPUT FOR THE NEW DELEGATE\n                            updatingCharter => true,\n                            _ => false\n                        };\n\n                        isMintingOk : Bool = validateUutMinting(\n                            mph: dd.mph,\n                            seed: seed,\n                            purposes: []String{purpose}, \n                            otherMintedValue: otherMintedValue,\n                            needsMintDelegateApproval: false,\n                            extraMintDelegateRedeemerCheck: false\n                        );\n\n                        isMintingOk && isUpdatingCharter\n\n                    },\n\n                    // the token is being burned, retiring the authority token for this minting delegate\n                    // as a result, this minting delegate will no longer be consulted.  This could be combined\n                    // with the creation of a new minting delegate with a new authority token, registered\n                    // with the Capo in place of this one (or Reassigning could be used for such a case).\n                    // If there is no replacement minting delegate, then the Capo will not be able to perform \n                    // any further minting activities.\n                    //\n                    // Retiring is not suitable for authorizing token-burning.\n                    Retiring => {\n                        REQT(\"... Retiring delegate authority token\");\n                        REQT(\"   -- must burn the indicated authority token\");\n                        tx.minted.get(dd.acAuthorityToken()) == -1\n                    },\n\n                    ValidatingSettings => {\n                        _charter : CapoDatum::CharterData = getTxCharterData(dd.mph);\n\n                        // each application-specific delegate must validate the settings\n                        // for itself?\n                        // OR: import the settings type, and trigger the validation here\n                        // ... so delegate authors can have fewer hoops to jump through\n                        TODO(\"import settings from delegate and validate them\");\n\n                        // _foundSettings = ProtocolSettings::from_data(cctx.getManifestedData(\"settings\"));\n\n                        //xxx foundSettings : outputAndDatum[CapoDatum::SettingsData] = \n                        //xxx     charter.mustFindSettingsOutput(dd.mph, dd.capoAddr);\n                        //xxx customSettings = fromCip68Wrapper[ProtocolSettings](foundSettings.rawData);\n\n                        // print(\"\\n\" + delegateName + \": delegate TRYING TO VALIDATE SETTINGS\\n\");\n                        // validated : Bool = customSettings.validate();\n                        // print(\"HURRAY\\n\");\n\n                        // TODO: also validate any typeMap (can do this later and adopt the new delegate \n                        // into the Capo when this code is written)\n\n                        assert( false && \n                            // validated && \n                            // isValid : Bool = \n                            //     ((isTest && throwIfBadSettings(dgtionDatum, settings)) || true) &&\n                            //     dgtionDatum.validateSettings(settings);\n                            // isValid\n                            true,\n                            \"ValidateSettings temporarily disabled\"\n                        );\n                        false\n                    }\n                },\n                CapoLifecycleActivities{dCLA} => {\n                    REQT(\"... with any CapoLifecycle activity: \");\n                    cctx = mkCapoCtx(dd.mph).\n                        withCharterInput().\n                        requiresGovAuthority();                    \n\n                    // the Capo policy already requires that this activity is identical\n                    // to the capo's own triggered lifecycle activity, given that the\n                    // capoLifecycleActivity is what's involved on that end.  We\n                    // ensure that is true here:\n                    REQT(\"requires the Capo's CharterData activity to match this delegate's activity\");\n                    cctx.getCharterRedeemer().switch {\n                        capoLifecycleActivity{cCLA} => {\n                            assert(\n                                cCLA == dCLA,\n                                \"activity mismatch with Capo's CharterData activity\"\n                            );\n                            print(\"  -- ok, CharterData capoLifecycleActivity matches ours\\n\")\n\n                        },\n                        updatingCharter => {\n                            dCLA.switch {\n                                CreatingDelegate => {\n                                    print(\"ok, Capo:updatingCharter works for now with CreatingDelegate\\n\")\n                                },\n                                _ => error(\"when Capo is UpdatingCharter, the mintDelegate must be CreatingDelegate\")\n                            }\n                        },\n                        _ => error(\"this activity must match the capo's own CharterData activity\")\n                    };\n\n                    // wantsRole : DelegateRole = CLA.switch {\n                    //     forcingNewSpendDelegate => error(\"the forcingNewSpendDelegate escape-hatch activity is always handled directly by the Capo\"),\n                    //     forcingNewMintDelegate => error(\"the forcingNewMintDelegate escape-hatch activity is always handled directly by the Capo\"),\n                    //     removePendingChange => DelegateRole::SpendDgt,\n                    //     commitPendingChanges => DelegateRole::BothMintAndSpendDgt,\n                    //     updatingManifest => DelegateRole::SpendDgt,\n\n                    //     CreatingDelegate => {\n                    //         TODO(\"deprecate use of CLA::CreatingDelegate\");\n                    //         DelegateRole::MintDgt\n                    //     },\n\n                    //     queuePendingChange => DelegateRole::BothMintAndSpendDgt\n                    //     // we want explicit handling of each case; don't use a default match here.\n                    //     // _ => error(\"DO NOT CATCH DEFAULT CASE HERE\")\n                    // };\n                    // wantsRole.switch {\n                    neededRole = cctx.dgtRolesForLifecycleActivity(dCLA);\n                    myCurrentRole : DelegateRole = neededRole.switch {\n                        HandledByCapoOnly => {\n                            error(\"delegate invoked with invalid escape-hatch activity (always handled directly by the Capo)\")\n                        },\n                        SpendDgt => {\n                            REQT(\n                                \"... this Capo lifecycle activity is only valid on spend delegate\",\n                                isSpendDelegate \n                            );\n                            assert(cctx.nowActingAsSpendDgt(), \"<----- that can fail, this can't\");                            \n                            print(\"  -- ok: spendDgt checking CapoLifecycleActivity\");\n                            neededRole\n                        },\n                        MintDgt => {\n                            REQT(\n                                \"... this Capo lifecycle activity is only valid on mint delegate\",\n                                isMintDelegate\n                            );\n                            assert(cctx.nowActingAsMintDgt(), \"<----- that can fail, this can't\");\n                            print(\"  -- ok: mintDgt checking CapoLifecycleActivity\");\n                            neededRole\n                        },\n                        BothMintAndSpendDgt => {\n                            REQT(\"It EXPECTS the Capo to enforce the presence of the mintDgt (to check the right mint) and spendDgt (to validate the charter-update logic)\");\n                            // REQT(\"  ... it needs the mintDgt to check mints & burns\");// the new dgTkn creation\");\n                            // REQT(\"  ... it uses the spendDgt to verify the correct charterData update\");\n                            if (cctx.nowActingAsMintDgt(required:false)) {\n                                DelegateRole::MintDgt\n                            } else if (cctx.nowActingAsSpendDgt(required:false)) {\n                                DelegateRole::SpendDgt\n                            } else {\n                                error(\"this Capo lifecycle activity is only valid on mint/spend delegate, not \"+ delegateName)\n                            }\n                        },\n                        _ => error(\"no way k\") // unreachable\n                    };\n\n\n                    dCLA.switch {\n                        // the mint delegate is validating a mint that CREATES A NEW DELEGATE\n                        // FOR APPLICATION-SPECIFIC PURPOSES. This can affect the structure of the Capo\n                        // it defers to the specialized minting delegate, if any; the unspecialized mint delegate\n                        // rejects all delegate-creation.\n                        CreatingDelegate{seed, purpose} => {\n                            // print(\"ðŸžðŸžðŸžðŸžðŸžðŸžðŸžðŸžðŸžðŸžðŸžðŸž !!!!!!!!!!!!!!!!!!! todo: fix this\\n\");\n                            // assert(false, \"obsolete CLA::CreatingDelegate?\");\n                            TODO(\"XXX it should output the new delegate token to the Capo as a PendingDelegate datum\");\n                            REQT(\"... here in the MintDgt: validates creation of UUT for the new delegate, aligned to the purpose indicated\");\n\n                            mkTn = mkUutTnFactory(seed);\n                            myCurrentRole.switch {\n                                MintDgt => {\n                                    REQT(\n                                        \"validates the new delegate's UUT is minted\"\n                                    );\n                                    if (validateUutMinting(\n                                        mph: dd.mph,\n                                        seed: seed,\n                                        purposes: []String{purpose},\n                                        // otherMintedValue: ()\n                                        mkTokenName: mkTn,\n                                        // WE ARE the mint delegate.\n                                        needsMintDelegateApproval: false \n                                    )) {\n                                        print(\"  -- ok, minted the new delegate's UUT\\n\") \n                                    };\n                                    REQT(\n                                        \"the UUT must have the right disposition (is it checked somewhere else?!?)\"\n                                    );\n                                    cctx.getNextCharterData().otherNamedDelegates.get_safe(purpose).switch {\n                                        None => error(\"the new delegate is not present in the Capo's named-delegates list\"),\n                                        Some{dgtLink} => {\n                                            assert(dgtLink.uutName == mkTn(purpose), \"uutName mismatch\");\n\n                                            dgtLink.hasValidOutput(\n                                                mph: dd.mph, \n                                                required: true,\n                                                createdOrReturned: DgTkn::Created\n                                            )\n                                        }\n                                    }\n                                },\n                                _ => error(\"unreachable wrong role for CreatingDelegate\")\n                            }\n                        },\n\n                        queuePendingChange => {\n                            REQT(\"... for the addingPendingDgt activity:\");\n\n                            charterData : CapoDatum::CharterData = cctx.getCharterData();\n\n                            REQT(\"The new pending-delegate action is found at the head of the new change-list\");\n                            oldPendingChanges = charterData.pendingChanges;\n                            nextCharterData = cctx.getNextCharterData();\n                            nextChangeList = nextCharterData.pendingChanges;\n                            newChange = nextChangeList.head;\n\n                            TODO(\"support otherManifestChange here\");\n                            PendingCharterChange::delegateChange{\n                                PendingDelegateChange{\n                                    action, // PendingDelegateAction\n                                    role, // : DelegateRole\n                                    OdgtLink //: Option[RelativeDelegateLink]\n                                }\n                            } = newChange;\n                            newDgtRoleName = role.switch {\n                                DgDataPolicy{dgtName} => dgtName,\n                                _ => error(\"only DgDataPolicy is yet supported in queuePendingChange\")\n                            };\n\n                            action.switch {\n                                Remove => {\n                                    print(\"   -- another delegate-role check would be redundant.\");\n\n                                    myCurrentRole.switch {\n                                        SpendDgt => {\n                                            REQT(\"verifies that the delegate queued for removal is present in the Capo's charterData\");\n                                            error(\"implement me\")\n                                        },\n                                        _ => error(\"unreachable\")\n                                    }\n                                }, \n                                _ => assert(true, \"no way l\")\n\n                            };\n\n\n\n                            REQT(\"the remainder of the change-list should be unchanged\");\n                            assert(\n                                nextChangeList.tail == oldPendingChanges, \n                                \"invalid update of pendingChanges; the new action must be prepended to the existing list.\"\n                            );\n                            (\n                                seed: TxOutputId, \n                                purpose: String,\n                                pendingActionIdPrefix: String\n                                // uutName: String, \n                                // dvh : Option[ValidatorHash], \n                                // config : ByteArray\n                            ) = action.switch { \n                                Remove => error(\"unreachable\"), \n                                Add{seed, purpose, idPrefix} => {\n                                    (seed, purpose, idPrefix) \n                                },\n                                Replace{seed, purpose, idPrefix, _replacesDgt } => { \n                                    (seed, purpose, idPrefix ) \n                                }\n                            };\n\n                            possibleMintDgtVerifications : Bool = myCurrentRole.switch {\n                                SpendDgt => /* no-op */ true,\n                                MintDgt => bREQT(\n                                    \"(general) the mintDgt checks everything about the mint\"\n                                ) && action.switch {\n                                    Remove => {\n                                        role.switch {\n                                            MintDgt => error(\"cannot Remove role: MintDgt\"),\n                                            SpendDgt => error(\"cannot Remove role: SpendDgt\"),\n                                            MintInvariant => error(\"cannot Remove role: MintInvariant\"),\n                                            SpendInvariant => error(\"cannot Remove role: SpendInvariant\"),\n                                            DgDataPolicy => {\n                                                assert(false, \"todo\")\n                                            },\n                                            OtherNamedDgt => {\n                                                assert(false, \"todo\")\n                                            },\n                                            BothMintAndSpendDgt => error(\n                                                \"DelegateRole::BothMintAndSpend not applicable in queuePendingChange activity\"\n                                            )\n                                        };\n                                        REQT(\"doesn't allow a Remove to duplicate an Add or Replace or Remove entry\");\n                                        TODO(\"^^^\");\n\n                                        assert(false, \"what else should be checked here?\");\n                                        false\n                                    },\n                                    _ => { // Replace or Add\n                                        if(false/*redundant*/) { assert(cctx.nowActingAsMintDgt(), \"<----- that can fail, this can't\") };\n\n                                        mkTokenName = mkUutTnFactory(seed);\n                                        dgTknName = mkTokenName(purpose);\n                        \n                                        mintedDgTkn = bREQT(\"the new delegate is created with the indicated authority token\")\n                                        && validateUutMinting(\n                                            mph: dd.mph,\n                                            seed: seed,\n                                            // \"dgtPol\", until/unless we get fancy like \"settingsPol\", \"reqtsPol\", \"mktSalePol\", etc:\n                                            purposes: []String{purpose}, \n                                            // otherMintedValue: ()\n                                            mkTokenName: mkUutTnFactory(seed),\n                                            // WE ARE the mint delegate.\n                                            needsMintDelegateApproval: false \n                                        );\n                                        \n                                        REQT(\"The new policy-token must match the seed\");\n                                        dgtLink = OdgtLink.switch {\n                                            None => error(\"missing required delegate link in pending dgt change\"),\n                                            Some{dl} => dl\n                                        };\n                                        assert(\n                                            dgtLink.uutName == dgTknName,\n                                            \"uutName mismatch; expected \"+dgTknName+\" but found \"+dgtLink.uutName\n                                        );\n\n                                        delegateTakesOwnership = bREQT(\"the new policy-delegate-script must take ownership of the dgTkn\",\n                                            dgtLink.hasValidOutput(\n                                                mph: dd.mph, \n                                                required: true,\n                                                createdOrReturned: DgTkn::Created\n                                        ));\n\n                                        possibleExtraReplacementCheck = action.switch {\n                                            Replace => {\n                                                REQT(\"Replace: the queued change must match the idPrefix of the current delegate \");\n                                                TODO(\"VALIDATE this through a unit-test ^\");\n                                                charterData.manifest.get_safe(newDgtRoleName).switch {\n                                                    Some{dde} => {\n                                                        CapoManifestEntry{entryType, _tn, _mph} = dde;\n                                                        entryType.switch {\n                                                            DgDataPolicy{_polLink, idPrefix, _refCount} => {\n                                                                REQT(\"expects the queued idPrefix to match the existing policy's idPrefix\");\n                                                                print(\"   -- expected: \" + idPrefix);\n                                                                print(\"   --   actual: \"+pendingActionIdPrefix);\n                                                                assert(\n                                                                    idPrefix == pendingActionIdPrefix,\n                                                                    \"idPrefix mismatch\"\n                                                                )\n                                                            },\n                                                            _ => error(\"invalid Replace; the matching manifest entry for '\"+newDgtRoleName+\"' isn't a DgDataPolicy.\")\n                                                        }\n                                                    },\n                                                    None => error(\"no existing dgDataPolicy found with key: \"+newDgtRoleName)\n                                                };\n                                                true\n                                            },\n                                            _ => true\n                                        };\n                                        mintedDgTkn && delegateTakesOwnership && possibleExtraReplacementCheck\n                                    }\n                                },\n                                _ => error(\"unreachable\") // other DelegateRoles \n                            }; // -> possibleMintDgtVerifications\n\n                            otherPossibleVerifications : Bool = myCurrentRole.switch { \n                                SpendDgt => /* no-op */ error(\n                                    \"this block had been run by spendDgt, but\\n\"+\n                                    \"... it's much cheaper to let the MintDgt do it ...\\n\"+\n                                    \"... since it's already involved anyway\"\n                                ),\n                                MintDgt => {\n                                    // REQT(\"(general) the spendDgt checks everything about the charterData update\");\n\n                                    REQT(\"doesn't allow a queued change to duplicate any other pending entry for the same delegate name\");\n                                    isNotADuplicate = charterData.pendingChanges.all( \n                                        (pdChange: PendingCharterChange) -> Bool {\n                                            pdChange.switch {\n                                                delegateChange{\n                                                    PendingDelegateChange{_pendingAction, pendingRole, _odgtLink}\n                                                } => {\n                                                    pendingRole.switch {\n                                                        DgDataPolicy{changingDgtName} => {\n                                                            changingDgtName != newDgtRoleName\n                                                        },\n                                                        _ => error(\"only DgDataPolicy is yet supported in queuePendingChange\")\n                                                    }\n                                                },\n                                                _ => error(\"otherManifestChange not yet supported\")\n                                            }\n                                    });\n                                    assert(isNotADuplicate, \"already has a pending change for this delegate: \"+newDgtRoleName);\n\n                                    existingRoleEntryMaybe : Option[CapoManifestEntry] = charterData.manifest.get_safe(newDgtRoleName);\n                                    possibleReplacementIsCorrect: Bool = action.switch {\n                                        Add => {\n                                            REQT(\"doesn't allow an Add for an existing policy name\");\n                                            existingRoleEntryMaybe.switch {\n                                                Some =>  error(\n                                                    \"queuing Add failed: already has a delegate for policy name: \"+ \n                                                    newDgtRoleName\n                                                )\n                                            };\n\n                                            true\n                                        },\n                                        Replace{_seed, _purpose, _idPrefix, replacesDgt} => {\n                                            REQT(\"For Replace on an existing delegate... \");\n\n                                            REQT(\"  -- Replace: invariants cannot be replaced\");\n                                            role.switch {\n                                                MintInvariant => error(\"cannot Replace role: MintInvariant\"),\n                                                SpendInvariant => error(\"cannot Replace role: SpendInvariant\"),\n                                                HandledByCapoOnly => error(\"HandledByCapoOnly role is not applicable in delegate context\"),\n                                                _ => print(\"  -- ok (not trying to replace an invariant)\")\n                                            };\n    \n                                            REQT(\"  -- doesn't allow a Replace if the policy-name doesn't already exist\");\n\n                                            existingDgtLink : RelativeDelegateLink = existingRoleEntryMaybe.switch {\n                                                None => error(\"queuing Replace failed: the policy-name doesn't exist: \"+ \n                                                    newDgtRoleName\n                                                ),\n                                                Some{CapoManifestEntry{entryType, _tn, _mph}} => {\n                                                    entryType.switch {\n                                                        DgDataPolicy{existingDgtLink, _idp, _refCount} => existingDgtLink,\n                                                        _ => error(\"invalid Replace; the matching manifest entry for '\"+newDgtRoleName+\"' isn't a DgDataPolicy.\")\n                                                    }\n                                                }\n                                            };\n                                            // RelativeDelegateLink{existingUutName, _dvh, _cfg} = existingDgtLink;\n\n                                            REQT(\"  -- Replace: the PendingDelegateAction's role + replacesDgt must match the existing delegate's authority token\");\n                                            existingDgTkn : Option[AssetClass] = role.switch {\n                                                MintDgt => Option[AssetClass]::Some{\n                                                    charterData.mintDelegateLink.acAuthorityToken(dd.mph)\n                                                },\n                                                SpendDgt => Option[AssetClass]::Some{\n                                                    charterData.spendDelegateLink.acAuthorityToken(dd.mph)\n                                                },                                                \n                                                DgDataPolicy{_policyName} /* DelegateRole::DgDataPolicy */ => {\n                                                    REQT(\"  -- Replace: dgDataPolicy: the named policy must be present in the Capo manifest\");\n\n                                                    Option[AssetClass]::Some{\n                                                        existingDgtLink.acAuthorityToken(dd.mph)\n                                                    }\n                                                },\n                                                OtherNamedDgt => {\n                                                    error(\"unreachable: OtherNamedDgt deprecated\")\n                                                    // REQT(\"  -- Replace: OtherNamedDgt: the named delegate must already be present\");\n                                                    // error(\"todo: get authority-token for this named delegate\")\n                                                },\n                                                BothMintAndSpendDgt => error(\n                                                    \"DelegateRole::BothMintAndSpend not applicable in queuePendingChange activity\"\n                                                ),\n                                                MintInvariant => error(\"unreachable\"),\n                                                SpendInvariant => error(\"unreachable\"),\n                                                HandledByCapoOnly => error(\"unreachable\")\n                                            };\n                                            assert(\n                                                replacesDgt == existingDgTkn.unwrap(),\n                                                \"the current \"+role.switch{\n                                                    MintDgt => \"mint\", SpendDgt => \"spend\", \n                                                    DgDataPolicy => \"dgDataPolicy\", OtherNamedDgt => \"named\",\n                                                    _ => \"â€¹incontheeiieivableâ€º\"\n                                                }+\" delegate's authority token doesn't match the queued action's token name \"+replacesDgt.show()\n                                            );\n\n                                            true    \n                                        },\n                                        Remove => {\n                                            REQT(\"doesn't allow a Remove if the policy-name doesn't already exist\");\n                                            existingRoleEntryMaybe.switch {\n                                                None => error(\n                                                    \"queuing Remove failed: the policy-name doesn't exist: \"+ \n                                                    newDgtRoleName\n                                                )\n                                            };\n                                            error(\"unreachable: Remove not yet supported\")\n                                        }\n                                    }; // -> possibleReplacementIsCorrect\n\n                                    true\n                                    && isNotADuplicate \n                                    && possibleReplacementIsCorrect\n                                }, \n                                _ => error(\"unreachable\") // other DelegateRoles \n                            }; // -> possibleSpendDgtVerifications\n                        \n                            REQT(\"TEMPORARY: only one pending change is allowed\");\n                            assert(oldPendingChanges.length == 0, \"only one pending change is allowed for now (avoids resource-exhaustion)\");\n\n                            true\n                            && possibleMintDgtVerifications \n                            && otherPossibleVerifications\n                        },\n                        removePendingChange{_role} => {\n                            // this code-path is only found in the spend-delegate\n                            TODO(\"implement removePendDgt\");\n                            REQT(\"allows the removal of a queued pending-delegate-change that can't be completed\");\n                            assert(false, \"not yet implemented\");\n                            false\n                        },\n                        commitPendingChanges => {\n                            REQT(\"... To commit pending changes:\");\n                            // this code-path has one leg in the spend-delegate\n                            // and one leg in the mint-delegate\n                            REQT(\"invariants cannot be replaced\");\n                            pendingChangesList : []PendingCharterChange = cctx.getCharterData().pendingChanges;\n                            previousManifest : Map[String]CapoManifestEntry = cctx.getCharterData().manifest;\n                            nextCharterData = cctx.getNextCharterData();\n                            nextManifest : Map[String]CapoManifestEntry = nextCharterData.manifest;\n\n                            assert(\n                                bREQT(\"the next-changes list must be empty\") &&\n                                nextCharterData.pendingChanges.length == 0,\n                                \"pendingChanges must be emptied\"\n                            );\n\n                            spendDgtCheck: Bool = if (!isSpendDelegate) {\n                                true\n                            } else {\n                                if (!cctx.nowActingAsSpendDgt(required: false)) {\n                                    true\n                                } else {\n                                    REQT(\"...spendDgt: validates that all the pending delegates are installed\");\n                                    // the pending changes are moved into the nextManifest\n\n                                    // walks through the pending changes and next-manifest entries\n                                    // ... and also holds a temporary picture of previous-manifest entries.\n                                    //  - verifies that each next change is reflected in the next-manifest's next entry\n                                    //  - verifies at the end that the remainder of the next-manifest-tail (after verifying changes added in its \"head\" section) \n                                    //    ... contains all the entries expected (from the previous-manifest-remainder,\n                                    //    ...   == previous-manifest, when no Remove/Replace actions are present);\n                                    //  - verifies that any Removed entries are missing from the next-manifest-map\n                                    //    ... while removing them from the previous-manifest-remainder's \"expected remaining entries\"\n                                    //  - verifies any Replaced entries have been added at the next-manifest's next entry\n                                    //    ... AND that they're removed from the remainder of the next-manifest-map,\n                                    //    ... while removing them from the \"expected remaining entries\" in the previous-manifest-remainder.\n                                    // At the end, it verifies that the two remaining partial-maps are identical.\n                                    (\n                                        prevManifestRemainder, nextManifestRemainder: Map[String]CapoManifestEntry\n                                    ) = pendingChangesList.fold2[ Map[String]CapoManifestEntry, Map[String]CapoManifestEntry ]( \n                                        (\n                                            prevManifestRemainder : Map[String]CapoManifestEntry, \n                                            nextCMEs: Map[String]CapoManifestEntry, \n                                            pcChange: PendingCharterChange\n                                        ) -> ( Map[String]CapoManifestEntry, Map[String]CapoManifestEntry ) {\n                                            pdChange : PendingDelegateChange = pcChange.switch {\n                                                delegateChange{dgtChange} => dgtChange,\n                                                otherManifestChange => error(\"otherManifestChange not yet supported\")\n                                            };\n                                            pendingTypeName = pdChange.role.switch {\n                                                DgDataPolicy{typeName} => {\n                                                    print(\"  -- ok: DgDataPolicy in commitPendingChanges\");\n                                                    typeName\n                                                },\n                                                _ => error(\"invalid delegate-change role (for now) in commitPendingChanges\")\n                                            };\n                                            //void\n                                            pdChange.action.switch {\n                                                Remove => {\n                                                    REQT(\"  -- Remove: verifies that the delegate queued for removal is now removed from the Capo manifest\");\n                                                    nextCMEs.get_safe(pendingTypeName).switch { \n                                                        Some => error(\n                                                            \"queued Remove failed: name still present in next-manifest item: \"+ \n                                                            pendingTypeName\n                                                        )\n                                                    }\n                                                },\n                                                _ => {\n                                                    REQT(\"   -- verifies that added & replaced entries are present in the updated map (at its next position)\");\n                                                    if (nextCMEs.length == 0) {\n                                                        error(\"queued Add/Replace failed: no more items in next-manifest map\")\n                                                    };\n                                                    ( CME_key : String, CapoManifestEntry{ME_type, _tn, _mph} ) = nextCMEs.head;\n                                                    print(\"vv @CME entry: \"+CME_key);\n                                                    ManifestEntryType::DgDataPolicy{ME_policyLink, ME_idPrefix, refCount} = ME_type;\n                                                    TODO(\"support minting multiple threads of a dgDataPolicy\");\n                                                    assert(refCount == 1, \"refCount must be 1 when adding a new dgDataPolicy\");\n                                                    assert(pendingTypeName == CME_key,\n                                                        \"queued change: name mismatch with next-manifest item\"\n                                                    );\n                                                    ME_name = ME_policyLink.uutName.show()\n                                                    print(\"    -- ME policy link \" + ME_name);\n                                                    pendingLink = pdChange.dgtLink.unwrap();\n                                                    pendingName = pendingLink.uutName.show()\n                                                    print(\"    -- pdChange policy link \" + pendingName);\n\n                                                    assert(ME_policyLink == pendingLink,\n                                                        \"queued change: policyLink mismatch with next-manifest item\"\n                                                    );\n\n                                                    nextIdPrefix = pdChange.action.switch {\n                                                        Replace{_,_,idPrefix,_} => {\n                                                            REQT(\"    -- Replace: verifies that the next-manifest no longer has the replaced entry\");\n\n                                                            nextCMEs.tail.get_safe(pendingTypeName).switch {\n                                                                Some => error(\n                                                                    \"queued Replace failed: duplicate name remaining in next-manifest map: \"+ \n                                                                    pendingTypeName\n                                                                )\n                                                            };\n                                                            idPrefix\n                                                        },\n                                                        Add{_,_,idPrefix} => idPrefix,\n                                                        _ => error( \"unreachable\")\n                                                    };\n                                                    REQT(\"    -- @each manifest entry: next-manifest's idPrefix must match the queued change\");\n                                                    assert(nextIdPrefix == ME_idPrefix,\n                                                        \"idPrefix mismatch with next-manifest's dgDataPolicy\"\n                                                    )\n                                                }\n                                            }; // void assertions; all needed checks are done ^^^^\n\n                                            // traverses to next state for the reducer:\n                                            pdChange.action.switch {\n                                                Add => {\n                                                    ( prevManifestRemainder, nextCMEs.tail )\n                                                },\n                                                _ => { // Remove, Replace => {\n                                                    ( prevManifestRemainder.delete(pendingTypeName), nextCMEs.tail )\n                                                }\n                                            }\n                                        }, // reducer\n                                        previousManifest, // init1\n                                        nextManifest // init2\n                                    );\n                                    nextManifestRemainder == prevManifestRemainder\n                                } // spendDgt\n                            };\n\n                            mintDgtCheck = if (!isMintDelegate) {\n                                true\n                            } else if (!cctx.nowActingAsMintDgt(required: false)) {\n                                true\n                            } else {\n                                REQT(\"... mintDgt: validates that all the removed dgTkns are burned\");\n                                \n                                REQT(\"the txn must have all the expected burns\");\n                                mint = tx.minted.to_map();\n                                mintThisPolicy = mint.get_safe(dd.mph);\n                                len = mint.length - 1; // ignores the \"0 ada minted\" that's always present\n                                if ( len > 1) {\n                                    print(tx.minted.show());\n                                    error(\"currently supporting only one minting policy being burned in the tx \" + len.show())\n                                };\n                                observedTokenBurn = mintThisPolicy.switch {\n                                    Some{minted} => minted,\n                                    None => Map[ByteArray]Int{} // no burns expected\n                                };\n\n                                remainingMint: Map[ByteArray]Int = pendingChangesList.fold[ Map[ByteArray]Int ]( \n                                    (foldingBurn: Map[ByteArray]Int, pcChange: PendingCharterChange) -> Map[ByteArray]Int {\n                                        REQT(\"EXPECTS the spendDgt to check details of Replace activities\");\n                                        // ignores the dgtLink details if present in a Replace activity\n                                        pdChange : PendingDelegateChange = pcChange.switch {\n                                            delegateChange{dgtChange} => dgtChange,\n                                            otherManifestChange => error(\"otherManifestChange not yet supported\")\n                                        };\n                                        pdChange.role.switch {\n                                            DgDataPolicy{typeName} => {\n                                                print(\"  -- ok: DgDataPolicy in commitPendingChanges: \"+typeName);\n                                                pdChange.action.switch {\n                                                    Add => {\n                                                        // doesn't accumulate any expected mints or burns for Add \n                                                        // (the mint happens in a previous transaction while queueing the change\n                                                        foldingBurn\n                                                    },\n                                                    _ => { // Replace, Remove => {\n                                                        REQT(\"verifies that a delegate queued for removal or replacement is burned\");\n                                                        previousManifest.get_safe(typeName).switch {\n                                                            None => error(\"queued Remove failed: not present in previous-manifest map: \"+ typeName),\n                                                            Some{CapoManifestEntry{ME_type, tn, mph}} => {\n                                                                mph.switch {\n                                                                    Some => {\n                                                                        print( \"    -- TODO: manifest entry with other-mph: allow optional burn\");\n                                                                        // doesn't accumulate any additional expected burns\n                                                                        foldingBurn\n                                                                    },\n                                                                    _ => {\n                                                                        REQT(\"each pending change must have a name recognized by the manifest\");\n                                                                        ManifestEntryType::DgDataPolicy{_ME_policyLink, _ME_recPrefix, refCount} = ME_type;\n                                                                        tnStr = tn.decode_utf8_safe();\n                                                                        foldingBurn.get_safe(tn).switch {\n                                                                            None => error(\"queued Remove/Replace failed: no burn, or double-burn: \"+ tnStr),\n                                                                            Some{burningCount} => {\n                                                                                print(\"    -- ok: BURN ðŸ”¥\"+ burningCount.show() + \"Ã—ðŸ’´ \"+ tnStr);\n                                                                                if (0 - refCount != burningCount) { // negative = burning\n                                                                                    error(\"queued Remove/Replace failed: expected burn of \" + \n                                                                                        refCount.show() + \"Ã—ðŸ’´ \"+ tnStr\n                                                                                    )\n                                                                                };\n                                                                                foldingBurn.delete(tn)\n                                                                            } // burningCount\n                                                                        } // check burn quantity\n                                                                    }\n                                                                } // mph\n                                                            }\n                                                        }\n                                                    } // Remove/Replace\n                                                } // action\n                                            }, // DgDataPolicy\n                                            _ => error(\"invalid delegate-change role (for now) in commitPendingChanges\")\n                                        } // role\n                                    },  // reducer\n                                    observedTokenBurn // initial value for 'foldingBurn'\n                                );\n\n                                REQT(\"requires all the burns of our policy-id to be accounted for\");\n                                assert(remainingMint.length == 0, \n                                    \"extra burns found in the transaction: \\n\"+remainingMint.show());\n                                REQT(\"... -- end of commitPendingChanges\");\n                                true\n                            }; /* mintDgt */ \n\n                            if(!isMintDelegate && !isSpendDelegate) {\n                                error(\"unreachable? not mintDgt or spendDgt\")\n                            };\n\n                            mintDgtCheck && spendDgtCheck\n                        }, // commitPendingChanges\n\n                        updatingManifest{manifestActivity} => {\n                            REQT(\"doesn't allow updating anything except the manifest\");\n                            manifestActivity.switch{\n                                retiringEntry{_key} => {\n                                    assert(false, \"TODO: support retirement activity\");\n                                    REQT(\"doesn't remove a dgDataPolicy entry from the manifest (use queuePendingChange instead)\");\n                                    REQT(\"removes the indicated key from the manifest\");\n                                    REQT(\"delegates MUST be allowed to validate that this doesn't drop something they need\")\n                                },\n                                updatingEntry{_key, _tokenName} => {\n                                    TODO(\"if delegates need a hook to validate that the updte is acceptable, that might be enforced here\");\n                                    assert(false, \"TODO: support updatingEntry activity\");\n                                    REQT(\"the indicated token MUST be referenced in the transaction\")\n                                },\n                                addingEntry{key, tokenName} => {\n                                    charterData : CapoDatum::CharterData = cctx.getCharterData();\n                                    nextCharterData = cctx.getNextCharterData();\n                                    REQT(\"the indicated token MUST be referenced in the transaction\");\n                                    refInput = cctx.delegatedDataRef(recIdBytes: tokenName);\n                                    assert(\n                                        (refInput == refInput).trace(\n                                            \"  -- found refInput: \"+tokenName.decode_utf8_safe()+\"?\"\n                                        ), \n                                        \"refInput must be found\"\n                                    );\n\n                                    REQT(\"the new entry MUST be found in the new manifest\");\n                                    nextCharterData.manifest.get_safe(key).switch {\n                                        None => error(\"the new manifest entry is missing: \"+key),\n                                        Some{CapoManifestEntry{entryType, tn, mph}} => {\n                                            print(\"   -- ok, found the manifest entry for \"+ key);\n                                            REQT(\"the new entry must have the right token-name\");\n                                            assert(tn == tokenName, \"token-name mismatch\");\n                                            mph.switch { Some => error(\"other-mph not yet supported\") };\n                                            entryType.switch {\n                                                NamedTokenRef => print(\"   -- ok: matching name, with NamedTokenRef added in updatingManifest\"),\n                                                _ => error(\"addingEntry: the new manifest entry must be a NamedTokenRef for now\")                                                \n                                            }\n                                        }\n                                    };\n                                    REQT(\"the remainder of the manifest must be unchanged\");\n                                    // NOTE if you're troubleshooting a txn-building functoin, that the order \n                                    //   of elements is significant.\n                                    assert(charterData.manifest == nextCharterData.manifest.delete(key),\n                                        \"manifest modified in an unexpected way\"\n                                    );\n                                    print(\"  -- ok! new manifest as expected\")\n                                },\n                                forkingThreadToken{_key, _newThreadCount} => {\n                                    assert(cctx.nowActingAsMintDgt(), \"<----- that can fail, this can't\");\n                                    assert(false, \"TODO: support forkingThreadToken activity\");\n                                    REQT(\"the indicated token MUST be referenced in the transaction\");\n                                    REQT(\"validates that another copy of the token name is minted\");\n                                    REQT(\"when the key is a DgDataPolicy, the existing manifest entry is updated\");\n                                    REQT(\"for mint/spend delegates and otherNamedDelegates, a new manifest entry is created with refCount=1+newThreadCount, if it doesn't exist\");\n                                    REQT(\"when the manifest already has the entry, the refCount is incremented by newThreadCount\")\n\n                                }\n                            }; // void assertions;\n                            true\n                        },\n                        forcingNewMintDelegate => {\n                            REQT(\"a forced delegate change is an escape-hatch only involving the minter and the Capo\");\n                            error(\"the mint/spend delegate never is involved when the minter is instructed to force a new delegate\")\n                        },\n                        forcingNewSpendDelegate => {\n                            REQT(\"a forced delegate change is an escape-hatch only involving the minter and the Capo\");\n                            error(\"the mint/spend delegate never is involved when the spender is instructed to force a new delegate\")\n                        }\n                    } && if (true) { \n                        print(\"BasicDelegate harness deferring to specialization for CapoLifecycleActivities\\n\");\n                        true\n                    } else { false }\n                },\n\n                // NOTE: this is a mint delegate activity on the mintDgt-* token,\n                // ... used only in a Capo's MINT delegate.  Once the specialized mint delegate includes\n                // ... the delegated-data controller's UUT through the re-delegation pattern,\n                // ... the delegated-data controller  picks up the thread of enforcement, via Its specialized \n                // ... delegate module's additionalDelegateValidation(), by handling the \n                // ... MintingActivities variant indicated in the *Ctrl-* token's activity/redeemer.  \n                // It can be tricky to recognize that this code module serves the mint delegate, \n                // ... and that it ALSO serves the data-controller delegate separately, in that completely different\n                // ... context and using its separate specialization module.\n                // In each of those cases, it follows the same high-level logic, hitting different paths through this file, \n                // ... while processing different tokens for each zone of authority/responsibility.\n                CreatingDelegatedData{seed, dDataTypeName} => if (!isMintDelegate) {\n                    error(\"CreatingDelegatedData activity is only allowed in the mint delegate\")\n                } else {\n                    cctx : CapoCtx = baseCctx.withCharterRef();\n                    assert(cctx.nowActingAsMintDgt(), \"<---- fails in there, not here\");\n                    REQT(\"context: CreatingDelegatedData\");\n\n                    REQT(\"  -- ensures the data-controller is invoked with its minting activity for the indicated recId\");\n                    policyDelegateInput = cctx.\n                        requiresDgDataPolicyInput(dDataTypeName);\n\n                    tnFactory : (String) -> String = mkUutTnFactory(seed);\n                    purpose = policyDelegateInput.idPrefix.unwrap();\n                    newDataId : ByteArray = tnFactory( purpose ).encode_utf8();\n                    // as a mint delegate, we should see to it that any minting does play by the rules\n                    //   ... however, this module is generic, so we can only perform generic checks here.\n                    //   ... we additionally call application-provided validation (provided by a specialization)\n                    //       (we haven't fully implemented generic data-controller registration, so that's a key limitation for now)\n                    // xxx WE are the mint delegate : ) -  cctx.requiresMintDelegateInput().requiresValidOutput() \n                    // this needs to be done by the speciization for now\n                    // && cctx.requiresDelegatedDataController(dDataTypeName).requiresDataMinting()                    \n\n                    // dgDataPolicy = cctx.findManifestEntry(dDataTypeName).switch {\n                    //     None => error(\n                    //         \"can't create delegatedData without a matching '\"+\n                    //         dDataTypeName+\"' dgDataPolicy entry in the capo manifest\"),\n                    //     Some{mEntry} => {\n                    //         mEntry.entryType.switch {\n                    //             DgDataPolicy{policyLink, _refCount} => policyLink,\n                    //             _ => error(\n                    //                 \"can't create delegatedData type '\"+\n                    //                 dDataTypeName+\n                    //                 \"'; its Capo manifest entry is not a DgDataPolicy\"\n                    //             )\n                    //         }\n                    //     }\n                    // };\n\n                    true\n                    && validateUutMinting(\n                        mph: dd.mph,\n                        seed: seed,\n                        purposes: []String{purpose},\n                        // otherMintedValue: ()\n                        mkTokenName: tnFactory,\n                        // WE ARE the mint delegate.\n                        needsMintDelegateApproval: false \n                    // ).trace(\n                    //     \" âœ… checked basic UUT minting \"\n                    )\n                    && bREQT(\"it outputs the new delegated-data record to the Capo address\")\n                    && cctx.mustOutputDelegatedData(\n                        newDataId, dDataTypeName\n                    )\n                    && bREQT(\"ensures the data-controller is invoked with ONE minting activity for the indicated recId\")\n                    && policyDelegateInput.\n                        withUniqueSeededMintingActivity(seed).\n                        orFail()\n\n                    // assert(false, \"^^^ does it implement the generic data-controller re-delegation convention? ^^\");\n                },\n                // This is a Spend delegate activity on the spendDgt-* token, \n                // ... used within a Capo's SPEND delegate (which code may also govern \n                // ... its mintDgt- token, under separate utxo cover).\n                // Once the specialized spend delegate includes the delegated-data controller UUT through the re-delegation pattern,\n                // ... the spend delegate's specialized module picks up the thread of enforcement via its\n                // ... additionalDelegateValidation(), by handling the SpendingActivities variant indicated in the *Pol-* token's activity/redeemer.\n                // That controller activity may alternatively be a MultiActivity, one of whose nested activities provides \n                // ... the needed SpendingActivities variant.\n                // It can be tricky to recognize that this code module serves the spend delegate and the mint delegate,\n                // ... and that it ALSO serves the data-controller delegate separately, in that completely different context \n                // ... and using its separate specialization module.\n                // In each of those cases, it follows the same high-level logic, hitting different paths through this file, \n                // ... while processing different tokens for each zone of authority/responsibility.\n                UpdatingDelegatedData{dDataTypeName, recId} => if (!isSpendDelegate) {\n                    error(\"UpdatingDelegatedData activity is only allowed in the spend delegate\")\n                } else {\n                    cctx : CapoCtx = baseCctx.withCharterRef();\n                    assert(cctx.nowActingAsSpendDgt(), \"<---- fails in there, not here\");\n                    REQT(\"EXPECTS j6bmfv: all and ONLY DelegatedData datums must be spent with the Capo's spendingDelegatedData activity\");\n\n                    REQT(\"implements a generic data-controller re-delegation convention based on the capo's manifest (those with type= DgDataPolicy)\");\n\n                    REQT(\"ensures the data-controller is invoked with ONE spending activity for the indicated recId\");\n                    assert( cctx.\n                        requiresDgDataPolicyInput(dDataTypeName).\n                        withUniqueDDSpendingActivity(recId).\n                        orFail(),\n                         \"^^^ those can fail, this assert won't.\"\n                    );\n\n                    inputDD : TxInput = cctx.delegatedDataTxInput(recIdBytes: recId);\n                    assert(inputDD == inputDD, \"no way m\");\n                    // ^^ same as vv\n                    // hasDDofType : (TxInput) -> Bool = cctx.mkDelegatedDataPredicate(dDataTypeName);\n                    // simply finding the input is enough to imply that the that those utxos are spend-governed by the Capo \n                    // ... which at j6bmfv, explicitly requires the token that leads to this code path\n                    // ddInputs : []TxInput = ctx.tx.inputs.filter(hasDDofType);\n                    // assert(ddInputs.length == 1, \"extra DD input(s)\");\n\n\n                    if (\"settings\" == dDataTypeName) {\n                        curSettingsId = cctx.getSettingsId(required: true).unwrap();\n                        TODO(\n                            \"when updating the current Capo settings, the delegates must all \"+\n                            \"have a chance to ensure the settings are valid for their needs\"\n\n                            // NOTE that requiring all policies to validate the settings update\n                            // in a single transaction carries a risk of requiring a transaction that\n                            // will be over-limit in some dimension.  To address this, the data structure\n                            // for a pending update should be able to include a list of policies that\n                            // haven't yet validated the settings; each one can validate and remove itself\n                            // from the list; then, the commit can happen when the list becomes empty.\n\n                            // ... as a special case, a single transaction that commits the changes AND\n                            // involves all the remaining policies from the list doing the validation can\n                            // be used to commit the changes, reducing transaction count needed to \n                            // complete the update.\n                        );\n                        if( false ) {\n                            if (curSettingsId == recId) {\n                                print(\" -> \");\n                                assert(\n                                    // fails if the delegates aren't all validating settings:\n                                    cctx.allDelegatesAreValidatingSettings(),\n                                    // can't fail:\n                                    \"no way jose\"\n                                );\n                                print( \" <- \")\n                            } else {\n                                recIdStr = recId.decode_utf8_safe();\n                                curSettingsIdStr = curSettingsId.decode_utf8_safe();\n                                print(\"  -- NOTE: updating \"+ recIdStr +\", which isn't currentSettings=\"+curSettingsIdStr)\n                            }\n                        }\n                    };\n\n                    cctx.mustOutputDelegatedData(recId, dDataTypeName).trace(\"  -- did output delegated data? \")\n                    && true\n                },\n\n                // only used in mint/spend Delegate, not the delegated-data policy\n                DeletingDelegatedData {_dataType, recId} => if (!isMintDelegate) {\n                    error(\"DeletingDelegatedData activity is only allowed in the mint delegate\")\n                } else {\n                    cctx : CapoCtx = baseCctx.withCharterRef();\n                    assert(cctx.nowActingAsMintDgt(), \"<---- fails in there, not here\");\n\n                    REQT(\"this code is triggered by both the mintDgt and spendDgt, with each doing their parts of the job\");\n                    REQT(\"the spendDgt allows the spending of the utxo\");\n                    REQT(\"the mintDgt requires the burning of its UUT\");\n                    REQT(\"it must not delete a record that's still referenced by the Capo manifest\");\n                    REQT(\"a matching manifest entry has to be changed or removed prior to deletion\");\n\n                    _inputDD : TxInput = cctx.delegatedDataTxInput(recIdBytes: recId);\n                    // the mintDelegate should be triggered with \n                    TODO(\"verify the input was found ^\");\n\n                    assert(false, \"Delete not supported yet\");\n\n                    TODO(\"implement the generic data-controller re-delegation convention here\");\n                    TODO(\"ensure that the right delegate is consulted with its BurningActivities.*\");\n\n                    false\n                },\n                // the following activities are NOT done in the mint/spend delegate,\n                //     ... but only in the data-controller delegate.\n                // We made these explicit so they're functionally required of every specialized delegate.\n                // All of the mint/spend/burn activities must be handled by the specialized delegate.  \n                // Note that this code module is generic, so it can't know the internal semantics of those activities,\n                // ... or even what their nested variants will be.  It's up to the specialization to handle them.\n                // Each of these indicates plural \"activities\", but they're actually each an individual, discrete, single activity\n                // ... with an Enum allowing ONE of various possible specialization-specific activities at that spot.\n                // ... MultipleActivities would be used to express \"it does multiple separate activities on different utxos\")\n                SpendingActivities => true, // handled by the specialized delegate\n                MintingActivities => true,  // handled by the specialized delegate\n                BurningActivities => true // handled by the specialized delegate\n            };\n            assert(checkNonDelegatedActivities, \"checkNonDelegatedActivities failed\");\n\n            if (\n                bREQT(\"... additionalDelegateValidation\") \n                && activity.additionalDelegateValidation(dgtionDatum, baseCctx.needsCharter())\n            ) {\n                print (\"delegate: \"+ delegateName + \": additionalDelegateValidation ok!\\n\");\n                true\n            } else {\n                error(\"delegate: \"+ delegateName + \": additionalDelegateValidation returned false (without any thrown error)\")\n            }\n        } else { false }\n    } else { false }\n\n    result\n}\n\nfunc main(\n    mdd: DelegateDatum, \n    activity: DelegateActivity\n) -> Bool {\n    print(\" ðŸš¥â“delegate: \"+delegateName + \"\\n\");\n\n    result :Bool = mdd.switch{\n        //! performs essential checks of policy for spending the minting delegate's authority token \"mintDgt-*\"\n        // ... it also calls any additionalDelegateValidation() defined in a specialized minting delegate,\n        // ... governing the minting of application-specific tokens (including UUTs, fungible tokens, \n        // ... or other sorts of tokens under our minting policy).\n        //! Ditto, for our spendDgt-* token, for governing the spend of any utxos in the Capo address.\n        capoStoredData => error(\"Data Delegates must never store the capoStoredData variant in the script; used only for data-structuring capo-stored utxo datum\"),\n        // todo: ensure that the utxo-creation path also does not store IsDelegatedData variants in the script\n\n        //! This code path is also used for other authority-bearing tokens in other specialized delegates,\n        //  ... such as named delegates that the mintDgt- or spendDgt- policies defer to.\n        //  ... each of those cases has separate execution through this base logic, with specialization \n        //  ... applicable for each (see references to \"nowActingAs\").\n        isD : IsDelegation{dd} => {\n             // MintDelegateDatum::IsDelegation{dd, cfg} = isD;\n             assert(dd.tn != rev.serialize(), \"param/script-hash uniqueness\");\n             assert(dd.tn != instance, \"param/script-hash uniqueness\");\n             assert(dd.tn != delegateName.encode_utf8(), \"param/script-hash uniqueness\");\n \n             // showMyTokens : (Value) -> String = mkTokenShow(dd.mph);\n             myDgTkn = // showMyTokens(get_current_input().value);\n             get_current_input().value.show();\n\n             print(\"  -- is spending dgTkn \"+ myDgTkn);\n\n             REQT(\"... final checks:\");\n             cctx : CapoCtx = mkCapoCtx(dd.mph).needsCharter();\n             govAuthorityCheck : Bool = if (!isDgDataPolicy) {true} else {\n                if (!requiresGovAuthority) {true} else {\n                    cctx.requiresGovAuthority().orFail()\n                }\n            }\n\n            govAuthorityCheck\n            && checkOneActivity(isD, activity, dd, cctx)\n        },\n        _ => {\n            // to trigger an invalid redeemer, call this function\n            kaboomInvalidRedeemer = () -> {  error(\"wrong Actvy/dtm\") }; // Activity custom datum must not use Activities reserved for IsDelegation datum.\") };\n\n            activity.switch{\n                DelegateLifecycleActivities => kaboomInvalidRedeemer(), \n                CapoLifecycleActivities => kaboomInvalidRedeemer(),\n                _ => activity.otherDatumValidation(mdd)\n            }\n        }\n    }            \n\n    print (\"ðŸš¥ðŸŸ¢ delegate: \"+ delegateName + \": ok!\\n\");\n    // always true:\n    result\n}", {
    project: "stellar-contracts",
    purpose: "spending",
    name:  "src/delegation/BasicDelegate.hl", // source filename
    moduleName:  "BasicDelegate",
});

export { BasicDelegate_hl as B };
//# sourceMappingURL=BasicDelegate.mjs.map
