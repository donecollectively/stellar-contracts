{
  "version": 3,
  "sources": ["../src/helios/rollupPlugins/heliosRollupLoader.ts", "../src/helios/rollupPlugins/heliosRollupBundler.ts", "../src/utils.ts", "../src/HeliosPromotedTypes.ts", "../src/colors.ts", "../src/helios/rollupPlugins/StellarHeliosProject.ts", "../src/helios/dataBridge/BundleTypes.ts", "../src/helios/dataBridge/BundleBasedGenerator.ts", "../src/helios/dataBridge/BundleTypeGenerator.ts", "../src/helios/dataBridge/dataBridgeGenerator.ts", "../src/networkClients/mkCancellablePromise.ts", "../src/environment.ts", "../src/helios/rollupPlugins/rollupCreateHlbundledClass.ts", "../src/configuration/DeployedScriptConfigs.ts", "../src/helios/CachedHeliosProgram.ts", "../src/delegation/jsonSerializers.ts", "../src/UplcConsoleLogger.ts", "../src/StellarTxnContext.ts", "../src/diagnostics.ts"],
  "sourcesContent": ["import { readFileSync } from \"fs\";\nimport path from \"path\";\n\nimport { createFilter } from \"rollup-pluginutils\";\nimport type { LoadResult, PluginContext, ResolveIdResult } from \"rollup\";\n\n/**\n * Rollup loader for Helios source files\n * @public\n **/\nexport function heliosRollupLoader(\n    opts: {\n        include?: string;\n        exclude?: string[];\n        project?: string;\n        resolve?: string | false | null;\n        onHeliosSource?: (heliosSourceId: string) => void;\n    } = {}\n) {\n    const filterOpts = {\n        ...{\n            include: [\"*.hl\", \"**/*.hl\"],\n            exclude: [],\n            project: \"\"\n        },\n        ...opts,\n    };\n    if (!filterOpts.include) {\n        throw Error(\"missing required 'include' option for helios loader\");\n    }\n\n    const filter = createFilter(\n        filterOpts.include || [\"*.hl\", \"**/*.hl\"],\n        filterOpts.exclude,\n        {\n            resolve: filterOpts.resolve,\n        }\n    );\n    const project = filterOpts.project ? `${filterOpts.project}` : \"\";\n\n    type Loader = {\n        code: string;\n        map: { mappings: string };\n    };\n    let esbuildApi;\n    function resolveId(this: PluginContext, source: string, importer: string | undefined, options: any) {\n        // the source is a relative path name\n        // the importer is an a fully resolved id of the imported module\n        const where = new Error(`here!`).stack;\n        if (!filter(source)) {\n            // console.log(`resolver1: resolving ${source} for ${importer}`, \n            //     //where\n            // );\n            // } else {\n            // if (source.match(/\\.hl$/))\n            // console.log(\n            //     `resolver1: skipping ${source} due to filter mismatch`\n            //     // filterOpts.include\n            // );\n            return null;\n        }\n        // this.addWatchFile(source);\n\n        return {\n            id: source,            \n        } as ResolveIdResult;\n    };\n    return {\n        name: \"helios\",\n        resolveId, // the resolver hook from above\n\n        \n        load(this: PluginContext, id: string): LoadResult {\n            if (filter(id)) {\n                const relPath = path.relative(\".\", id);\n                // this.warn(`.hl watch: ${id}`);\n\n                // when this loader is used within a nested self-compilation of a helios bundle,\n                // this hook informs the caller in the top-level Rollup instance about the presence \n                // of a dependency file.  See rollupCreateHlbundledClass.ts \n                // Not needed for general use in the top-level rollup config.\n                if (opts.onHeliosSource) {\n                    opts.onHeliosSource(id);\n                }\n                const content = readFileSync(relPath, \"utf-8\");\n                // console.warn(\n                //     `heliosLoader: ${relPath}`\n                // );\n\n                // helios.Program.new(content) // fails unless it can resolve deps\n\n                // todo: use Helios' logic for this\n                const [_, purpose, moduleName] =\n                    content.match(\n                        /(module|minting|spending|endpoint)\\s+([a-zA-Z0-9]+)/m\n                    ) || [];\n\n                if (!(purpose && moduleName))\n                    throw new Error(`Bad format for helios file ${id}`);\n\n                const code =\n                    `import { makeSource } from \"@helios-lang/compiler-utils\";\\n`+\n                    `const ${moduleName}_hl = makeSource(\\n` +\n                    `  ${JSON.stringify(content)}, {\\n` +\n                    // `  srcFile: ${JSON.stringify(relPath)},\\n`+\n                    `    project: ${JSON.stringify(project)},\\n` +\n                    `    purpose: ${JSON.stringify(purpose)},\\n` +\n                    `    name:  ${JSON.stringify(\n                        relPath\n                    )}, // source filename\\n` +\n                    `    moduleName:  ${JSON.stringify(moduleName)},\\n` +\n                    `})\\n` +\n                    `\\nexport default ${moduleName}_hl\\n`;\n                return {\n                    code: code,                    \n                    // id: `${id}\u2039generated\u203A.ts`,\n                    map: { mappings: \"\" },\n                };\n            }\n        },\n\n        // buildStart({ plugins }) {\n        // \tconst parentName = 'esbuild';\n        // \tconst parentPlugin = plugins.find(\n        // \t\tplugin => plugin.name === parentName\n        // \t);\n        // \tif (!parentPlugin) {\n        // \t\t// or handle this silently if it is optional\n        // \t\tthrow new Error(\n        // \t\t\t`This plugin depends on the \"${parentName}\" plugin.`\n        // \t\t);\n        // \t}\n        // \t// now you can access the API methods in subsequent hooks\n        // \tesbuildApi = parentPlugin;\n        // },\n    };\n}\n", "import path from \"path\";\nimport {\n    existsSync,\n    mkdirSync,\n    readFileSync,\n    unlinkSync,\n    utimesSync,\n    writeFileSync,\n} from \"fs\";\nimport { createFilter } from \"rollup-pluginutils\";\nimport MagicString from \"magic-string\";\nimport { inspect } from \"util\";\nimport { colors } from \"../../utils.js\";\nconst { magenta } = colors;\n\nimport {\n    type InputOptions,\n    type ResolveIdHook,\n    type ResolveDynamicImportHook,\n    type ResolveIdResult,\n    type PartialResolvedId,\n    type LoadResult,\n    type PluginContext,\n    type SourceDescription,\n    type LoadHook,\n    type CustomPluginOptions,\n    rollup,\n    type ResolvedId,\n} from \"rollup\";\n\nimport { blake2b } from \"@helios-lang/crypto\";\nimport { bytesToHex, hexToBytes } from \"@helios-lang/codec-utils\";\nimport { StellarHeliosProject } from \"./StellarHeliosProject.js\";\nimport { bytesToText, textToBytes } from \"../../HeliosPromotedTypes.js\";\nimport {\n    rollupCreateHlbundledClass,\n    type BundleClassWithLoadStats,\n    type heliosSourceFileSeenHook,\n} from \"../rollupPlugins/rollupCreateHlbundledClass.js\";\nimport type { HeliosScriptBundle } from \"../scriptBundling/HeliosScriptBundle.js\";\nimport type { CapoHeliosBundle } from \"../scriptBundling/CapoHeliosBundle.js\";\nimport {\n    parseCapoJSONConfig,\n    type CapoDeployedDetails,\n} from \"../../configuration/DeployedScriptConfigs.js\";\nimport {\n    serializeCacheEntry,\n    stringifyCacheEntry,\n} from \"../CachedHeliosProgram.js\";\nimport {\n    delegateLinkSerializer,\n    uplcDataSerializer,\n} from \"../../delegation/jsonSerializers.js\";\nimport { environment } from \"../../environment.js\";\n\ntype HeliosBundlerPluginState = {\n    capoBundle?: CapoHeliosBundle;\n    hasExplicitCapoBundle: boolean;\n    hasOtherBundles: boolean;\n    project: StellarHeliosProject;\n    bundleClassById: Record<string, BundleClassWithLoadStats>;\n    emittedArtifacts: Set<string>;\n    deps: Map<string, Set<string>>;\n    hlToOutputFiles: Map<string, Set<string>>;\n    hlToHlb: Map<string, Set<string>>;\n};\n\n/**\n * Rollup loader for generating typescript types from Helios source files\n * @remarks\n * This rollup plugin is designed to be used in a rollup configuration\n * to generate typescript types from Helios source files.\n *\n * The plugin is designed to be used in conjunction with the helios rollup loader,\n * which compiles the helios source files into javascript.\n *\n * The following Rollup build hooks are used to make it all happen:\n * - resolveId: this hook is used to intercept the import of the helios bundle files, and use the\n *   project to generate updated types if needed and available.\n * @public\n **/\nexport function heliosRollupBundler(\n    opts: {\n        include?: string;\n        exclude?: string[];\n        project?: string;\n        vite?: boolean;\n        emitBundled?: boolean;\n        compile?: boolean;\n        exportPrefix?: string;\n    } = {}\n) {\n    const pluginOptions = {\n        vite: false,\n        project: \"\",\n        compile: false,\n        exportPrefix: \"\",\n        ...opts,\n        ...{\n            include: /.*\\.hlb\\.[jt]s$/,\n            exclude: [],\n        },\n    };\n\n    // creates a temporary directory for dynamic loading,\n    // in the project-root's .temp directory\n    const tempDir = path.join(process.cwd(), \".hltemp\", \"heliosBundler\");\n    // create the tempdir if needed\n    if (!existsSync(tempDir)) {\n        mkdirSync(tempDir, { recursive: true });\n    }\n    // console.log(`heliosBundler: using tempDir: ${tempDir}`);\n\n    const filterHLB = createFilter(\n        pluginOptions.include,\n        pluginOptions.exclude\n    );\n\n    const filterHeliosSources = createFilter([\"*.hl\", \"**/*.hl\"]);\n\n    const regexCurrentCapoConfig =\n        /^@donecollectively\\/stellar-contracts\\/currentCapoConfig$/;\n\n    const filterHlbundledImportName = createFilter(/.*\\.hlb\\.[jt]s\\?bundled/);\n    // const project = options.project ? `${options.project}` : \"\";\n\n    const netName = environment.CARDANO_NETWORK;\n    if (!netName) {\n        console.warn(\n            \"missing CARDANO_NETWORK environment signal; building for 'preprod'\"\n        );\n    }\n    const networkId = netName || \"preprod\";\n\n    // const lib = loadCompilerLib();\n    const { projectRoot, packageJSON } =\n        StellarHeliosProject.findProjectDetails();\n\n    const thisPackageName = packageJSON.name;\n    const packageWithPrefix =\n        `${thisPackageName}/${pluginOptions.exportPrefix}/`\n            .replace(/\\/+/g, \"/\")\n            .replace(/\\/$/, \"\");\n\n    //read package.json from project root, parse and check its package name\n    // const packageJsonPath = path.join(projectRoot, \"package.json\");\n    // const packageJson = JSON.parse(readFileSync(packageJsonPath, \"utf-8\"));\n    const isStellarContracts =\n        \"@donecollectively/stellar-contracts\" === packageJSON.name;\n\n    const state: HeliosBundlerPluginState = {\n        capoBundle: undefined, // new CapoHeliosBundle(),\n        hasExplicitCapoBundle: false,\n        hasOtherBundles: false,\n        project: new StellarHeliosProject(),\n        bundleClassById: {},\n        emittedArtifacts: new Set<string>(),\n        deps: new Map<string, Set<string>>(),\n        hlToOutputFiles: new Map<string, Set<string>>(),\n        hlToHlb: new Map<string, Set<string>>(),\n    };\n\n    const firstImportFrom: Record<string, string> = {};\n\n    function relativePath(id: string) {\n        return id.replace(`${projectRoot}/`, \"\");\n    }\n    const isJavascript = /\\.js$/;\n\n    const placeholderSetup = {\n        setup: {\n            isMainnet: false,\n            isPlaceholder: \"rollupBundlerPlugin for type-gen\",\n        },\n    };\n\n    function findOrCreateDeps(importerId: string) {\n        if (state.deps.has(importerId)) {\n            return state.deps.get(importerId)!;\n        } else {\n            const newDeps = new Set<string>();\n            state.deps.set(importerId, newDeps);\n            return newDeps;\n        }\n    }\n    function addHlb(hlId: string, hlbId: string) {\n        if (!state.hlToHlb.has(hlId)) {\n            state.hlToHlb.set(hlId, new Set<string>());\n        }\n        // console.warn( colors.redBright( \"--- addHlb: \") + hlId + \" -> \" + hlbId);\n        state.hlToHlb.get(hlId)!.add(hlbId);\n    }\n    function addHlArtifact(hlId: string, filename: string) {\n        if (!state.hlToOutputFiles.has(hlId)) {\n            state.hlToOutputFiles.set(hlId, new Set<string>());\n        }\n        // console.warn( colors.greenBright( \"--- addHlArtifact: \") + hlId + \" -> \" + filename);\n        state.hlToOutputFiles.get(hlId)!.add(filename);\n    }\n    function removeOutputArtifact(hlId: string) {\n        if (state.hlToOutputFiles.has(hlId)) {\n            for (const filename of state.hlToOutputFiles.get(hlId)!) {\n                // console.warn(\"--- removeOutputArtifact: \" + filename);\n                if (existsSync(filename)) {\n                    unlinkSync(filename);\n                }\n            }\n        }\n    }\n\n    return {\n        name: \"heliosBundler\",\n        buildEnd: {\n            order: \"pre\",\n            handler(this: PluginContext, error?: Error) {\n                // write the project file after the build, skipping any\n                // pending delay from calls to `deferredWriteProjectFile()`\n                this.debug(\n                    \"@buildEnd: \" + (error ? \"error: \" + error?.message : \"\")\n                );\n                if (pluginOptions.vite) return;\n                this.emitFile({\n                    type: \"asset\",\n                    fileName: \"needResolverConditions.mjs\",\n                    source: resolverConditionsHelper(),\n                });\n                // return state.project.writeProjectFile();\n            },\n        },\n        // ...stellarDeploymentHook({\n        //     networkId,\n        //     thisPackageName,\n        //     isStellarContracts,\n        // }),\n        resolveId: {\n            order: \"pre\",\n            async handler(this: PluginContext, source, importer, options) {\n                const interesting = !!source.match(/Vesting.*\\.hlb\\./);\n\n                if (source.match(regexCurrentCapoConfig)) {\n                    throw new Error(`hurray`);\n                } else {\n                    // console.log(\"      ==== import ... from \", source);\n                }\n\n                const { project } = state;\n                const { isEntry } = options;\n                let resolved: ResolvedId | null = null;\n\n                const importerIsJS = !!importer?.match(isJavascript);\n                const resolutionTargetIsJS = !!source?.match(isJavascript);\n                const importerIsInThisProject =\n                    importer?.indexOf(project.projectRoot) === 0;\n                if (\n                    pluginOptions.vite &&\n                    importerIsJS &&\n                    resolutionTargetIsJS &&\n                    importerIsInThisProject\n                ) {\n                    this.warn(\n                        `patching up a vitest resolution: ${importer} imported ${source}`\n                    );\n                    // work around vitest not resolving .ts files from .js using\n                    // the correct rules...\n                    const sourceWithTs = source.replace(/\\.js$/, \".ts\");\n                    resolved = await this.resolve(\n                        source,\n                        importer.replace(/\\.js$/, \".ts\"),\n                        {\n                            ...options,\n                            skipSelf: true,\n                        }\n                    );\n                    if (resolved) {\n                        console.log(\n                            `heliosBundler: in vitest: resolving ${source} as ${sourceWithTs} for ${importer}`\n                            // {\n                            //     source,\n                            //     importer,\n                            //     resolved,\n                            // }\n                        );\n                    }\n                }\n                if (isEntry && !importer) {\n                    // this.debug(`<- resolveId (${source}) @isEntry`)\n                    if (resolved && filterHeliosSources(source)) {\n                        const importerDeps = findOrCreateDeps(importer);\n                        importerDeps.add(resolved.id);\n                    } else {\n                        this.debug(\n                            \"resolveId: not resolved or not a filter match: \" +\n                                source +\n                                \" \" +\n                                resolved?.id\n                        );\n                    }\n\n                    return resolved;\n                }\n                // let other resolvers resolve to an absolute filename\n                const r = await this.resolve(source, importer, {\n                    ...options,\n                    skipSelf: true,\n                });\n                if (r) resolved = r;\n                const id = resolved?.id || source;\n                const p = relativePath(id);\n                firstImportFrom[p] =\n                    firstImportFrom[p] || relativePath(importer);\n                if (resolved && id && filterHLB(id)) {\n                    this.debug(\n                        `-> resolveId ${source} (from ${relativePath(\n                            importer\n                        )})`\n                    );\n                    if (interesting) {\n                        this.debug(\n                            `resolved absolute HLB id ${id} with options: ` +\n                                JSON.stringify(options)\n                        );\n                    }\n\n                    if (pluginOptions.vite) {\n                        // in vite, we allow resolution and loading to proceed without\n                        // forking a separate compile-and-load sequence for an emitted chunk.\n                        // Vite(st) uses in-memory techniques, so it doesn't support emitFile().\n                        // nonetheless, our type-generation will create the appropriate\n                        // typeInfo & bridge files for any .hlb.ts file loaded in vite/vitest.\n                        this.debug(\n                            `<- resolveId (${relativePath(\n                                resolved.id\n                            )}) for Vite`\n                        );\n                        return resolved;\n                    } else {\n                        // id is now an absolute filename of a (TS or JS) helios-bundle definition.\n                        // Before proceeding with returning a resolution for that file, let's\n                        // try to push it through a depth-first compile, load it and generate types.\n                        // const name = resolved.id.replace(\n                        //     /.*\\/([._a-zA-Z]*)\\.hlb\\.[jt]s$/,\n                        //     \"$1\"\n                        // );\n                        const bundledId = `${id}?bundled`;\n\n                        const name = resolved.id.replace(\n                            /.*\\/([._a-zA-Z0-9]*)\\.hlb\\.[jt]s$/,\n                            \"$1\"\n                        );\n                        const buildGenericArtifacts = !!isStellarContracts;\n                        const netIdSuffix = buildGenericArtifacts\n                            ? \"\"\n                            : `-${networkId}`;\n\n                        const packageRelativeName = `contracts${netIdSuffix}/${name}.hlb`;\n                        const bundledExportName = `${packageWithPrefix}/${packageRelativeName}`;\n                        //This arranges a convention for emitting a predictable\n                        // exported file, used to connect the importer with emitted code\n                        // using an expected import name\n                        // Note: this requires subpath patterns for contracts/*.hlb\n                        // to be part of the package.json exports field:\n                        // ```\n                        //   \"exports\": {\n                        //       \".\": { /* types, import, ...etc */ }\n                        //       \"./contracts/*.hlb\": {\n                        //             \"network-preprod\": \"./dist/contracts-preprod/*.hlb.mjs\",\n                        //             \"network-mainnet\": \"\"./dist/contracts-mainnet/*.hlb.mjs\",\n                        //       }\n                        //      [...]\n                        //   }\n                        // ```\n                        if (pluginOptions.emitBundled) {\n                            const actualResolutionResult = await this.resolve(\n                                id,\n                                importer,\n                                options\n                            );\n\n                            if (\n                                actualResolutionResult?.id &&\n                                !state.emittedArtifacts.has(bundledId)\n                            ) {\n                                // preempt asynchronous overlapping work:\n                                state.emittedArtifacts.add(bundledId);\n\n                                const myDeps = findOrCreateDeps(\n                                    actualResolutionResult?.id\n                                );\n                                const onHeliosSource: heliosSourceFileSeenHook =\n                                    (hsId, outFile) => {\n                                        this.debug(`  \u2022 ${hsId} \uD83D\uDC40\uD83D\uDD0D`);\n\n                                        this.debug(` \u2022  ${hsId} \uD83D\uDC40\uD83D\uDD0D`);\n                                        myDeps.add(hsId);\n                                        this.addWatchFile(hsId);\n                                        addHlArtifact(hsId, outFile);\n                                        addHlb(hsId, id);\n                                    };\n\n                                const SomeBundleClass =\n                                    await rollupCreateHlbundledClass(\n                                        actualResolutionResult.id,\n                                        {\n                                            projectRoot,\n                                            onHeliosSource,\n                                        }\n                                    );\n\n                                const isMainnet = networkId === \"mainnet\";\n\n                                state.bundleClassById[id] = SomeBundleClass;\n                                const hlBundler: HeliosScriptBundle =\n                                    SomeBundleClass.create({\n                                        ...placeholderSetup,\n                                        placeholderAt: \"variant generation\",\n                                    });\n                                if (SomeBundleClass.isCapoBundle) {\n                                    debugger;\n                                    if (!state.project.capoBundleName) {\n                                        // debugger\n                                        // throw new Error(`surprise, we don't know the capo name yet!?! (debugging breakpoint available)`);\n                                    } else if (\n                                        SomeBundleClass.name ==\n                                        state.project.capoBundleName\n                                    ) {\n                                        const filenameBase = id.replace(\n                                            /.*\\/([^.]+)\\..*$/,\n                                            \"$1\"\n                                        );\n                                        const deployDetailsFile = `./${filenameBase}.hlDeploy.${networkId}.json`;\n                                        const resolvedDeployConfig =\n                                            await this.resolve(\n                                                deployDetailsFile,\n                                                id, // importer\n                                                {\n                                                    // attributes: {type: \"json\" },\n                                                }\n                                            );\n                                        if (!resolvedDeployConfig) {\n                                            debugger;\n                                            this.info(\n                                                `Capo bundle: no deploy config for ${networkId}: ${SomeBundleClass.name}`\n                                            );\n\n                                            state.project.configuredCapo.reject(\n                                                new Error(\n                                                    \"no deployment config\"\n                                                )\n                                            );\n                                            debugger;\n                                        }\n                                    }\n                                }\n                                // immediately starts resolving the file-for-emit, and returns a\n                                // PACKAGE-RELATIVE name for the artifact.  The importer of\n                                // the .hlb.ts file will get that translated import statement, and\n                                // the emitFile acts like a fork, with the processing of the emitted\n                                // file happening on a separate track.\n                                // and the package-relative import name used in place of normal\n                                // load/transform processing of the separate chunk.\n                                console.log(\n                                    `--------------------------------------------------------------\\n` +\n                                        `  -- heliosBundler: emitting ${packageRelativeName}` +\n                                        `\\n--------------------------------------------------------------\\n` +\n                                        \"\"\n                                );\n                                this.emitFile({\n                                    type: \"chunk\",\n                                    id: bundledId,\n                                    name: packageRelativeName,\n                                    importer,\n                                    // only valid for emitted assets, not chunks:\n                                    // originalFileName: resolved.id,\n                                });\n                                this.debug(\n                                    `<- resolveId (${relativePath(\n                                        resolved.id\n                                    )}) with artifacts to be emitted`\n                                );\n                                // this.debug(`  --> load before finishing resolution: ${relativePath(bundledExportName)}`)\n                                // await this.load(actualResolutionResult)\n                                // this.debug(`  <-- loaded and finishing resolution: ${relativePath(bundledExportName)}`)\n\n                                return bundledExportName;\n                            } else if (actualResolutionResult?.id) {\n                                // this.debug(\n                                //     `<- resolveId (${relativePath(\n                                //         resolved.id\n                                //     )}) skipped redundant artifact creation`\n                                // );\n                                return bundledExportName;\n                            }\n                        }\n                        this.info(\n                            `<- resolveId (${relativePath(\n                                resolved?.id\n                            )}) without emitted artifacts`\n                        );\n                        return bundledExportName;\n                    }\n                } else if (filterHlbundledImportName(id)) {\n                    this.debug(\n                        `-> resolveId for emitted bundle: ${relativePath(\n                            source\n                        )}\\n   (from ${relativePath(importer)})`\n                    );\n\n                    if (interesting && process.env.DEBUG) {\n                        this.warn(\n                            `resolveId: got HLBundled: ${id}` +\n                                JSON.stringify(options)\n                        );\n                    }\n                    // resolving the file-to-be-emitted - it's the same file, but as a\n                    // dynamic entry-point.  We resolve it like any file, minus the ?bundled suffix,\n                    // then load & transform as seen below.\n\n                    const unbundledId = id.replace(/\\?bundled$/, \"\");\n                    if (filterHLB(unbundledId)) {\n                        const myDeps = findOrCreateDeps(unbundledId);\n                        for (const dep of myDeps) {\n                            // box: \uD83D\uDCE6; eyes: \uD83D\uDC40; bullet: \u2022\n                            this.debug(\" \u2022 \uD83D\uDC40  \uD83D\uDCE6\" + dep);\n                            addHlArtifact(dep, unbundledId);\n                            addHlb(dep, unbundledId);\n                            this.addWatchFile(dep);\n                        }\n                    }\n                    // this call doesn't hit the path above, or cause an infinite loop,\n                    //  because this.resolve() skips using this plugin's own resolveId hook.\n                    const result = await this.resolve(unbundledId, importer, {\n                        ...options,\n                        skipSelf: true,\n                    });\n                    // debugger;\n                    if (!result) {\n                        throw new Error(`can't fail here`); // for typescript narrowing\n                    }\n                    this.debug(\n                        `<- resolveId (${\n                            result ? relativePath(result.id) : \"\u2039null\u203A\"\n                        }) for emitted bundle`\n                    );\n                    return result;\n                } else {\n                    if (\n                        id.match(/hlb/) &&\n                        !id.match(/hlBundled/) &&\n                        !id.match(/dist\\//)\n                    ) {\n                        console.log(\n                            `resolve: skipping due to filter mismatch (debugging breakpoint available)`,\n                            { id, importer }\n                        );\n                        debugger;\n                        //no-op, but helpful for debugging:\n                        filterHLB(id); // trace into here to see what's up with the filter\n                        return null;\n                    }\n                }\n                // this.debug(`<- resolveId (${source}) verbatim result`)\n                return resolved;\n            },\n        },\n        load: {\n            order: \"pre\",\n            handler: async function (\n                this: PluginContext,\n                id: string\n            ): Promise<LoadResult> {\n                // the source is a relative path name\n                // the importer is an a fully resolved id of the imported module\n                // console.log(\"heliosBundler: load\");\n\n                const interesting = !!id.match(/Vesting.*\\.hlb\\./);\n                const { project } = state;\n                if (filterHlbundledImportName(id)) {\n                    // NOTE: the filterHlbundledImportName branch\n                    // in the resolveId hook above ensures that we NEVER\n                    // arrive here.  Instead, the load process continues\n                    // normally, but with the output emitted to the separate\n                    // chunk whose emitFile() is initiated above.\n                    //\n                    // See the transform hook for the details we add to the .hlb\n\n                    throw new Error(\n                        `unused code path for broken emitFile in load `\n                    );\n                }\n                if (!filterHLB(id)) {\n                    if (\n                        id.match(/hlb/) &&\n                        !id.match(/hlBundled/) &&\n                        !id.match(/dist\\//)\n                    ) {\n                        console.log(\n                            `load: skipping due to filter mismatch (debugging breakpoint available)`,\n                            { id }\n                        );\n                        debugger;\n                        //no-op, but helpful for debugging:\n                        filterHLB(id); // trace into here to see what's up with the filter\n                    }\n\n                    return null;\n                }\n                this.debug(`-> load: ${relativePath(id)}`);\n                if (interesting && process.env.DEBUG) {\n                    console.log(\"    ---- heliosBundler: load\", { id });\n                }\n\n                // ->  todo: load an existing bundle if it's already compiled, and ask that class to\n                // ->   check its sources for changes, so we can skip rollup and recompilation if\n                // ->   things are already up-to-date.\n                let SomeBundleClass = state.bundleClassById[id];\n\n                // bullet: \u2022 ; eyes: \uD83D\uDC40\n                this.debug(`watch: ${id} \uD83D\uDC40 \uD83D\uDC5C`);\n                this.addWatchFile(id);\n                const myDeps = findOrCreateDeps(id);\n                const onHeliosSource: heliosSourceFileSeenHook = (\n                    heliosSourceId,\n                    outputFile\n                ) => {\n                    this.debug(`  \u2022 ${heliosSourceId} \uD83D\uDC40 \uD83D\uDC5C`);\n                    this.addWatchFile(heliosSourceId);\n                    addHlArtifact(heliosSourceId, outputFile);\n                    addHlb(heliosSourceId, id);\n                    myDeps.add(heliosSourceId);\n                };\n                if (!SomeBundleClass) {\n                    if (pluginOptions.emitBundled) {\n                        this.warn(\n                            `heliosBundler: missing expected bundleClass for ${id} (debugging breakpoint available)`\n                        );\n                        debugger;\n                    }\n                    SomeBundleClass = await rollupCreateHlbundledClass(id, {\n                        projectRoot,\n                        onHeliosSource,\n                    });\n                }\n                // await rollupCreateHlbundledClass(id);\n                const relativeFilename = path.relative(projectRoot, id);\n                this.debug(\n                    `   \uD83D\uDC41\uFE0F  checking helios bundle ${SomeBundleClass.name} from ${relativeFilename}`\n                );\n\n                const { hash, afterDelay } = SomeBundleClass;\n                this.debug(\n                    colors.cyanBright(\n                        `create from ${id} ${hash} ${afterDelay}s`\n                    )\n                );\n\n                let bundle = SomeBundleClass.create({\n                    ...placeholderSetup,\n                    placeholderAt: \"load() before type-gen\",\n                });\n\n                // compile the program seen in that bundle!\n                // ... to trigger helios syntax-checking:\n                let program = bundle.program;\n\n                let replacedCapo = false;\n                if (SomeBundleClass.isCapoBundle) {\n                    let skipInstallingThisOne = false;\n                    const filenameBase = id.replace(/.*\\/([^.]+)\\..*$/, \"$1\");\n                    const deployDetailsFile = `./${filenameBase}.hlDeploy.${networkId}.json`;\n                    const resolvedDeployConfig = await this.resolve(\n                        deployDetailsFile,\n                        id, // importer\n                        {\n                            // attributes: {type: \"json\" },\n                        }\n                    );\n\n                    if (state.hasExplicitCapoBundle) {\n                        if (!state.capoBundle) {\n                            throw new Error(\n                                `redundant unreachable error for typescript narrowing`\n                            );\n                        }\n\n                        let existingBundleProtoChainNames: string[] = [];\n                        // if the new class is just a base class for a more specific one, that's ok\n                        // we will still return it, without installing it as \"the\" Capo bundle\n                        let existingBundleProto = state.capoBundle.constructor;\n                        while (existingBundleProto) {\n                            existingBundleProtoChainNames.push(\n                                existingBundleProto.name\n                            );\n                            existingBundleProto =\n                                Object.getPrototypeOf(existingBundleProto);\n                        }\n                        if (\n                            existingBundleProtoChainNames.includes(\n                                SomeBundleClass.name\n                            )\n                        ) {\n                            skipInstallingThisOne = true;\n                            console.log(\n                                `Helios project-loader: not adopting ${SomeBundleClass.name} as the project Capo\\n` +\n                                    `  ... because it looks like a base class of already-loaded ${state.capoBundle.constructor.name}`\n                            );\n                        } else {\n                            console.log(\n                                \"have explicitCapoBundle...  AND another, with a different lineage\",\n                                { id, existing: state.capoBundle }\n                            );\n                            debugger;\n                        }\n                    }\n                    if (!state.capoBundle) {\n                        console.log(\n                            \"\\nTroubleshooting first .hlb.ts imports?\\n\" +\n                                [...state.project.bundleEntries.keys()]\n                                    .map(\n                                        (existing: string) =>\n                                            // bullet: \u2022\n                                            `    \u2022 ${traceImportPath(existing)}`\n                                    )\n                                    .join(\"\\n\") +\n                                \"\\n\"\n                        );\n                        // throw new Error(\n                        //     `heliosBundler: Capo bundle not loaded, but there are already other bundles in the state (see import trace above)`\n                        // );\n                    } else {\n                        if (state.hasOtherBundles && !skipInstallingThisOne) {\n                            throw new Error(`unreachable code path??`);\n                            let dCur = shortHash(\n                                JSON.stringify(state.capoBundle?.modules)\n                            );\n                            let dNew = shortHash(\n                                JSON.stringify(\n                                    SomeBundleClass.prototype.modules\n                                )\n                            );\n\n                            if (dCur !== dNew) {\n                                throw new Error(`unreachable code path`);\n                                // logCapoBundleDifferences(\n                                //     dCur,\n                                //     state,\n                                //     dNew,\n                                //     SomeBundleClass,\n                                //     id\n                                // );\n                                // const ts1 = Date.now();\n                                // state.project =\n                                //     state.project.replaceWithNewCapo(\n                                //         id,\n                                //         SomeBundleClass\n                                //     );\n                                // console.log(\n                                //     \"  ---- Reinitialized project in\",\n                                //     Date.now() - ts1,\n                                //     \"ms\"\n                                // );\n                                // replacedCapo = true;\n                            } else {\n                                console.log(\n                                    \"  ---- warning: second capo discovered, though its modules aren't different from default. Generatings its types, but otherwise, Ignoring.\"\n                                );\n                                // make a new project, add the new Capo bundle to it, generate types.\n                                const newProject = new StellarHeliosProject();\n                                newProject.loadBundleWithClass(\n                                    id,\n                                    SomeBundleClass\n                                );\n                                newProject.generateBundleTypes(id);\n                            }\n                        }\n                    }\n                    state.hasExplicitCapoBundle = true;\n\n                    // bundle = new SomeBundleClass({\n                    //     ...placeholderSetup,\n                    //     placeholderAt: \"redundant thing?\",\n                    // });\n                    if (!replacedCapo) {\n                        // state.project.loadBundleWithClass(id, SomeBundleClass);\n                        // state.project.generateBundleTypes(id);\n                    }\n                    this.debug(\n                        `   \uD83D\uDC41\uFE0F  checking (Capo) helios bundle ${SomeBundleClass.name}`\n                    );\n                    if (!skipInstallingThisOne) {\n                        state.capoBundle = bundle;\n                        state.project.loadBundleWithClass(id, SomeBundleClass);\n                        state.project.generateBundleTypes(id);\n                    }\n                } else {\n                    state.hasOtherBundles = true;\n                    if (state.project.bundleEntries.size === 0) {\n                        const capoName = bundle.capoBundle.constructor.name;\n\n                        if (\n                            capoName == \"CapoHeliosBundle\" &&\n                            !state.capoBundle\n                        ) {\n                            console.log(\n                                `looks like you're using the default Capo bundle! ${capoName}`\n                            );\n                            state.project.capoBundleName = capoName;\n\n                            state.project.configuredCapo.resolve(undefined);\n                            state.project.loadBundleWithClass(\n                                \"src/helios/scriptBundling/CapoHeliosBundle.ts\",\n                                bundle.capoBundle.constructor\n                            );\n                            this.warn(\n                                \"skipping type-gen for default Capo bundle\"\n                            );\n                            // state.project.generateBundleTypes(\n                            //     \"src/helios/scriptBundling/CapoHeliosBundle.ts\"\n                            // );\n                        } else {\n                            console.log(\n                                `  -- \uD83D\uDCE6 Your project's Capo bundle: ${capoName}`\n                            );\n                            state.project.capoBundleName = capoName;\n                        }\n                    }\n                    // try {\n                    //     bundle = new SomeBundleClass(state.capoBundle);\n                    //     this.warn(`\uD83D\uDC41\uFE0F checking helios bundle ${SomeBundleClass.name} from ${relativeFilename}`)\n                    // } catch (e:any) {\n                    //     this.error(`Error loading helios bundle ${SomeBundleClass.name}: ${e.message}`);\n                    // }\n                    state.project.loadBundleWithClass(id, SomeBundleClass);\n                    try {\n                        state.project.generateBundleTypes(id);\n                        this.debug(\n                            `<- load: ${relativePath(\n                                id\n                            )} type-gen side effects done`\n                        );\n                        return null;\n                    } catch (e: any) {\n                        if (e.message.match(\"compilerError\")) {\n                            console.error(e);\n                            throw new Error(\n                                `Error in Helios script (see above)`\n                            );\n                        }\n                        console.error(`Error generating types for ${id}:\\n`, e);\n                        return new Promise((resolve, reject) => {\n                            setTimeout(() => {\n                                reject(\n                                    new Error(\n                                        `type-generation error (see above)`\n                                    )\n                                );\n                            }, 5000);\n                        });\n                    }\n                }\n                this.debug(\n                    `<- load: ${relativePath(id)} deferred to other plugins`\n                );\n                return null as LoadResult;\n                //     id: source,\n                // };\n                //  throw new Error(`heliosLoader: ${importer} is importing ${source}`);\n            },\n        },\n        watchChange: {\n            order: \"pre\",\n            handler: function (\n                this: PluginContext,\n                id: string,\n                change: { event: \"create\" | \"update\" | \"delete\" }\n            ) {\n                this.warn(\"change: \" + id + \" \" + change.event);\n                removeOutputArtifact(id);\n                const hlbs = state.hlToHlb.get(id);\n                debugger;\n                if (hlbs) {\n                    for (const hlb of hlbs) {\n                        // touch the hlb file\n                        utimesSync(hlb, new Date(), new Date());\n                    }\n                }\n                return Promise.resolve();\n            },\n        },\n        shouldTransformCachedModule: {\n            handler: function (this: PluginContext, id: string) {\n                this.warn(\"shouldTransformCachedModule: \" + id);\n                return true;\n            },\n        },\n        transform: {\n            order: \"pre\",\n            handler: function (this: PluginContext, code: string, id: string) {\n                if (!filterHLB(id)) return;\n                let looksLikeCapo = code.match(/extends .*Capo.*/);\n                if (looksLikeCapo?.[0].match(/usingCapoBundle/))\n                    looksLikeCapo = null;\n                // this.warn(\"------------------------------------------- transform: \" + id);\n                const myDeps = findOrCreateDeps(id);\n                if (myDeps.size > 0) {\n                    this.debug(`---- watching helios sources for ${id}: `);\n                    for (const dep of myDeps) {\n                        // bullet: \u2022 ; eyes: \uD83D\uDC40\n                        this.debug(`  \u2022 ${dep} \uD83D\uDC40`);\n                        this.addWatchFile(dep);\n                    }\n                } else {\n                    this.warn(`----- no dependencies registered for ${id}`);\n                }\n                const capoConfigRegex =\n                    /^(\\s*preConfigured *= )*(?:capoConfigurationDetails)\\s*;?\\s*$/m;\n                // const tester = `            preConfigured = mkCapoDeployment`\n                // const tester2 = `            preConfigured = mkCapoDeployment; `\n                // const tester3 = `            preConfigured = mkCapoDeployment ;`\n                // const tester4 = `            preConfigured = mkCapoDeployment  ;  `\n                const filenameBase = id.replace(/.*\\/([^.]+)\\..*$/, \"$1\");\n                const deployDetailsFile = `./${filenameBase}.hlDeploy.${networkId}.json`;\n                const hlbFile = id.replace(/.*\\/([^.]+)\\..*$/, \"$1\");\n\n                const SomeBundleClass = state.bundleClassById[\n                    id\n                ] as typeof CapoHeliosBundle;\n\n                if (!SomeBundleClass) {\n                    this.debug(\n                        `skipping config insertion (no emitBundle in this env) ${filenameBase}`\n                    );\n                    return null;\n                }\n                if (looksLikeCapo) {\n                    if (!code.match(capoConfigRegex)) {\n                        debugger;\n                        if (SomeBundleClass.isAbstract == true) {\n                            this.info(\n                                `${SomeBundleClass.name}: abstract class; skipping config insertion`\n                            );\n                            return null;\n                        }\n                        const msg =\n                            `${SomeBundleClass.name}: this looks like a Capo bundle class without a currentDeploymentConfig\\n` +\n                            `  in ${hlbFile}\\n` +\n                            `  import {currentDeploymentConfig} from \"@donecollectively/stellar-contracts\"\\n` +\n                            `  ... and add  'preConfigured = capoConfigurationDetails' to your class.\\n` +\n                            `This will use deployment details from ${deployDetailsFile}\\n` +\n                            `  ... or another json file when deploying to a different network`;\n                        this.warn(msg);\n                        console.log(colors.red(msg));\n                        return null;\n                    }\n                } else if (code.match(capoConfigRegex)) {\n                    this.warn(\n                        `non-Capo class using currentDeploymentConfig in ${id}`\n                    );\n                } else {\n                    debugger;\n                    return transformNonCapo.call(this, code, id);\n                }\n                return transformCapo.call(\n                    this,\n                    code,\n                    id,\n                    capoConfigRegex,\n                    deployDetailsFile\n                );\n            },\n        },\n    };\n\n    async function transformCapo(\n        this: PluginContext,\n        code: string,\n        id: string,\n        capoConfigRegex: RegExp,\n        deployDetailsFile: string\n    ) {\n        this.debug(`-> [transform] Capo`);\n\n        const SomeBundleClass = state.bundleClassById[\n            id\n        ] as typeof CapoHeliosBundle;\n\n        if (!SomeBundleClass) return null;\n\n        const resolvedDeployConfig = await this.resolve(\n            deployDetailsFile,\n            id, // importer\n            {\n                // attributes: {type: \"json\" },\n            }\n        );\n        if (!resolvedDeployConfig) {\n            this.warn(\n                `no ${networkId} setup for Capo bundle: ${deployDetailsFile}`\n            );\n            if (SomeBundleClass.name == state.project.capoBundleName) {\n                state.project.configuredCapo.resolve(undefined);\n            }\n        } else {\n            this.info(\"building with Capo setup: \" + deployDetailsFile);\n            const deployDetailsConfigJSON = readFileSync(\n                resolvedDeployConfig.id\n            );\n            const deployDetails: CapoDeployedDetails<\"json\"> = JSON.parse(\n                deployDetailsConfigJSON.toString() || \"{}\"\n            );\n            if (!deployDetails.capo) {\n                throw new Error(\n                    `missing required 'capo' entry in ${resolvedDeployConfig.id}`\n                );\n            }\n\n            // this.warn(`watch2: ${id}`);\n            // this.addWatchFile(id);\n            // this.addWatchFile(resolvedDeployConfig.id);\n\n            // debugger;\n            // const myDeps = findOrCreateDeps(id);\n            // for (const dep of myDeps) {\n            //     this.addWatchFile(dep);\n            // }\n\n            console.log(deployDetails);\n            const capoConfig = parseCapoJSONConfig(deployDetails.capo.config);\n            const { seedIndex, seedTxn } = capoConfig;\n            const hlBundler: CapoHeliosBundle = await SomeBundleClass.create({\n                deployedDetails: {\n                    config: capoConfig,\n                },\n                setup: {\n                    isMainnet: networkId === \"mainnet\",\n                    isPlaceholder: `rollupBundlerPlugin for inserting pre-compiled Capo details`,\n                },\n            });\n\n            const { CapoMinterBundle } = await import(\n                \"@donecollectively/stellar-contracts/contracts/CapoMinter.hlb\"\n            );\n            const minterBundler: HeliosScriptBundle =\n                await CapoMinterBundle.create({\n                    params: {\n                        seedTxn,\n                        seedIndex,\n                    },\n                    // deployedDetails: {\n                    //     config: {\n                    //         seedTxn,\n                    //         seedIndex\n                    //     }\n                    // },\n                    setup: {\n                        isMainnet: networkId === \"mainnet\",\n                        isPlaceholder: `rollupBundlerPlugin for inserting pre-compiled Minter details`,\n                    },\n                });\n\n            const { programBundle: minterBundle, scriptHash: mph } =\n                await minterBundler.getSerializedProgramBundle();\n            const { scriptHash, programBundle } =\n                await hlBundler.getSerializedProgramBundle();\n            state.project.configuredCapo.resolve(hlBundler);\n\n            const {\n                capo: { config },\n            } = deployDetails;\n            debugger;\n            const typedDeployDetailsText = `{\n        capo: {\n            programBundle: (${JSON.stringify(programBundle)} as never),\n            scriptHash: \"${scriptHash}\",\n            config: this.parseCapoJSONConfig(${JSON.stringify(\n                deployDetails.capo.config\n            )}),\n        },\n        minter: {\n            programBundle: (${JSON.stringify(minterBundle)} as never),\n            scriptHash: ${JSON.stringify(mph)},\n            config: this.parseCapoMinterJSONConfig({\n                seedTxn: ${JSON.stringify(config.seedTxn)},\n                seedIndex: ${JSON.stringify(config.seedIndex)},\n            }),\n        }\n    } \n            static isPreconfigured = true;\n            `;\n            // deployDetails.capo.scriptHash = hexToBytes(scriptHash);\n            deployDetails.capo.programBundle = programBundle;\n\n            const s = new MagicString(code);\n            s.replace(capoConfigRegex, `$1 ${typedDeployDetailsText}`);\n            // console.log(s.toString());\n            // debugger;\n            this.debug(`[transform] <- Capo (w/ deployment)`);\n            return {\n                code: s.toString(),\n                map: s.generateMap({ hires: true }),\n            };\n        }\n    }\n\n    async function transformNonCapo(\n        this: PluginContext,\n        code: string,\n        id: string\n    ) {\n        const s = new MagicString(code);\n        const r = filterHLB(id);\n        if (!r) {\n            return null;\n        }\n        // 1. matches one of the following patterns in the bundle code:\n        //  - specializedDelegateModule = ...\n        //  - static needsSpecializedDelegateModule = false\n        // 2. inserts precompiled: { [variant]: {scriptHash, programBundle} } details\n        //     ... with one entry per variant found in the SomeBundleClass\n\n        // const myDeps = findOrCreateDeps(id);\n        // for (const dep of myDeps) {\n        //     this.debug(`  \u2022 ${dep} \uD83D\uDC40`);\n        //     this.addWatchFile(dep);\n        // }\n        const regex =\n            /(\\s*specializedDelegateModule\\s*=\\s*)|(static needsSpecializedDelegateModule = false)/m;\n        if (code.match(regex)) {\n            const SomeBundleClass: typeof HeliosScriptBundle =\n                state.bundleClassById[id];\n\n            if (!SomeBundleClass) {\n                debugger;\n                this.warn(\n                    `not (yet) inserting pre-compiled script for ${id} (dbpa)`\n                );\n                return null;\n            }\n            let hlBundler: HeliosScriptBundle = SomeBundleClass.create({\n                setup: {\n                    isMainnet: networkId === \"mainnet\",\n                    isPlaceholder: `rollupBundlerPlugin for inserting pre-compiled script details`,\n                },\n            });\n\n            const precompiledVariants: Record<\n                string,\n                string //... with jsonified contents:\n                // {\n                //     scriptHash: string;\n                //     programBundle: any;\n                //     config\n                // }\n            > = {};\n\n            if (SomeBundleClass.needsCapoConfiguration) {\n                this.debug(`[transform]  -- waiting for configured capo`);\n                const configuredCapo =\n                    await state.project.configuredCapo.promise.catch((e) => {\n                        this.debug(\n                            `failed to load configured Capo bundle: ${e.message}`\n                        );\n                        debugger;\n                        return undefined;\n                    });\n                if (configuredCapo) {\n                    hlBundler.capoBundle = configuredCapo;\n                    this.debug(`[transform]  -- configured capo ready`);\n                } else {\n                    this.warn(\n                        `[transform]  ---- no capo deployment; not inserting compiled script for ${relativePath(\n                            id\n                        )}`\n                    );\n                    return null; // transform without injecting compiled script\n                }\n            }\n\n            let scriptCount = 0;\n            let skipCount = 0;\n            for (const [variant, params] of Object.entries(\n                hlBundler.variants\n            )) {\n                if (params) {\n                    const configuredBundle = hlBundler.withSetupDetails({\n                        params,\n                        setup: { isMainnet: networkId === \"mainnet\" },\n                    });\n\n                    const { scriptHash, programBundle, config } =\n                        await (async () => {\n                            if (configuredBundle.preCompiled?.[variant]) {\n                                const { scriptHash, programBundle, config } =\n                                    configuredBundle.preCompiled[variant];\n                                if (!scriptHash) {\n                                    throw new Error(\n                                        `${configuredBundle.displayName}: missing expected scriptHash for pre-compiled variant ${variant}`\n                                    );\n                                }\n                                return {\n                                    programBundle,\n                                    scriptHash,\n                                    config: JSON.stringify(config),\n                                };\n                            } else {\n                                const t =\n                                    await configuredBundle.getSerializedProgramBundle();\n                                const { scriptHash, programBundle } = t;\n                                return {\n                                    programBundle,\n                                    scriptHash,\n                                    config: JSON.stringify(\n                                        configuredBundle.configuredParams,\n                                        delegateLinkSerializer\n                                    ),\n                                };\n                            }\n                        })();\n                    precompiledVariants[variant] = `{\n                        programBundle: (${JSON.stringify(\n                            programBundle\n                        )} as never),\n                        scriptHash: \"${scriptHash}\",\n                        config: ${config},\n                    }\\n`;\n                    scriptCount++;\n                } else {\n                    debugger;\n                    if (state.capoBundle?.configuredUplcParams) {\n                        this.warn(\n                            `variant '${variant}': derive params from capo? (dbpa)`\n                        );\n                    } else if (state.capoBundle) {\n                        this.warn(\n                            `variant '${variant}': missing baseParams; skipping (dbpa)`\n                        );\n                    } else {\n                        this.warn(`wait for capoBundle?`);\n                    }\n                    skipCount++;\n                }\n            }\n\n            const skipMsg = skipCount > 0 ? ` (+${skipCount} skipped)` : ``;\n            if (!scriptCount) {\n                this.debug(\n                    `[transform] <- skipping script insertion for non-capo ${skipMsg}`\n                );\n                return null;\n            } else {\n                const precompiled = `    preCompiled = ({\\n${Object.entries(\n                    precompiledVariants\n                )\n                    .map(([vName, vSrc]) => `${vName}: ${vSrc},\\n`)\n                    .join(\"\")}    })\\n\\n`;\n\n                s.replace(\n                    regex,\n                    (match, specializedDelegateModule, getMain) => {\n                        this.debug(\n                            `[transform] -- inserting pre-compiled script`\n                        );\n                        const existing = specializedDelegateModule || getMain;\n                        return `${precompiled}   ${existing}`;\n                    }\n                );\n\n                // console.log(s.toString())\n                this.debug(\n                    `[transform] <- non-capo w/ ${scriptCount} compiled script(s)${skipMsg}`\n                );\n                return {\n                    code: s.toString(),\n                    map: s.generateMap({ hires: true }),\n                };\n            }\n        }\n        throw new Error(\n            `bundle module format error\\n` +\n                ` ... non-Capo must define 'specializedDelegateModule = ...\\n` +\n                ` ... or EXACTLY AND VERBATIM: \\`static needsSpecializedDelegateModule = false\\``\n        );\n\n        return null;\n    }\n\n    function traceImportPath(existing: string) {\n        let trace: string[] = [];\n        for (let p = existing; p; p = firstImportFrom[p]) {\n            trace.push(p);\n        }\n        const importTrace = trace.join(\"\\n      imported by \");\n        return importTrace;\n    }\n    function shortHash(str: string) {\n        return bytesToHex(blake2b(textToBytes(str)).slice(0, 5));\n    }\n\n    function resolverConditionsHelper() {\n        return `export default class needResolveConditions {\n    constructor() {\n        throw new Error(\\`\n\nThis app tried to load a deployed on-chain script bundle, without\nhaving indicated a network-id.\n\nTo resolve deployed on-chain script bundles, you need to specify\ncustom resolver condition to connect the specific deployment\nenvironment with the pre-compiled scripts for that environment.\n\nIn Next.js, try something like this in next.config.js:\n/** @type {import('next').NextConfig} */\nconst nextConfig = {\n  experimental: {\n    esmExternals: true\n  },\n  webpack: (config) => {\n    config.resolve.conditionNames.push(\\`network-\\${CARDANO_NETWORK || \"preprod\"}\\`);\n    return config;\n  }\n    ...\n                        \\`)\n                    }\n\nIn VIte, use its resolve.conditions setting.\n- see https://vite.dev/config/shared-options.html#resolve-conditions\n                 \nexport default defineConfig({\n     ...\n     resolve: {\n         conditions: [\n             \\`network-\\${process.env.CARDANO_NETWORK || \"preprod\"}\\`\n         ]\n })\n\nMore about conditional exports and the resolver conditions they match:\n\nhttps://nodejs.org/docs/latest-v22.x/api/packages.html#conditional-exports\n\\`  \n}\n}\n`;\n    }\n}\n", "import { isValidUtf8 } from \"@helios-lang/codec-utils\";\nimport type { uutPurposeMap } from \"./CapoTypes.js\";\nimport { textToBytes, type valuesEntry } from \"./HeliosPromotedTypes.js\";\nimport { UutName } from \"./delegation/UutName.js\";\nimport {\n    makeAssets,\n    makeValue,\n    type Value,\n    type MintingPolicyHash,\n} from \"@helios-lang/ledger\";\n\n/**\n * Creates Value-creation entires for a list of uuts\n * @remarks\n *\n * returns a list of `entries` usable in Value's `[mph, entries[]]` tuple.\n * @param uuts - a list of {@link UutName}s or a {@link uutPurposeMap}\n * @public\n **/\nexport function mkUutValuesEntries(uuts: UutName[]): valuesEntry[];\n/** @public **/\nexport function mkUutValuesEntries(uuts: uutPurposeMap<any>): valuesEntry[];\n/** @public **/\nexport function mkUutValuesEntries(\n    uuts: UutName[] | uutPurposeMap<any>\n): valuesEntry[];\n/** @public **/\nexport function mkUutValuesEntries(\n    uuts: UutName[] | uutPurposeMap<any>\n): valuesEntry[] {\n    const uutNs = Array.isArray(uuts) ? uuts : Object.values(uuts);\n    const uniqs: UutName[] = [];\n    for (const un of uutNs) {\n        if (!uniqs.includes(un)) uniqs.push(un);\n    }\n    return uniqs.map((uut) => mkValuesEntry(uut.name, BigInt(1)));\n}\n\n/**\n * Creates a tuple usable in a Value, converting token-name to byte-array if needed\n * @public\n **/\nexport function mkValuesEntry(\n    tokenName: string | number[],\n    count: bigint\n): valuesEntry {\n    const tnBytes = Array.isArray(tokenName)\n        ? tokenName\n        : textToBytes(tokenName);\n\n    // addrHint,  //moved to config\n    // reqdAddress,  // removed\n\n    return [tnBytes, count];\n}\n\n/**\n * construct a Value based on a token-name\n * @remarks\n *\n * A simpler version of the Value constructor to serve the\n * common case of a single, string-based token name.\n *\n * If you need the Value to contain its minUtx computed based\n * on network parameters, use the StellarContract's mkMinTv()\n * method instead.\n *\n * @param mph - policy-hash of the token\n * @param tokenName - string name of the token\n * @param count: number of the tokens to include in the value\n * @public\n **/\nexport function mkTv(\n    mph: MintingPolicyHash,\n    tokenName: string | number[],\n    count: bigint = 1n\n): Value {\n    const v = makeValue(\n        0,\n        makeAssets([[mph, [mkValuesEntry(tokenName, count)]]])\n    );\n    return v;\n}\n\n/**\n * Multiplies two numbers using integer math semantics for matching with Helios on-chain Real math\n *\n * @remarks\n * The numbers can be whole or fractional, with 6 decimal places of honored precision.\n * The result is rounded to 6 decimal places.\n * @todo - delegate this to a call into the on-chain version of same\n * @public\n */\nexport function realMul(a: number, b: number) {\n    const a2 = Math.trunc(1000000 * a);\n    const b2 = Math.trunc(1000000 * b);\n    const result1 = a2 * b2;\n    const result2 = result1 / 1_000_000_000_000;\n    if (debugRealMath) {\n        console.log(\"    ---- realMul\", a2, b2);\n        console.log(\"    ---- realMul result1\", result1);\n        console.log(\"    ---- realMul result2\", result2);\n    }\n    return result2;\n}\n\n/**\n * Divides two numbers using integer math semantics for matching with Helios on-chain Real math\n *\n * @remarks\n * The numbers can be whole or fractional, with 6 decimal places of honored precision.\n * The result is rounded to 6 decimal places.\n * @todo - delegate this to a call into the on-chain version of same\n * @public\n */\nexport function realDiv(a: number, b: number) {\n    if (b === 0) {\n        throw new Error(\"Cannot divide by zero\");\n    }\n    const a2 = Math.trunc(1_000_000 * a);\n    const b2 = Math.trunc(1_000_000 * b);\n    const result1 = a2 / b;\n    // const result2 = toFixedReal(result1 / 1_000_000);\n    const result2 = Math.round(result1) / 1_000_000;\n    if (debugRealMath) {\n        console.log(\"    ---- realDiv\", a, \"/\", b);\n        console.log(\"    ---- realDiv\", a2);\n        console.log(\"    ---- realDiv result1\", result1);\n        console.log(\"    ---- realDiv result2\", result2);\n    }\n    return result2;\n}\n\n/**\n * Rounds a number to 6 decimal places, with correction for low-value floating-point\n * errors e.g. `(2.999999999) -> 3.0`\n * @public\n */\nexport function toFixedReal(n: number) {\n    return parseFloat((Math.floor(n * 1_000_000 + 0.1) / 1_000_000).toFixed(6));\n}\n/**\n * Temporarily enable debugRealMath for the duration of the callback\n * @internal\n */\nexport function debugMath<T extends number>(callback: () => T): T {\n    const old = debugRealMath;\n    debugRealMath = true;\n    const result = callback();\n    debugRealMath = old;\n    return result;\n}\n\nlet debugRealMath = false;\n\n\n\n/**\n * @public\n */\nexport class TxNotNeededError extends Error {\n    constructor(message: string) {\n        super(message);\n        this.name = \"TxAlreadyPresentError\";\n    }\n}\n\n/**\n * @public\n */\nexport class AlreadyPendingError extends TxNotNeededError {\n    constructor(message: string) {\n        super(message);\n        this.name = \"AlreadyPendingError\";\n    }\n}\n\n/**\n * @public\n */\nexport function checkValidUTF8(data: number[]) {\n  // quickly check, without throwing errors, for invalid UTF-8 sequences:\n  let i = 0;\n  while (i < data.length) {\n    if ((data[i] & 0x80) === 0x00) {\n      i++;\n    } else if ((data[i] & 0xE0) === 0xC0) {\n      if (i + 1 >= data.length || (data[i + 1] & 0xC0) !== 0x80) return false;\n      i += 2;\n    } else if ((data[i] & 0xF0) === 0xE0) {\n      if (i + 2 >= data.length || (data[i + 1] & 0xC0) !== 0x80 || (data[i + 2] & 0xC0) !== 0x80) return false;\n      i += 3\n    } else if ((data[i] & 0xF8) === 0xF0) {\n      if (i + 3 >= data.length || (data[i + 1] & 0xC0) !== 0x80 || (data[i + 2] & 0xC0) !== 0x80 || (data[i + 3] & 0xC0) !== 0x80) return false;\n      i += 4;\n    } else {\n      return false;\n    }\n  }\n  // if it didn't fail above, fine - but still defer to isValidUtf8.  it CAN throw (and catch) an error,\n  // but the above checks are much likelier to return false with NO caught error.\n  return isValidUtf8(data);\n}\n\nexport {colors} from \"./colors.js\"", "import type { CompileOptions } from \"@helios-lang/compiler\";\nimport type { InlineTxOutputDatum } from \"@helios-lang/ledger\";\nimport type { UplcProgramV2, UplcProgramV3 } from \"@helios-lang/uplc\";\n\n/**\n * @public\n */\nexport type CompileOptionsForCachedHeliosProgram = CompileOptions & {\n    /**\n     * The timeout for waiting for another instance to finish compiling.\n     * Defaults to 30 seconds.\n     */\n    timeout?: number;\n};\n\n/**\n * @public\n */\nexport type anyUplcProgram = UplcProgramV2 //| UplcProgramV3;\n\nexport { \n    encodeUtf8 as textToBytes,\n    decodeUtf8 as bytesToText,\n} from \"@helios-lang/codec-utils\";\n\n/**\n * tuple expressing a token-name and count\n * @public\n **/\nexport type tokenNamesOrValuesEntry = [string | number[], bigint];\n/**\n * Tuple of byte-array, count, needed for Value creation on native tokens.\n * @public\n **/\nexport type valuesEntry = [number[], bigint];\n\n/**\n * @public\n */\nexport type InlineDatum = InlineTxOutputDatum\n\n", "// local copy of picocolors.js\n// guards against supply chain attacks\n// original ISC license preserved:\n\n// ISC License\n\n// Copyright (c) 2021-2024 Oleksii Raspopov, Kostiantyn Denysov, Anton Verinov\n\n// Permission to use, copy, modify, and/or distribute this software for any\n// purpose with or without fee is hereby granted, provided that the above\n// copyright notice and this permission notice appear in all copies.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n\n\nlet p = process || {}, argv = p.argv || [], env = p.env || {}\nlet isColorSupported =\n\t!(!!env.NO_COLOR || argv.includes(\"--no-color\")) &&\n\t(!!env.FORCE_COLOR || argv.includes(\"--color\") || \n        p.platform === \"win32\" || \n        (\n            true \n        //  && (p.stdout || {}).isTTY \n        // && env.TERM !== \"dumb\"\n        ) || \n        !!env.CI\n        )\n\nlet formatter = (open, close, replace = open) => {\n    const f = (input) => {\n\t\tlet string = \"\" + input, index = string.indexOf(close, open.length)\n\t\treturn ~index ? open + replaceClose(string, close, replace, index) + close : open + string + close\n\t}\n    f.start = open\n    f.close = close\n    return f\n}\n\nlet replaceClose = (string, close, replace, index) => {\n\tlet result = \"\", cursor = 0\n\tdo {\n\t\tresult += string.substring(cursor, index) + replace\n\t\tcursor = index + close.length\n\t\tindex = string.indexOf(close, cursor)\n\t} while (~index)\n\treturn result + string.substring(cursor)\n}\n\nlet createColors = (enabled = isColorSupported) => {\n\tlet f = enabled ? formatter : () => String\n\treturn {\n\t\tisColorSupported: enabled,\n\t\treset: f(\"\\x1b[0m\", \"\\x1b[0m\"),\n\t\tbold: f(\"\\x1b[1m\", \"\\x1b[22m\", \"\\x1b[22m\\x1b[1m\"),\n\t\tdim: f(\"\\x1b[2m\", \"\\x1b[22m\", \"\\x1b[22m\\x1b[2m\"),\n\t\titalic: f(\"\\x1b[3m\", \"\\x1b[23m\"),\n\t\tunderline: f(\"\\x1b[4m\", \"\\x1b[24m\"),\n\t\tinverse: f(\"\\x1b[7m\", \"\\x1b[27m\"),\n\t\thidden: f(\"\\x1b[8m\", \"\\x1b[28m\"),\n\t\tstrikethrough: f(\"\\x1b[9m\", \"\\x1b[29m\"),\n\n\t\tblack: f(\"\\x1b[30m\", \"\\x1b[39m\"),\n\t\tred: f(\"\\x1b[31m\", \"\\x1b[39m\"),\n\t\tgreen: f(\"\\x1b[32m\", \"\\x1b[39m\"),\n\t\tyellow: f(\"\\x1b[33m\", \"\\x1b[39m\"),\n\t\tblue: f(\"\\x1b[34m\", \"\\x1b[39m\"),\n\t\tmagenta: f(\"\\x1b[35m\", \"\\x1b[39m\"),\n\t\tcyan: f(\"\\x1b[36m\", \"\\x1b[39m\"),\n\t\twhite: f(\"\\x1b[37m\", \"\\x1b[39m\"),\n\t\tgray: f(\"\\x1b[90m\", \"\\x1b[39m\"),\n\n\t\tbgBlack: f(\"\\x1b[40m\", \"\\x1b[49m\"),\n\t\tbgRed: f(\"\\x1b[41m\", \"\\x1b[49m\"),\n\t\tbgGreen: f(\"\\x1b[42m\", \"\\x1b[49m\"),\n\t\tbgYellow: f(\"\\x1b[43m\", \"\\x1b[49m\"),\n\t\tbgBlue: f(\"\\x1b[44m\", \"\\x1b[49m\"),\n\t\tbgMagenta: f(\"\\x1b[45m\", \"\\x1b[49m\"),\n\t\tbgCyan: f(\"\\x1b[46m\", \"\\x1b[49m\"),\n\t\tbgWhite: f(\"\\x1b[47m\", \"\\x1b[49m\"),\n\n\t\tblackBright: f(\"\\x1b[90m\", \"\\x1b[39m\"),\n\t\tredBright: f(\"\\x1b[91m\", \"\\x1b[39m\"),\n\t\tgreenBright: f(\"\\x1b[92m\", \"\\x1b[39m\"),\n\t\tyellowBright: f(\"\\x1b[93m\", \"\\x1b[39m\"),\n\t\tblueBright: f(\"\\x1b[94m\", \"\\x1b[39m\"),\n\t\tmagentaBright: f(\"\\x1b[95m\", \"\\x1b[39m\"),\n\t\tcyanBright: f(\"\\x1b[96m\", \"\\x1b[39m\"),\n\t\twhiteBright: f(\"\\x1b[97m\", \"\\x1b[39m\"),\n\n\t\tbgBlackBright: f(\"\\x1b[100m\", \"\\x1b[49m\"),\n\t\tbgRedBright: f(\"\\x1b[101m\", \"\\x1b[49m\"),\n\t\tbgGreenBright: f(\"\\x1b[102m\", \"\\x1b[49m\"),\n\t\tbgYellowBright: f(\"\\x1b[103m\", \"\\x1b[49m\"),\n\t\tbgBlueBright: f(\"\\x1b[104m\", \"\\x1b[49m\"),\n\t\tbgMagentaBright: f(\"\\x1b[105m\", \"\\x1b[49m\"),\n\t\tbgCyanBright: f(\"\\x1b[106m\", \"\\x1b[49m\"),\n\t\tbgWhiteBright: f(\"\\x1b[107m\", \"\\x1b[49m\"),\n\t} as any\n}\n\n/**\n * @public\n */\nexport const colors : Colors = createColors()\n\n\n/**\n * @public\n */\nexport type Formatter = {\n    start: string;\n    end: string;\n} & ((input: string | number | null | undefined) => string);\n\n/**\n * @public\n */\nexport interface Colors {\n    isColorSupported: boolean;\n\n    reset: Formatter;\n    bold: Formatter;\n    dim: Formatter;\n    italic: Formatter;\n    underline: Formatter;\n    inverse: Formatter;\n    hidden: Formatter;\n    strikethrough: Formatter;\n\n    black: Formatter;\n    red: Formatter;\n    green: Formatter;\n    yellow: Formatter;\n    blue: Formatter;\n    magenta: Formatter;\n    cyan: Formatter;\n    white: Formatter;\n    gray: Formatter;\n\n    bgBlack: Formatter;\n    bgRed: Formatter;\n    bgGreen: Formatter;\n    bgYellow: Formatter;\n    bgBlue: Formatter;\n    bgMagenta: Formatter;\n    bgCyan: Formatter;\n    bgWhite: Formatter;\n\n    blackBright: Formatter;\n    redBright: Formatter;\n    greenBright: Formatter;\n    yellowBright: Formatter;\n    blueBright: Formatter;\n    magentaBright: Formatter;\n    cyanBright: Formatter;\n    whiteBright: Formatter;\n\n    bgBlackBright: Formatter;\n    bgRedBright: Formatter;\n    bgGreenBright: Formatter;\n    bgYellowBright: Formatter;\n    bgBlueBright: Formatter;\n    bgMagentaBright: Formatter;\n    bgCyanBright: Formatter;\n    bgWhiteBright: Formatter;\n}\n\n", "import { existsSync, readFileSync, writeFileSync } from \"fs\";\nimport path from \"path\";\nimport type { HeliosScriptBundle } from \"../scriptBundling/HeliosScriptBundle.js\";\nimport type { UplcData } from \"@helios-lang/uplc\";\nimport { BundleTypeGenerator } from \"../dataBridge/BundleTypeGenerator.js\";\nimport { dataBridgeGenerator } from \"../dataBridge/dataBridgeGenerator.js\";\nimport type { CapoHeliosBundle } from \"../scriptBundling/CapoHeliosBundle.js\";\nimport { mkCancellablePromise } from \"../../networkClients/mkCancellablePromise.js\";\nimport { environment } from \"../../environment.js\";\n// import {CapoHeliosBundle} from \"../CapoHeliosBundle.js\";\n\nconst startTime = Date.now();\n\ntype BundleStatusEntry = {\n    filename: string;\n    status: \"registering\" | \"pendingLoad\" | \"loaded\";\n    bundleClassName: string;\n    parentClassName?: string;\n    bundleClass?: typeof HeliosScriptBundle; // or a subclass\n    bundle?: HeliosScriptBundle;\n};\n\nexport function isUplcData(x: any): x is UplcData {\n    return \"kind\" in x && \"toCbor\" in x;\n}\n\n/**\n * Gathers `*.hlb.[tj]s` files along with their status and attributes.\n * @public\n * @remarks\n * For script bundles that have previously been loaded, the project will\n * have access to the bundle's type information, and  be able to\n * instantiate the bundle, given a CapoBundle that typically provides\n * library dependencies.\n *\n * For script bundles that are being loaded for the first time, the project\n * can generate a \"placeholder\" type-definition, to be updated once the\n * bundle has been transformed by the helios rollup loader to be able to\n * do the above.\n */\nexport class StellarHeliosProject {\n    static details: {\n        projectRoot: string;\n        packageJSON: {\n            name: string;\n            version: string;\n            dependencies: Record<string, string>;\n            devDependencies: Record<string, string>;\n        };\n    };\n    configuredCapo = mkCancellablePromise<CapoHeliosBundle>();\n    bundleEntries: Map<string, BundleStatusEntry>;\n    capoBundleName?: string;\n    capoBundle: CapoHeliosBundle | undefined = undefined;\n    constructor() {\n        this.bundleEntries = new Map();\n        const { projectRoot, packageJSON } =\n            StellarHeliosProject.findProjectDetails();\n\n        this._isSC = packageJSON.name === \"@donecollectively/stellar-contracts\";\n    }\n\n    _isSC: boolean | undefined;\n\n    isStellarContracts() {\n        return this._isSC;\n    }\n    get projectRoot() {\n        return StellarHeliosProject.details.projectRoot;\n    }\n\n    replaceWithNewCapo(\n        absoluteFilename: string,\n        newCapoClass: typeof HeliosScriptBundle\n    ) {\n        throw new Error(`dead code?!?!`);\n        const replacement = new StellarHeliosProject();\n        replacement.loadBundleWithClass(absoluteFilename, newCapoClass);\n        replacement.generateBundleTypes(absoluteFilename);\n        for (const [filename, entry] of this.bundleEntries.entries()) {\n            if (!entry.bundleClass?.isCapoBundle) {\n                replacement.loadBundleWithClass(filename, entry.bundleClass!);\n                replacement.generateBundleTypes(filename);\n            }\n        }\n        return replacement;\n    }\n\n    // call from code-generated hlproject.mjs with instantiated bundle\n    // call from rollup plugin with bundle filename\n    loadBundleWithClass(\n        absoluteFilename: string,\n        bundleClass: typeof HeliosScriptBundle,\n        harmlessSecondCapo: boolean = false\n    ) {\n        if (harmlessSecondCapo) {\n            throw new Error(\"deprecated use of arg3 'harmlessSecondCapo'\");\n        }\n        // if the file location is within the project root, make it relative\n        // otherwise, use the absolute path\n        const filename = absoluteFilename.startsWith(this.projectRoot)\n            ? path.relative(this.projectRoot, absoluteFilename)\n            : absoluteFilename;\n\n        if (filename.startsWith(\"/\")) debugger;\n        const bundleClassName = bundleClass.name;\n\n        // we need to do rollup on the project before we'll ever hit this path\n        let bundle: HeliosScriptBundle | undefined;\n        // if the bundle has a CapoBundle, use it\n        // searches the bundle class hierarchy for the presence of a class named CapoHeliosBundle.\n        let isCapoBundle = bundleClass.isCapoBundle;\n        let proto = bundleClass.prototype;\n        let parentClassName = \"\";\n        while (proto) {\n            const thisClassName = proto.constructor.name;\n            if (!parentClassName && bundleClassName !== thisClassName) {\n                parentClassName = proto.constructor.name;\n                break;\n            }\n            proto = Object.getPrototypeOf(proto);\n        }\n\n        if (isCapoBundle && !harmlessSecondCapo) {\n            if (this.capoBundle) {\n                throw new Error(`only one CapoBundle is currently supported`);\n            }\n            // console.log(`Project: loading CapoBundle ${bundleClassName}`);\n            this.capoBundle = new (bundleClass as any)({\n                setup: { isMainnet: false },\n            });\n            const registeredCapoName = bundleClass.name;\n            if (this.bundleEntries.size > 0) {\n                // debugger\n                for (const [filename, entry] of this.bundleEntries.entries()) {\n                    const thatCapoName =\n                        entry.bundle?.capoBundle?.constructor.name;\n                    if (thatCapoName !== registeredCapoName) {\n                        console.log(\"new capo bundle is \" + registeredCapoName);\n                        console.log(\n                            \"pre-registered bundle uses capo \" + thatCapoName\n                        );\n                        throw new Error(\n                            `mismatched capo bundle for ${filename} (see details above)`\n                        );\n                    }\n                }\n                // throw new Error(`register capo first!! ??`);\n                // update any pending bundles with an instantiated\n                // bundle including the newly-discovered CapoBundle\n                // for (const filename of this.bundleEntries.keys()) {\n                //     const entry = this.bundleEntries.get(filename);\n                //     if (entry?.status !== \"pendingLoad\") {\n                //         throw new Error(`unexpected status: ${entry?.status}`);\n                //     }\n                //     const bundleClass = entry.bundleClass;\n                //     if (!bundleClass) {\n                //         throw new Error(\n                //             `no bundleClass for entry with status '${entry?.status}': ${filename}`\n                //         );\n                //     }\n                //     console.log(\"finishing pending load for\", filename);\n                //     entry.bundle = new (bundleClass as any)(this.capoBundle);\n                //     entry.status = \"loaded\";\n                // }\n            }\n            this.bundleEntries.set(filename, {\n                filename,\n                status: \"loaded\",\n                bundle: this.capoBundle,\n                bundleClassName: bundleClassName,\n                parentClassName,\n                bundleClass,\n            });\n        } else if (isCapoBundle && harmlessSecondCapo) {\n            throw new Error(\"dead code path\");\n            console.log(`Project: loading CapoBundle ${bundleClassName}`);\n            console.log(\n                `  (replaces existing capo ${this.capoBundle?.constructor.name})`\n            );\n            debugger;\n            this.bundleEntries.set(filename, {\n                filename,\n                status: \"loaded\",\n                bundle: new (bundleClass as any)({\n                    setup: { isMainnet: false },\n                }), // harmless second capo\n                bundleClassName: bundleClassName,\n                parentClassName,\n                bundleClass,\n            });\n        } else {\n            const bundleEntry: BundleStatusEntry = {\n                filename,\n                status: \"registering\", // overwritten below, one way or other\n                bundleClass,\n                bundleClassName: bundleClassName,\n                parentClassName,\n            };\n            bundle = new (bundleClass as any)({ setup: { isMainnet: false } });\n            bundleEntry.bundle = bundle;\n            bundleEntry.status = \"loaded\";\n            this.bundleEntries.set(filename, bundleEntry);\n        }\n\n        // this.bundleEntries.set(filename, { filename, bundle, types, importName });\n    }\n\n    hasBundleClass(filename: string) {\n        if (this.bundleEntries.has(filename)) {\n            return this.bundleEntries.get(filename)?.bundle !== undefined;\n        }\n        if (filename.startsWith(this.projectRoot)) {\n            const relativeFilename = path.relative(this.projectRoot, filename);\n            return this.hasBundleClass(\"./\" + relativeFilename);\n        }\n        console.log(\n            `helios project: no bundle yet for ${filename}\\n` +\n                `${[...this.bundleEntries.keys()]\n                    .map((k) => `  - ${k}`)\n                    .join(\"\\n\")}`\n        );\n    }\n\n    generateBundleTypes(oneFile: string) {\n        const fn = this.normalizeFilePath(oneFile);\n        const bundleEntry = this.bundleEntries.get(fn);\n        if (!bundleEntry) {\n            throw new Error(`bundle not found: ${fn}`);\n        }\n        this.writeTypeInfo(oneFile, bundleEntry);\n        this.writeDataBridgeCode(\n            oneFile.replace(/(\\.hlb)?\\.[tj]s$/, \".bridge.ts\"),\n            bundleEntry\n        );\n\n        // this.writeReadDatabridge(\n        //     oneFile.replace(/\\.hlb\\.[tj]s$/, \".readData.ts\"),\n        //     bundleEntry\n        // );\n\n        // throw new Error(`don't use omnibus generation anymore!`);\n\n        // // for each bundle, generate the types\n        // for (const filename of this.bundleEntries.keys()) {\n        //     if (oneFile && oneFile !== filename) continue;\n        //     this.writeTypeInfo(filename);\n        // }\n    }\n\n    // uses the dataBridgeGenerator class to generate a *.bridge.ts file\n    writeDataBridgeCode(oneFilename: string, bundleEntry: BundleStatusEntry) {\n        const fn = this.normalizeFilePath(oneFilename);\n        const dataBridgeFn = fn.replace(/\\.hlb\\.[jt]s$/, \".bridge.ts\");\n\n        const bundle = bundleEntry.bundle;\n        const status = bundleEntry.status;\n        if (!bundle) {\n            console.warn(\n                `not writing data bridge for ${fn} for newly-added bundle (check for hasBundleClass() first?)`\n            );\n            return;\n        }\n        if (status !== \"loaded\") {\n            throw new Error(\n                `cannot generate data bridge for ${fn} with status ${status}`\n            );\n        }\n        const ts1 = Date.now();\n        // console.log(\"writing data bridge code: \", bundle.moduleName);\n        const bridgeGenerator = dataBridgeGenerator.create(bundle);\n        if (this.isStellarContracts()) {\n            if (dataBridgeFn.match(/\\b(testing|tests)\\//)) {\n                console.log(\n                    `   ------- from testing package or tests: ${dataBridgeFn} -- uses @donecollectively/stellar-contracts for imports`\n                );\n            } else {\n                bridgeGenerator._isInStellarContractsLib(true);\n            }\n        }\n        const bridgeSourceCode = this.isStellarContracts()\n            ? bridgeGenerator.generateDataBridge(fn, \"stellar-contracts\")\n            : bridgeGenerator.generateDataBridge(fn);\n        if (this.writeIfUnchanged(dataBridgeFn, bridgeSourceCode)) {\n            console.log(\n                `\uD83D\uDCE6 ${bundle.moduleName}: create/update data bridge: ${\n                    Date.now() - ts1\n                }ms`\n            );\n        }\n    }\n\n    writeIfUnchanged(filename: string, source: string) {\n        if (existsSync(filename)) {\n            const existingSource = readFileSync(filename, \"utf-8\");\n            if (existingSource === source) {\n                environment.DEBUG && console.log(`   -- unchanged: ${filename}`);\n                return;\n            }\n        }\n        writeFileSync(filename, source);\n        return source;\n    }\n\n    normalizeFilePath(filename: string) {\n        const fn = filename.startsWith(this.projectRoot)\n            ? path.relative(this.projectRoot, filename)\n            : filename;\n\n        if (fn.startsWith(\"/\")) debugger;\n        // console.log(\"normalizedFilePath: \", fn);\n        return fn;\n    }\n\n    writeTypeInfo(filename: string, bundleEntry: BundleStatusEntry) {\n        const fn = this.normalizeFilePath(filename);\n        const bundle = bundleEntry.bundle;\n        const status = bundleEntry.status;\n\n        if (!bundle) {\n            console.warn(\n                `not writing type info for ${filename} for newly-added bundle (check for hasBundleClass() first?)`\n            );\n            return;\n        }\n        if (status !== \"loaded\") {\n            throw new Error(\n                `cannot generate types for ${filename} with status ${status}`\n            );\n        }\n\n        let typeFilename = filename.replace(/(\\.hlb)?\\.[jt]s$/, \".typeInfo.d.ts\");\n        const { bundleClassName, parentClassName } = bundleEntry;\n\n        if (!parentClassName) {\n            throw new Error(`no parent class name for ${filename}`);\n        }\n\n        const ts1 = Date.now();\n        const typeContext = BundleTypeGenerator.create(bundle);\n        if (this.isStellarContracts()) {\n            if (filename.match(/\\b(testing|tests)\\//)) {\n                console.log(\n                    `   ------- from testing package or tests: ${filename} -- uses @donecollectively/stellar-contracts for imports`\n                );\n            } else {\n                typeContext._isInStellarContractsLib(true);\n            }\n        }\n\n        const typesSource = typeContext.createAllTypesSource(\n            bundleClassName,\n            parentClassName,\n            typeFilename\n        );\n        // console.log(\"not writing type info yet:\", {\n        //     filename,\n        //     typeFilename,\n        // });\n        // return\n\n        if (this.writeIfUnchanged(typeFilename, typesSource)) {\n            console.log(\n                `\uD83D\uDCE6 ${bundleClassName}: generated types (${Date.now() - ts1}ms)`\n            );\n        }\n    }\n\n    static findProjectDetails() {\n        if (this.details) return this.details;\n\n        const cwd = process.cwd();\n        let dir = cwd;\n        let found = false;\n        let packageJSON = {} as any;\n        while (!found) {\n            const fileName = path.join(dir, \"package.json\");\n            if (existsSync(fileName)) {\n                found = true;\n                packageJSON = JSON.parse(readFileSync(fileName, \"utf-8\"));\n            } else {\n                const parent = path.dirname(dir);\n                if (parent === dir) {\n                    throw new Error(\n                        `could not find package.json in ${cwd} or any parent directories`\n                    );\n                }\n                dir = parent;\n            }\n        }\n        console.log(\n            `\uD83D\uDCE6 StellarHeliosProject: found project root at ${dir}: ${packageJSON.name}`\n        );\n        this.details = {\n            packageJSON,\n            projectRoot: dir,\n        };\n        return this.details;\n    }\n}\n\nfunction ts() {\n    return Date.now() - startTime;\n}\n", "import { genTypes } from \"@helios-lang/contract-utils\";\nimport type {\n    HeliosScriptBundle,\n} from \"../scriptBundling/HeliosScriptBundle.js\";\nimport type {\n    anyTypeDetails,\n    EnumId,\n    EnumTypeMeta,\n    enumTypeDetails,\n    HeliosBundleTypeDetails,\n    HeliosBundleTypes, \n    makesUplcActivityEnumData,\n    singleEnumVariantMeta,\n    typeDetails,\n    TypeVariety,\n    VariantFlavor,\n    variantTypeDetails\n} from \"../HeliosMetaTypes.js\";\nimport type {\n    EnumTypeSchema,\n    VariantTypeSchema,\n    TypeSchema\n} from \"@helios-lang/type-utils\";\nimport type { DataType, EnumMemberType } from \"@helios-lang/compiler\";\n\nexport interface TypeGenHooks<T> {\n    registerNamedType?(details: anyTypeDetails): void;\n    getMoreEnumInfo?(details: enumTypeDetails): T;\n    getMoreStructInfo?(details: typeDetails): T;\n    getMoreVariantInfo?(details: variantTypeDetails): T;\n    getMoreTypeInfo?(details: typeDetails): T;\n}\n\n/**\n * Gathers any number of types expressible for an on-chain Helios script,\n * and generates types and type aliases for the off-chain TypeScript context.\n *\n * Each struct type is directly expressed as its name\n * Each enum type is expressed as a proxy type, unioned with the possible raw enum variants for that type\n * As each type is encountered (as a **nested field** within a datum or redeemer), any named types encountered\n * are added to the context, with any recursive expansions generated and added to the context, depth-first,\n * ... then the named type is used for the **nested field** where it was encountered.\n */\nexport class BundleTypes implements TypeGenHooks<undefined> {\n    topLevelTypeDetails: HeliosBundleTypeDetails;\n    topLevelDataTypes: HeliosBundleTypes;\n    namedTypes: Record<string, anyTypeDetails> = {};\n\n    constructor(\n        public bundle: HeliosScriptBundle,\n        public collaborator?: TypeGenHooks<any>\n    ) {\n        this.namedTypes = {};\n        const dataTypes = (this.topLevelDataTypes =\n            this.bundle.getTopLevelTypes());\n        this.topLevelTypeDetails = this.gatherTopLevelTypeDetails(dataTypes);\n    }\n\n    get activityTypeDetails(): anyTypeDetails {\n        return this.topLevelTypeDetails.redeemer;\n    }\n\n    get datumTypeDetails(): anyTypeDetails | undefined {\n        return this.topLevelTypeDetails.datum;\n    }\n\n    // it can begin gathering the types from the bundle's main contract\n    // this has a side-effect of adding all nested named types to the context\n    gatherTopLevelTypeDetails(\n        dataTypes: HeliosBundleTypes\n    ): HeliosBundleTypeDetails {\n        const {datum, redeemer, ...others} = dataTypes;\n        const typeDetails = {\n            datum: datum\n                ? this.gatherTypeDetails(datum)\n                : undefined,\n            redeemer: this.gatherTypeDetails(redeemer),\n        };\n\n        for (const [typeName, dataType] of Object.entries(others)) {\n            this.gatherTypeDetails(dataType as DataType);\n        }\n\n        return typeDetails\n    }\n\n    gatherTypeDetails(\n        type: DataType,\n        useTypeNamesAt?: \"nestedField\"\n    ): anyTypeDetails {\n        const schema = type.toSchema();\n        if (schema.kind === \"enum\") {\n            return this.gatherEnumDetails(type as any, useTypeNamesAt);\n        } else {\n            return this.gatherOtherTypeDetails(type, useTypeNamesAt);\n        }\n    }\n\n    /**\n     * type-gen interface: registers a named type in the context\n     */\n    registerNamedType(details: anyTypeDetails) {\n        const {\n            //@ts-expect-error - some schemas don't have a name, but anything here does.\n            typeSchema: { name },\n            canonicalTypeName,\n        } = details;\n        const useTypeName = canonicalTypeName || name;\n        if (!this.namedTypes[useTypeName]) {\n            this.namedTypes[useTypeName] = details;\n        } else {\n            // console.log(\"No need to re-register type:\", useTypeName, \"(right?)\");\n            // right!\n        }\n    }\n\n    private extractModuleName(id: string) {\n        return id.replace(/__module__(\\w+)?__.*$/, \"$1\");\n    }\n\n    private extractVariantParentName(id: string) {\n        // given input \"__module__CapoHelpers__CapoDatum[]__CharterData\",\n        //   ... returns \"CapoDatum\", not \"CapoHelpers\"\n        return id.replace(/__module__(\\w+)?__(\\w+)?\\[\\]__.*/, \"$2\");\n    }\n\n    gatherOtherTypeDetails(\n        dataType: DataType,\n        useTypeNamesAt?: \"nestedField\"\n    ): typeDetails {\n        // gathers names for any nested types, then generates minimal types\n        // based on having those names registered in the context.\n        let typeName: string | undefined = undefined;\n        const schema = dataType.toSchema();\n        if (schema.kind === \"enum\") {\n            throw new Error(\n                \"must not call gatherNonEnumTypeInfo with an enum schema\"\n            );\n        }\n        if (\"internal\" != schema.kind && \"name\" in schema) {\n            typeName = schema.name;\n        }\n\n        let parentNameMaybe : string | undefined = undefined;\n        // gather nested types where applicable, so they are added to the context.\n        switch (schema.kind) {\n            case \"internal\":\n                // built-in data types don't need to be registered in the type context\n                break;\n            case \"reference\":\n            case \"tuple\":\n                console.log(\n                    \"Not registering nested types for (as-yet unsupported)\",\n                    schema.kind\n                );\n                break;\n            case \"list\":\n                this.gatherTypeDetails((dataType as any)._types[0]);\n                // this.gatherTypeDetails(type.itemType);\n                break;\n            case \"map\":\n                this.gatherTypeDetails((dataType as any)._types[0]);\n                this.gatherTypeDetails((dataType as any)._types[1]);\n            case \"option\":\n                this.gatherTypeDetails((dataType as any)._types[0]);\n                break;\n            case \"struct\":\n                for (const field of dataType.fieldNames) {\n                    this.gatherTypeDetails(\n                        dataType.instanceMembers[field].asDataType!,\n                        \"nestedField\"\n                    );\n                }\n                break;\n            case \"variant\":\n                // we only hit this case when a nested variant is encountered\n                //   as a field of some other data structure, where only that specific variant-type\n                //   is expected.  When iterating the variants defined in an enum type,\n                //   gatherEnumDetails() calls gatherVariantDetails(), but when this path\n                //   is hit, we may need to gather those enum details separately.\n                // if (schema.name == \"CharterData\")\n                //     debugger;\n\n                const vType = dataType as EnumMemberType;\n                parentNameMaybe = vType.parentType.name;\n                return this.gatherVariantDetails(\n                    vType as any,\n                    { \n                        module:  this.extractModuleName(schema.id),\n                        enumName: vType.parentType.name\n                    }\n                );\n                break;\n            default:\n                //@ts-expect-error - when all cases are covered, schema is \u2039never\u203A\n                throw new Error(`Unsupported schema kind: ${schema.kind}`);\n        }\n\n        const canonType = this.mkMinimalType(\"canonical\", schema, undefined, parentNameMaybe);\n        const ergoType = this.mkMinimalType(\"ergonomic\", schema, undefined, parentNameMaybe);\n        const details: typeDetails<any> = {\n            typeSchema: schema,\n            typeName,\n            dataType,\n            canonicalType: canonType,\n            ergoCanonicalType:\n                ergoType == canonType\n                    ? typeName\n                        ? `${typeName}/*like canon-other*/`\n                        : ergoType\n                    : ergoType,\n            permissiveType: this.mkMinimalType(\"permissive\", schema, undefined, parentNameMaybe),\n            moreInfo: undefined,\n        };\n        // if (schema.kind !== \"internal\") debugger\n        // if (schema.kind === \"struct\") debugger\n        if (typeName) {\n            details.canonicalTypeName = typeName;\n            details.ergoCanonicalTypeName = `Ergo${typeName}`;\n            details.permissiveTypeName = `${typeName}Like`;\n            this.registerNamedType(details);\n            const moreInfo =\n                schema.kind == \"struct\"\n                    ? this.collaborator?.getMoreStructInfo?.(details)\n                    : this.collaborator?.getMoreTypeInfo?.(details);\n            if (moreInfo) details.moreInfo = moreInfo;\n            this.collaborator?.registerNamedType?.(details);\n        }\n        return details;\n    }\n\n    gatherEnumDetails(\n        enumType: { toSchema(): EnumTypeSchema } & DataType,\n        useTypeNamesAt?: \"nestedField\"\n    ): enumTypeDetails {\n        // gathers names for any nested types, then generates minimal types\n        // based on having those names registered in the context.\n        const schema = enumType.toSchema();\n        const enumName = schema.name;\n        const module = this.extractModuleName(schema.id);\n        // at type-gen time, we don't need this to be a fully-typed VariantMap.\n        //  ... a lookup record is fine.\n        const variants: Record<string, variantTypeDetails> = {};\n        for (const member of schema.variantTypes) {\n            const memberType =\n                enumType.typeMembers[member.name].asEnumMemberType;\n            if (!memberType) {\n                throw new Error(\n                    `Enum member type for ${member.name} not found`\n                );\n            }\n            variants[member.name] = this.gatherVariantDetails(\n                memberType as any,\n                { module, enumName }\n            );\n        }\n\n        if (useTypeNamesAt) {\n            // this happens when the enum is a nested field of a struct or variant\n            // console.log(\"enum\", enumName, \"is used as a nested field, and that's okay!\");\n            // it's fine to have this useTypeNames hint coming in, but we don't want\n            // to use the type-name when registering the enum itself; see \"XXX\" comments below.\n        }\n\n        const canonType = this.mkMinimalType(\"canonical\", schema);\n        const ergoType = this.mkMinimalType(\"ergonomic\", schema);\n        const details: enumTypeDetails<any> = {\n            enumName: schema.name,\n            dataType: enumType,\n            typeSchema: schema,\n            variants,\n            canonicalTypeName: `${enumName}`,\n            ergoCanonicalTypeName: `Ergo${enumName}`,\n            permissiveTypeName: `${enumName}Like`,\n            canonicalMetaType: this.mkMinimalEnumMetaType(\"canonical\", schema),\n            permissiveMetaType: this.mkMinimalEnumMetaType(\n                \"permissive\",\n                schema\n            ),\n            canonicalType: canonType,\n            ergoCanonicalType:\n                ergoType == canonType\n                    ? `${enumName}/*like canon enum*/`\n                    : ergoType,\n            permissiveType: this.mkMinimalType(\n                \"permissive\",\n                schema\n                // XXX here, we always want to register the true type of the enum, not the type-name\n                // XXX useTypeNamesAt\n            ),\n            moreInfo: undefined,\n        };\n        this.registerNamedType(details);\n        const moreInfo = this.collaborator?.getMoreEnumInfo?.(details);\n        if (moreInfo) details.moreInfo = moreInfo;\n        this.collaborator?.registerNamedType?.(details);\n\n        return details;\n    }\n\n    gatherVariantDetails(\n        variantDataType: { toSchema(): VariantTypeSchema } & EnumMemberType,\n        enumId: EnumId\n    ): variantTypeDetails {\n        if (!variantDataType.toSchema) debugger;\n        const schema = variantDataType.toSchema();\n\n        // console.log(\"Enum-variant name: \" + schema.name);\n        if (schema.kind !== \"variant\") {\n            throw new Error(\n                \"Must not call gatherVariantTypeInfo with a non-variant schema\"\n            );\n        }\n        const fieldCount = schema.fieldTypes.length;\n        const fields = {};\n\n        // uses dataType.fieldNames and dataType.instanceMembers to gather the fields\n        for (const fieldName of variantDataType.fieldNames) {\n            const fieldMember = variantDataType.instanceMembers[fieldName];\n            if (!fieldMember) {\n                throw new Error(`Field member ${fieldName} not found`);\n            }\n            fields[fieldName] = this.gatherTypeDetails(fieldMember.asDataType!);\n        }\n\n        const variantName = schema.name;\n        const canonicalTypeName =\n            fieldCount > 0 ? `${enumId.enumName}$${variantName}` : \"tagOnly\";\n        const permissiveTypeName =\n            fieldCount > 0\n                ? `${enumId.enumName}$${variantName}Like`\n                : \"tagOnly\";\n        const canonType = this.mkMinimalType(\n            \"canonical\",\n            schema,\n            undefined,\n            enumId.enumName\n        );\n        const ergoType = this.mkMinimalType(\n            \"ergonomic\",\n            schema,\n            undefined,\n            enumId.enumName\n        );\n        const details: variantTypeDetails<any> = {\n            fields,\n            fieldCount: fieldCount,\n            variantName: variantName,\n            typeSchema: schema,\n            dataType: variantDataType,\n            canonicalTypeName,\n            ergoCanonicalTypeName: `${enumId.enumName}$Ergo$${variantName}`,\n            permissiveTypeName,\n            canonicalType: canonType,\n            ergoCanonicalType:\n                ergoType == canonType\n                    ? `${enumId.enumName}$${variantName}  /*ergo like-canonical-this-variant*/`\n                    : ergoType,\n            permissiveType: this.mkMinimalType(\n                \"permissive\",\n                schema,\n                undefined,\n                enumId.enumName\n            ),\n            canonicalMetaType: this.mkMinimalVariantMetaType(\n                \"canonical\",\n                schema,\n                enumId\n            ), //, \"nestedField\"),\n            permissiveMetaType: this.mkMinimalVariantMetaType(\n                \"permissive\",\n                schema,\n                enumId\n            ), //, \"nestedField\"),\n            moreInfo: undefined,\n        };\n        if (this.collaborator) {\n            const moreInfo = this.collaborator.getMoreVariantInfo?.(details);\n            details.moreInfo = moreInfo;\n        }\n        if (fieldCount == 1) {\n            // debugger\n        }\n\n        // don't register named types for tagOnly variants; worthless indirection\n        if (fieldCount > 1) {\n            this.registerNamedType(details);\n            this.collaborator?.registerNamedType?.(details);\n        }\n\n        // the enum itself is registered, and we don't need the variants registered separately.\n        // this.collaborator?.registerNamedType?.(details);\n        return details;\n    }\n\n    mkMinimalType(\n        typeVariety: TypeVariety,\n        schema: TypeSchema,\n        useTypeNamesAt?: \"nestedField\",\n        parentName?: string\n    ): string {\n        // uses the canonical underlying type for \"ergonomic\" versions of internal types\n        const varietyIndex = typeVariety === \"permissive\" ? 1 : 0;\n        //@ts-expect-error - not every schema-type has a name\n        let name = schema.name as string | undefined;\n        let nameLikeOrName = name;\n        let $nameLike = name ? `${name}Like` : undefined;\n\n        // switch on each schema kind...\n        switch (schema.kind) {\n            case \"internal\":\n                // use genType directly to return the indicated type\n                return genTypes(schema)[varietyIndex];\n            case \"reference\":\n                throw new Error(\"References are not yet supported\");\n            case \"tuple\":\n                throw new Error(\"Tuples are not yet supported\");\n            case \"list\":\n                return `Array<${this.mkMinimalType(\n                    typeVariety,\n                    schema.itemType,\n                    \"nestedField\"\n                )}>`;\n            case \"map\":\n                // todo: support string keys with simpler Record<string, ...> type\n                return `Map<${this.mkMinimalType(\n                    typeVariety,\n                    schema.keyType,\n                    \"nestedField\"\n                )}, ${this.mkMinimalType(\n                    typeVariety,\n                    schema.valueType,\n                    \"nestedField\"\n                )}>`;\n            case \"option\":\n                return `${this.mkMinimalType(\n                    typeVariety,\n                    schema.someType,\n                    useTypeNamesAt\n                )} | undefined`;\n            case \"struct\":\n                if (typeVariety === \"permissive\") {\n                    nameLikeOrName = $nameLike;\n                } else if (typeVariety === \"ergonomic\") {\n                    nameLikeOrName = `Ergo${name}`;\n                }\n                if (useTypeNamesAt) return nameLikeOrName as string;\n\n                return `{\\n${schema.fieldTypes\n                    .map(\n                        (field) =>\n                            `    ${\n                                field.name\n                            }: /*minStructField*/ ${this.mkMinimalType(\n                                typeVariety,\n                                field.type,\n                                \"nestedField\"\n                            )}`\n                    )\n                    .join(\"\\n\")}\\n}\\n`;\n            case \"enum\":\n                if (typeVariety === \"permissive\") {\n                    nameLikeOrName = $nameLike; // `IntersectedEnum<${$nameLike}>`;\n                } else if (typeVariety === \"ergonomic\") {\n                    nameLikeOrName = `Ergo${name}`;\n                }\n                if (useTypeNamesAt) return nameLikeOrName as string;\n\n                const module = this.extractModuleName(schema.id);\n                const enumId: EnumId = { module, enumName: name! };\n\n                return schema.variantTypes\n                    .map((variant) => {\n                        return `\\n        | { ${\n                            variant.name\n                        }: ${this.mkMinimalType(\n                            typeVariety,\n                            variant,\n                            \"nestedField\",\n                            enumId.enumName\n                        )} /*minEnumVariant*/ }`;\n                    })\n                    .join(\"\") + \"\\n\";\n\n            case \"variant\":\n                if (!parentName) {\n                    parentName = this.extractVariantParentName(schema.id);\n                }\n\n                const variantInfo = this.mkMinimalVariantType(\n                    schema,\n                    typeVariety,\n                    parentName\n                );\n                if (variantInfo === \"tagOnly\") return variantInfo;\n                if (Array.isArray(variantInfo)) {\n                    const fullVariantName = `${parentName}$${name}`;\n                    if (typeVariety === \"permissive\") {\n                        nameLikeOrName = `${parentName}$${$nameLike}`;\n                    } else if (typeVariety === \"ergonomic\") {\n                        // todo maybe; it will tend to shrink the type output size\n                        //  -- the issue is, the type info isn't necessarily available yet\n                        //  -- might need to use a two-pass process, gathering type info first\n\n                        // const thisType = this.namedTypes[fullVariantName];\n                        // if (!thisType) {\n                        //     debugger\n                        //     throw new Error(`No named type found for ${fullVariantName}`);\n                        // }\n                        // nameLikeOrName = thisType.canonicalType == thisType.ergoCanonicalType ?\n                        //     `${parentName}$${name} /*same as $Ergo$ variant*/` :\n                        nameLikeOrName = `${parentName}$Ergo$${name}`;\n                    } else {\n                        nameLikeOrName = fullVariantName;\n                    }\n                    if (useTypeNamesAt) return nameLikeOrName;\n\n                    return `{${variantInfo.join(`,`)}\\n` + `}\\n`;\n                } else {\n                    // variant only has one field\n\n                    return `/* implied wrapper { ${schema.fieldTypes[0].name}: ... } for singleVariantField */ \\n\\t\\t\\t${variantInfo}   `;\n                }\n            default:\n                //@ts-expect-error - when all cases are covered, schema is \u2039never\u203A\n                throw new Error(`Unsupported schema kind: ${schema.kind}`);\n        }\n    }\n\n    mkMinimalEnumMetaType(typeVariety: TypeVariety, schema: EnumTypeSchema) {\n        const name = schema.name;\n\n        const module = this.extractModuleName(schema.id);\n        const enumId: EnumId = { module, enumName: name! };\n        const $enumId = `{module: \"${enumId.module}\", enumName: \"${enumId.enumName}\"}`;\n\n        return `EnumTypeMeta<\\n    ${$enumId}, {\\n${schema.variantTypes\n            .map((variantSchema) => {\n                return `        ${\n                    variantSchema.name\n                }: ${this.mkMinimalVariantMetaType(\n                    typeVariety,\n                    variantSchema,\n                    enumId\n                    // \"nestedField\"\n                )}`;\n            })\n            .join(\",\\n\")}\\n    }\\n>;\\n`;\n    }\n\n    mkMinimalVariantMetaType(\n        typeVariety: TypeVariety,\n        schema: VariantTypeSchema,\n        enumId: EnumId\n        // useTypeNamesAt?: \"nestedField\"\n    ) {\n        // When writing an enum variant with 0 fields, the typescript api for generating\n        //   ... that enum variant data should require only the variant name,\n        //   ... IF it is accessed via that type's named proxy (e.g. mkDatum.variantName\n        //   ... or  `{ ..., someNestedField: /*proxy*/ SomeEnumType.variantName }`).  If not\n        //   ... using the proxy type, then raw `{ ... someNestedField: { variantName: {} } }`\n        //   ... form will be needed.\n        //\n        // When writing a single-field variant, the raw form needed will look like\n        //   ... `{ variantName: { singleFIeldName: \u2039nestedFieldData\u203A } }` or,\n        //   ... `{ ..., someNestedField: { variantName: { singleFieldName: \u2039nestedFieldData\u203A } } }`\n        //   ... while the interface can be used like\n        //   ... `mkDatum.variantName({...nestedFieldData})`\n        //   ...  or `{ ..., someNestedField: /*proxy*/ SomeEnumType.variantName(\u2039nestedFieldData\u203A) }`\n        //\n        // When an enum variant has multiple fields, we use the variant like a struct,\n        //   ... with each named field being represented in the the type-proxy:\n        //   ... `mkDatum.variantName({ field1: \u2039fieldData\u203A, field2: ... })`\n        //   ... or `{ ..., someNestedField: /*proxy*/ SomeEnumType.variantName({ field1: \u2039fieldData\u203A, field2: ... }) }`\n        //\n        // In all these cases, the types for any datum/redeemer enum (or enum nested-field)\n        //   ... should ideally indicate the EnumTypeProxy's aggregate named type, with the raw type\n        //   ... as a secondary alternative for people who prefer to write out the full structure.\n        //\n        // The types returned by the proxy's accessors will be identical to the raw types.\n        let variantName = schema.name;\n        // if (typeVariety === \"permissive\") {\n        //     if (useTypeNamesAt) {\n        //         // throw new Error(\"Write path not yet supported for variants\");\n        //         return `${variantName}Like /*writePath*/`;\n        //     }\n        //     // variant name remains unchanged in this case\n        //     // variantName = `${variantName}Like`;\n        // }\n        // if (useTypeNamesAt) return `${variantName}`;\n\n        const variantFlavor = this.variantFlavor(schema);\n        const $nlindent = \"\\n\" + \" \".repeat(12);\n        const $nloutdent = \"\\n\" + \" \".repeat(8);\n        let quotedFlavor =\n            \"fields\" === variantFlavor\n                ? `${$nlindent}\"${variantFlavor}\"`\n                : `\"${variantFlavor}\"`;\n\n        const fieldDefs = this.mkMinimalType(\n            typeVariety,\n            schema,\n            \"nestedField\",\n            enumId.enumName\n        );\n        // this.mkMinimalVariantType(schema, typeVariety);\n\n        const specialFlags: string[] = [];\n        if (schema.fieldTypes[0]?.name === \"seed\") {\n            specialFlags.push(`\"isSeededActivity\"`);\n        }\n        const $specialFlags = specialFlags.join(\" | \") || `\"noSpecialFlags\"`;\n        //pretter-ignore\n        const minimalVariantSrc =\n            `singleEnumVariantMeta<${enumId.enumName}Meta, \"${variantName}\",` +\n            `${$nlindent}\"Constr#${schema.tag}\", ${quotedFlavor}, ` +\n            `${fieldDefs}, ${$specialFlags}` +\n            `${$nloutdent}>`;\n        return minimalVariantSrc;\n    }\n\n    variantFlavor(schema: VariantTypeSchema): VariantFlavor {\n        switch (schema.fieldTypes.length) {\n            case 0:\n                return \"tagOnly\";\n            case 1:\n                return \"singletonField\";\n            default:\n                return \"fields\";\n        }\n    }\n\n    private mkMinimalVariantType(\n        schema: VariantTypeSchema,\n        typeVariety: TypeVariety,\n        parentName: string\n    ): string | string[] {\n        const $nlindent = \"\\n\" + \" \".repeat(4);\n        // const $nlindentMore = \"\\n\" + \" \".repeat(16);\n\n        const variantFlavor = this.variantFlavor(schema);\n        switch (variantFlavor) {\n            case \"tagOnly\":\n                return \"tagOnly\";\n            case \"singletonField\":\n                return this.mkMinimalType(\n                    typeVariety,\n                    schema.fieldTypes[0].type,\n                    \"nestedField\"\n                );\n            case \"fields\":\n                //pretter-ignore\n                return schema.fieldTypes.map(\n                    (field) =>\n                        `${$nlindent}${field.name}: ${this.mkMinimalType(\n                            typeVariety,\n                            field.type,\n                            \"nestedField\"\n                        )}  /*minVariantField*/ `\n                );\n            default:\n                throw new Error(\n                    `Incomplete switch or invalid variant flavor: ${variantFlavor}`\n                );\n        }\n    }\n}\n", "import { BundleTypes } from \"./BundleTypes.js\";\nimport type { HeliosScriptBundle } from \"../scriptBundling/HeliosScriptBundle.js\";\nimport path from \"path\";\n\nconst CREATED = Symbol(\"withCreate\");\n\nexport class BundleBasedGenerator {\n    bundle: HeliosScriptBundle;\n    typeBundle!: BundleTypes;\n\n    /**\n     * ## Don't use this constructor directly!\n     * For proper initialization, you must use `\u2039class\u203A.create(bundle)`, not `new \u2039class\u203A(bundle)`\n     */\n    constructor(bundle: HeliosScriptBundle, isBrandedCreate: typeof CREATED) {\n        if (isBrandedCreate !== CREATED) {\n            throw new Error(`Invalid use of \\`new ${this.constructor.name}.new(bundle)\\`\\n  ... use \\`${this.constructor.name}.create(bundle)\\` instead`);\n        }\n        this.bundle = bundle;\n    }\n\n    /**\n     * provides delayed iniitalization of the BundleTypes\n     */\n    static create<T extends BundleBasedGenerator>(this: (\n        new (bundle: HeliosScriptBundle, isBrandedCreate: typeof CREATED) => T\n    ), bundle: HeliosScriptBundle): T {\n        const item = new this(bundle, CREATED)\n        item.initTypeBundle()\n        return item\n    }\n\n    initTypeBundle() {\n        this.typeBundle = new BundleTypes(this.bundle, this as any);\n    }\n\n    get namedTypes() {\n        return this.typeBundle.namedTypes;\n    }\n\n    get topLevelTypeDetails() {\n        return this.typeBundle.topLevelTypeDetails;\n    }\n\n    get activityTypeDetails() {\n        return this.typeBundle.activityTypeDetails;\n    }\n\n    get datumTypeDetails() {\n        return this.typeBundle.datumTypeDetails;\n    }\n\n    /**\n     * internal use for modifying imports for .hlb*.[tj]s that are part of the stellar contracts library\n     * if it is true, then the imports will be expressed in a way relative to the stellar contracts \n     * repository.  Otherwise, all the stellar contracts types will be imported from the\n     * \\`\\@donecollectively\\/stellar-contracts\\` package.\n     */\n    protected _isSC = false;\n    _isInStellarContractsLib(t: true) {\n        this._isSC = true;\n    }\n\n    /**\n     * computes relative path from inputFile to importFile\n     */\n    mkRelativeImport(inputFile: string, importFile: string) {\n        let relativePath = path.relative(\n            path.dirname(inputFile),\n            path.join(importFile)\n        );\n        if (relativePath[0] !== \".\") {\n            relativePath = `./${relativePath}`;\n        }\n        return relativePath;\n    }\n\n    get datumTypeName() {\n        return this.bundle.effectiveDatumTypeName();\n    }\n}", "\nimport type {\n    anyTypeDetails,\n    EnumId,\n    EnumTypeMeta,\n    enumTypeDetails,\n    HeliosBundleTypeDetails,\n    HeliosBundleTypes, makesUplcActivityEnumData,\n    singleEnumVariantMeta,\n    typeDetails,\n    variantTypeDetails\n} from \"../HeliosMetaTypes.js\";\nimport type {\n    EnumTypeSchema,\n    TypeSchema,\n    VariantTypeSchema,\n} from \"@helios-lang/type-utils\";\n\n// import { BundleTypes } from \"./BundleTypes.js\";\nimport { BundleBasedGenerator } from \"./BundleBasedGenerator.js\";\n\n/**\n * Gathers any number of types expressible for an on-chain Helios script,\n * and generates types and type aliases for the off-chain TypeScript context.\n *\n * Each struct type is directly expressed as its name\n * Each enum type is expressed as a proxy type, unioned with the possible raw enum variants for that type\n * As each type is encountered (as a **nested field** within a datum or redeemer), any named types encountered\n * are added to the context, with any recursive expansions generated and added to the context, depth-first,\n * ... then the named type is used for the **nested field** where it was encountered.\n * @public\n */\nexport class BundleTypeGenerator extends BundleBasedGenerator {\n    createAllTypesSource(\n        className: string,\n        parentClassName: string,\n        inputFile: string\n    ) {\n        let stellarImports = `        \nimport type {\n    CapoHeliosBundle,\n    CapoDelegateBundle,\n    minimalData,\n    HeliosScriptBundle,\n    EnumTypeMeta,\n    singleEnumVariantMeta,\n    tagOnly,\n    IntersectedEnum\n} from \"@donecollectively/stellar-contracts\"\n`;\n        if (this._isSC) {\n            stellarImports = `\nimport {HeliosScriptBundle} from \"${this.mkRelativeImport(\n                inputFile,\n                \"src/helios/scriptBundling/HeliosScriptBundle.js\"\n            )}\"\nimport type { \n    tagOnly, \n    EnumTypeMeta, \n    singleEnumVariantMeta\n} from \"${this.mkRelativeImport(\n                inputFile,\n                \"src/helios/HeliosMetaTypes.js\"\n            )}\"\nimport type { minimalData } from \"${this.mkRelativeImport(\n            inputFile,\n            \"src/delegation/DelegatedData.js\"\n)}\"\nimport type { IntersectedEnum } from \"${this.mkRelativeImport(\n                inputFile,\n                \"src/helios/typeUtils.js\"\n            )}\"\n                \n`;\n            // import type {CapoHeliosBundle} from \"${this.mkRelativeImport(\n            //                 inputFile,\n            //                 \"src/CapoHeliosBundle.js\"\n            //             )}\"\n            // import type {CapoDelegateBundle} from \"${this.mkRelativeImport(\n            //                 inputFile,\n            //                 \"src/delegation/CapoDelegateBundle.js\"\n            //             )}\"\n            // `;\n        }\n        return (\n            \"\" +\n            `// generated by StellarHeliosProject using Stellar heliosRollupTypeGen()\n// recommended: CHECK THIS FILE INTO YOUR VERSION CONTROL SYSTEM\n//   ... and keep checking in the changes as your on-chain types evolve.\n//\n// NOTE: this file is auto-generated; do not edit directly\n\nimport type { UplcData } from \"@helios-lang/uplc\";\nimport type {\n    Address,\n    AssetClass,\n    DatumHash,\n    MintingPolicyHash,\n    PubKey,\n    PubKeyHash,\n    ScriptHash,\n    SpendingCredential,\n    StakingCredential,\n    StakingValidatorHash,\n    TimeRange,\n    TxId,\n    TxInput,\n    TxOutput,\n    TxOutputId,\n    InlineTxOutputDatum,\n    ValidatorHash,\n    Value,\n} from \"@helios-lang/ledger\";\nimport type { Cast } from \"@helios-lang/contract-utils\";\nimport type { \n    IntLike,\n    // BytesLike,\n } from \"@helios-lang/codec-utils\";\n\n/**\n * @public\n */\nexport type TimeLike = IntLike;\n \n${stellarImports}\n\n${this.generateNamedDependencyTypes()}\n`\n            // export default\n            // class ${className}\n            // extends ${parentClassName} {\n            // ${this.generateDatumApiTypes()}\n            // ${this.generateRedeemerApiTypes()}\n            // }\n            // `\n        );\n    }\n\n    generateNamedDependencyTypes() {\n        return Object.entries(this.namedTypes)\n            .map(([name, typeInfo]) => {\n                if (typeInfo.typeSchema.kind === \"enum\") {\n                    return this.generateEnumTypeSource(\n                        name,\n                        typeInfo as enumTypeDetails\n                    );\n                } else {\n                    return this.generateOtherNamedTypeSource(\n                        name,\n                        typeInfo as typeDetails\n                    );\n                }\n            })\n            .join(\"\\n\");\n    }\n\n    generateEnumTypeSource(name: string, typeInfo: enumTypeDetails) {\n        return (\n            `\n            /**\n            * @internal\n            */\n            export type ${name}Meta = ${typeInfo.canonicalMetaType}\\n` +\n            `\\n/**\\n` +\n            ` * ${name} enum variants\\n` +\n            ` * \\n` +\n            ` * @remarks - expresses the essential raw data structures\\n` +\n            ` * supporting the **${\n                Object.keys(typeInfo.variants).length\n            } variant(s)** of the ${name} enum type\\n` +\n            ` * \\n` +\n            ` * - **Note**: Stellar Contracts provides a higher-level \\`${name}Helper\\` class\\n` +\n            ` *     for generating UPLC data for this enum type\\n` +\n            ` * @public\\n`+\n            ` */\\n` +\n            `export type ${name} = ${typeInfo.canonicalType}\\n` +\n            `/**\n * ergonomic type enabling easy access to values converted from the on-chain form\n * @remarks\n * The data will be expressed in canonical form, and enum variants are merged to a single type with optional fields.\n * Nested enums are also merged in this ergonomic way.\n * @public\n */\\n`+\n            `export type ${typeInfo.ergoCanonicalTypeName} = IntersectedEnum<${typeInfo.ergoCanonicalType}>\\n` +\n            // `// factory signatures for this Enum: \\n` +\n            // `// makesUplcEnumData<${name}Like>;\\n` +\n            // `// ^^ calling such a factory makes a EnumUplcResult\\n` +\n            // `// makesUplcActivityEnumData<${name}Like>; // if activity!\\n` +\n            // `// ^^ calling such a factory makes a EnumUplcResult\\n` +\n            // `// reader signature for this Enum: \\n` +\n            // `// readsUplcEnumData<${name}>;\\n` +\n            `\\n/**\\n` +\n            ` * ${name} enum variants (permissive)\\n` +\n            ` * \\n` +\n            ` * @remarks - expresses the allowable data structure\\n` +\n            ` * for creating any of the **${\n                Object.keys(typeInfo.variants).length\n            } variant(s)** of the ${name} enum type\\n` +\n            ` * \\n` +\n            ` * - **Note**: Stellar Contracts provides a higher-level \\`${name}Helper\\` class\\n` +\n            ` *     for generating UPLC data for this enum type\\n` +\n            ` *\\n` +\n            ` * #### Permissive Type\\n` +\n            ` * This is a permissive type that allows additional input data types, which are \\n` +\n            ` * converted by convention to the canonical types used in the on-chain context.\\n` +\n            ` * @public\\n` +\n            ` */\\n` +\n            `export type ${name}Like = IntersectedEnum<${typeInfo.permissiveType}>\\n` +\n            \"\"\n        );\n    }\n\n    generateOtherNamedTypeSource(name: string, typeInfo: typeDetails) {\n        if (!typeInfo.ergoCanonicalTypeName) throw new Error(\"missing ergoCanonicalTypeName\");\n        if (!typeInfo.permissiveTypeName) throw new Error(\"missing permissiveTypeName\");\n        const schema = typeInfo.typeSchema;\n        const minimalTypeInfo = schema.kind === \"struct\" &&\n        !! schema.fieldTypes.find((f) => f.name === \"id\" && f.type.kind == \"internal\" && f.type.name == \"ByteArray\") &&\n        !! schema.fieldTypes.find((f) => f.name === \"type\" && f.type.kind == \"internal\" && f.type.name == \"String\") \n        ?\n            `\n/**\n * expresses the essential fields needed for initiating creation of a ${typeInfo.canonicalTypeName}\n * @public\n */\nexport type minimal${typeInfo.canonicalTypeName} = minimalData<${typeInfo.permissiveTypeName}>` : \"\";\n\n        return (\n`/**\n * A strong type for the canonical form of ${typeInfo.canonicalTypeName || name}\n * @remarks\n * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing\n * enum data conforming to this type can be a bit of a pain.\n * For a more ergonomic, though less strictly-safe form of this type, see ${typeInfo.ergoCanonicalTypeName} instead.\n * @public\n */\nexport interface ${typeInfo.canonicalTypeName || name} ${typeInfo.canonicalType}\n\n/**\n * An ergonomic, though less strictly-safe form of ${typeInfo.canonicalTypeName || name}\n * @remarks\n * This type can use enums expressed as merged unions of the enum variants.  You might think of this type\n * as being \"read-only\", in that it's possible to create data with this type that would not be suitable for\n * conversion to on-chain use.  For creating such data, use the ${typeInfo.permissiveTypeName} type,\n * or the on-chain data-building helpers instead.\n * @public\n */\nexport type ${typeInfo.ergoCanonicalTypeName} = ${typeInfo.ergoCanonicalType}\n\n/**\n * A strong type for the permissive form of ${typeInfo.canonicalTypeName || name}\n * @remarks\n * The field types enable implicit conversion from various allowable input types (including the canonical form).\n * @public\n */\nexport interface ${typeInfo.permissiveTypeName} ${typeInfo.permissiveType}\n${minimalTypeInfo}\n`\n        );\n    }\n\n    // // redeemer is write-only\n    // generateRedeemerApiTypes() {\n    //     return this.generateWriteApiTypes(\n    //         this.topLevelTypeDetails.redeemer,\n    //         \"Activity\"\n    //     );\n    // }\n\n    // // datums are read/write, when present\n    // generateDatumApiTypes() {\n    //     // datum: HeliosTypeInfo | HeliosEnumInfo) {\n    //     if (!this.topLevelTypeDetails.datum) {\n    //         return `// no datum types in this script`;\n    //     }\n\n    //     return (\n    //         this.generateWriteApiTypes(\n    //             this.topLevelTypeDetails.datum,\n    //             \"mkDatum\"\n    //         ) +\n    //         this.generateReadApiTypes(\n    //             this.topLevelTypeDetails.datum,\n    //             \"readDatum\"\n    //         )\n    //     );\n\n    //     // mkDatum: {\n    //     //     placeholder: \"generate proxy types here\";\n    //     // }\n    //     // readDatum: {\n    //     //     placeholder: \"show proxy types here\";\n    //     // }\n    // }\n\n    // generateWriteApiTypes(typeInfo: anyTypeDetails, accessorName?: string) {\n    //     if (!accessorName) {\n    //         //@ts-expect-error - name not always present\n    //         if (!typeInfo.typeSchema.name) {\n    //             throw new Error(\"typeName must be provided for unnamed types\");\n    //         }\n    //         //@ts-expect-error - name already guarded above\n    //         accessorName = `mk${typeInfo.typeSchema.name}`;\n    //     }\n    //     const isActivity = \"Activity\" == accessorName ? \"Activity\" : \"\";\n    //     if (typeInfo.typeSchema.kind === \"enum\") {\n    //         return `    ${accessorName}: makesUplc${isActivity}EnumData<${typeInfo.typeSchema.name}Like>;\\n`;\n    //     }\n\n    //     //@ts-expect-error - name not always present\n    //     if (typeInfo.typeSchema.name) {\n    //         //@ts-expect-error - name already guarded above\n    //         return `    ${accessorName}: uplcDataMaker<${typeInfo.typeSchema.name}Like>;\\n`;\n    //     } else {\n    //         console.log(\n    //             \" ????????? is non-named uplcDataMaker ever used?\\nyes:\" +\n    //                 new Error(\"\").stack!.split(\"\\n\").splice(2).join(\"\\n\")\n    //         );\n    //         return `    ${accessorName}: uplcDataMaker<${typeInfo.permissiveType}>;\\n`;\n    //     }\n    // }\n\n    // generateReadApiTypes(typeInfo: anyTypeDetails, accessorName?: string) {\n    //     if (!accessorName) {\n    //         //@ts-expect-error - name not always present\n    //         if (!typeInfo.typeSchema.name) {\n    //             throw new Error(\"typeName must be provided for unnamed types\");\n    //         }\n    //         //@ts-expect-error - name already guarded above\n    //         accessorName = `read${typeInfo.typeSchema.name}`;\n    //     }\n    //     if (typeInfo.typeSchema.kind === \"enum\") {\n    //         return `    ${accessorName}: readsUplcEnumData<${typeInfo.typeSchema.name}>;\\n`;\n    //     }\n    //     //@ts-expect-error - name not always present\n    //     if (typeInfo.typeSchema.name) {\n    //         //@ts-expect-error - name already guarded above\n    //         return `    ${accessorName}: readsUplcData<${typeInfo.typeSchema.name}>;\\n`;\n    //     }\n    //     return `    ${accessorName}: readsUplcData<${typeInfo.canonicalType}>;\\n`;\n    // }\n}\n", "import path from \"path\";\nimport { type TypeGenHooks } from \"./BundleTypes.js\";\nimport type {\n    anyTypeDetails,\n    enumTypeDetails,\n    typeDetails,\n    variantTypeDetails,\n} from \"../HeliosMetaTypes.js\";\nimport type { EnumTypeSchema, TypeSchema } from \"@helios-lang/type-utils\";\nimport { BundleBasedGenerator } from \"./BundleBasedGenerator.js\";\n\ntype dataBridgeTypeInfo = {\n    accessorCode: string;\n    castCode?: string;\n    helperClassName?: string;\n};\n\ntype fullDetails = anyTypeDetails<dataBridgeTypeInfo>;\ntype fullEnumTypeDetails = enumTypeDetails<dataBridgeTypeInfo>;\ntype fullVariantTypeDetails = variantTypeDetails<dataBridgeTypeInfo>;\ntype fullTypeDetails = typeDetails<dataBridgeTypeInfo>;\n\n/**\n * Gathers any number of types expressible for an on-chain Helios script,\n * and does code generation for a class, including accessors for generating typed data\n * by converting expected data using the Cast class.\n *\n * The class uses a various subclasses of DataBridge for different types defined\n * in the contract script.\n *\n * Uses the BundleTypes class as a helper, in which the bridge-generator is a\n * \"collaborator\" in that class.  Thus, the data-bridge has access to the same\n * key events in the schema-finding process, and can tap into all the essential\n * logic for finding types.\n *\n * This strategy is also used for generating the data-reader class.\n *\n * When generating methods in the new class, the following rules apply:\n *\n * 1.  Each struct type is directly exposed as its name, making \u2039bridge\u203A.\u2039struct name\u203A\n *      available for generating any data expected to match that form.\n *\n * 2.  Each enum type is exposed as its name, with nested accessors for each enum variant,\n *       ... with the accessors for each variant depend on the number of fields in the variant.\n *\n *     - if the variant has no fields, the accessor directly returns \u2039cast\u203A.toUplcData(\\{ variantName: \\{\\} \\})\n *\n *     - if the variant has a single field, the accessor is a function that takes the field value\n *        (with a strong type) and returns \u2039cast\u203A.toUplcData(\\{ variantName: \\{ fieldName: value \\} \\}\n *\n *     - if the variant has multiple fields, the accessor is a function that takes a strongly-typed\n *       object having the fields and returns \u2039cast\u203A.toUplcData(\\{ variantName: \\{ ...fields \\} \\})\n *\n * 3. Datum creator functions return a InlineTxOutputDatum, not just UplcData.\n *\n * 4. Reader types use an ergonomic type, where enum variants at any level are merged into a single\n *     type, not a union of its variants.  Enums and Structs with nested enums are also ergonomic.\n *\n * While gathering types, all the known type names are registered in a local namespace,\n * with function implementations gathered for each type.\n *\n * As each type is encountered (as a **nested field** within a datum or redeemer), any named\n * types encountered are added to the context, with any recursive expansions generated and\n * added to the context, depth-first... then the named type is used for the **nested field**\n * where it was encountered.\n * @public\n */\nexport class dataBridgeGenerator\n    extends BundleBasedGenerator\n    implements TypeGenHooks<dataBridgeTypeInfo>\n{\n    namedSchemas: Record<string, TypeSchema> = {};\n\n    // satisfies TypeGenHooks<dataBridgeTypeInfo> for creating more details for an enum type\n    getMoreEnumInfo?(typeDetails: enumTypeDetails): dataBridgeTypeInfo {\n        const enumName = typeDetails.enumName;\n        const helperClassName = `${enumName}Helper`;\n\n        this.namedSchemas[enumName] = typeDetails.typeSchema;\n\n        return {\n            accessorCode: `get ${enumName}() {\n                return new ${helperClassName}();\n            }`,\n            helperClassName,\n        };\n    }\n\n    getMoreStructInfo?(typeDetails: typeDetails): dataBridgeTypeInfo {\n        const structName = typeDetails.typeName!;\n        const castMemberName = `\u1C7A\u1C7A${structName}Cast`;\n        const helperClassName = `${structName}Helper`;\n\n        this.namedSchemas[structName] = typeDetails.typeSchema;\n\n        return {\n            castCode: `\n                 /*unused?*/ ${castMemberName}: Cast<${structName}Like, ${structName}> \n                    = makeCast<${structName}Like, ${structName}>(\n                        this.schema.${structName}, \n                        { isMainnet: this.isMainnet, unwrapSingleFieldEnumVariants: true }\n                    );\n            `,\n            accessorCode: `${structName}(fields: ${structName}Like}) {\n                throw new Error(\"hey, this isn't actually unused!\");\n                \n                return this.${castMemberName}.toUplcData(fields);\n            }`,\n            helperClassName,\n        };\n    }\n\n    getMoreVariantInfo?(details: variantTypeDetails): dataBridgeTypeInfo {\n        return {} as any;\n    }\n    getMoreTypeInfo?(details: typeDetails): dataBridgeTypeInfo {\n        return {} as any;\n    }\n\n    // creates a class providing an interface for creating each type of data relevent\n    // for a contract script, with an 'activity' accessor for creating redeemer data,\n    // a 'datum' accessor well-typed on-chain datum, and any utility functions defined\n    // in on-chain scripts.\n    // Any of these that are enums will have their own helper classes for creating\n    //  the enum's specific variants.\n    generateDataBridge(inputFile: string, projectName?: string) {\n        const { bridgeClassName } = this.bundle;\n\n        let imports =\n            /*-----------------imports---------------*/\n            `\nimport { makeCast, type Cast } from \"@helios-lang/contract-utils\"\nimport type { UplcData, ConstrData } from \"@helios-lang/uplc\";\nimport type { \n    IntLike,\n } from \"@helios-lang/codec-utils\";\nimport type {\n    Address,\n    AssetClass,\n    DatumHash,\n    MintingPolicyHash,\n    PubKey,\n    PubKeyHash,\n    ScriptHash,\n    SpendingCredential,\n    StakingCredential,\n    StakingValidatorHash,\n    TimeRange,\n    TxId,\n    TxInput,\n    TxOutput,\n    TxOutputId,\n    ValidatorHash,\n    Value,\n} from \"@helios-lang/ledger\";\n import { makeInlineTxOutputDatum, type InlineTxOutputDatum, type TxOutputDatum } from \"@helios-lang/ledger\";\nimport type { EnumTypeSchema, StructTypeSchema } from \"@helios-lang/type-utils\";\n\n`; // ---------------------/imports------------------------------\n        let scImports = /*--------------stellar-contracts-imports --------------*/ `import {\n    ContractDataBridge,\n    DataBridge, \n    DataBridgeReaderClass ,\n    EnumBridge,\n    impliedSeedActivityMaker,\n    type tagOnly, \n    type hasSeed, \n    type isActivity, \n    type funcWithImpliedSeed,\n    type SeedAttrs,\n    type JustAnEnum,\n    type callWith,\n    type IntersectedEnum,\n} from \"@donecollectively/stellar-contracts\"\\n`;\n        if (this._isSC) {\n            scImports =\n                `import { \n    DataBridge, \n    ContractDataBridge, \n    DataBridgeReaderClass,\n    type callWith,\n} from \"${this.mkRelativeImport(\n                    inputFile,\n                    \"src/helios/dataBridge/DataBridge.js\"\n                )}\"\\n` +\n                `import { \n    EnumBridge,\n    type JustAnEnum,\n} from \"${this.mkRelativeImport(\n                    inputFile,\n                    \"src/helios/dataBridge/EnumBridge.js\"\n                )}\"\\n` +\n                `import type { tagOnly } from \"${this.mkRelativeImport(\n                    inputFile,\n                    \"src/helios/HeliosMetaTypes.js\"\n                )}\"\\n` +\n                `import type { IntersectedEnum } from \"${this.mkRelativeImport(\n                    inputFile,\n                    \"src/helios/typeUtils.js\"\n                )}\"\\n` +\n                `import { \\n` +\n                `    impliedSeedActivityMaker, SeedActivity, type hasSeed, type isActivity, \\n` +\n                `    type funcWithImpliedSeed, type SeedAttrs\\n} from \"${this.mkRelativeImport(\n                    inputFile,\n                    \"src/ActivityTypes.js\"\n                )}\"\\n`;\n            //---------------------/sc-imports-----------------------;\n        }\n        return /* --------------overall file format----------------*/ `// generated by Stellar Contracts dataBridgeGenerator\n// based on types defined in ${this.bundle.program.name} (${\n            this.bundle.main.name\n        })\n// recommended: CHECK THIS FILE INTO YOUR VERSION CONTROL SYSTEM\n//   ... and keep checking in the changes as your on-chain types evolve.\n//\n// NOTE: this file is auto-generated; do not edit directly\n${imports}\n${scImports}\n\n/**\n * @public\n */\nexport type TimeLike = IntLike;\n\n${this.includeScriptNamedTypes(inputFile)}\n\n/**\n * GENERATED data bridge for **${\n     this.bundle.program.name\n }** script (defined in class ***${this.bundle.constructor.name}***)\n * main: **${this.bundle.main.name}**, project: **${\n            this.bundle.main.project || \"\u2039local proj\u203A\"\n        }**\n * @remarks\n* This class doesn't need to be used directly.  Its methods are available through the ***contract's methods***:\n*  - \\`get mkDatum\\` - returns the datum-building bridge for the contract's datum type\n*  - \\`get activity\\` - returns an activity-building bridge for the contract's activity type\n*  - \\`get reader\\` - (advanced) returns a data-reader bridge for parsing CBOR/UPLC-encoded data of specific types\n*  - \\`get onchain\\` - (advanced) returns a data-encoding bridge for types defined in the contract's script\n* The advanced methods are not typically needed - mkDatum and activity should normally provide all the\n* type-safe data-encoding needed for the contract.  For reading on-chain data, the Capo's \\`findDelegatedDataUtxos()\\` \n* method is the normal way to locate and decode on-chain data without needing to explicitly use the data-bridge helper classes.\n* \n* ##### customizing the bridge class name\n* Note that you may override \\`get bridgeClassName() { return \"...\" }\\` to customize the name of this bridge class\n* @public\n */\nexport class ${bridgeClassName} extends ContractDataBridge {\n    static isAbstract = false as const;\n    isAbstract = false as const;\n${this.includeDatumAccessors()}\n${this.includeActivityCreator()}\n${this.includeDataReaderHelper()}\n${this.includeTypeAccessors()}\n${this.includeUtilityFunctions()}\n}\nexport default ${bridgeClassName};\n${this.gatherHelperClasses()}\n${this.includeAllHelperClasses()}\n${this.includeNamedSchemas()}\n// }\n`;\n        //------------------------------/overall formal------------------------------\n    }\n\n    includeCastMemberInitializers() {\n        return Object.values(this.additionalCastMemberDefs).join(\"\");\n    }\n\n    includeDataReaderHelper() {\n        const readerClassName = `${this.bundle.bridgeClassName}Reader`;\n        this.helperClasses[readerClassName] =\n            this.generateDataReaderClass(readerClassName);\n        return `    reader = new ${readerClassName}(this, this.isMainnet);\\n`;\n    }\n\n    generateDataReaderClass(className: string) {\n        return `/**\n * @public\n */\nexport class ${className} extends DataBridgeReaderClass {\n    constructor(public bridge: ${\n        this.bundle.bridgeClassName\n    }, isMainnet: boolean) {\n        super();\n    }\n${this.includeEnumReaders()}\n${this.includeStructReaders()}\n}\\n`;\n    }\n\n    includeEnumReaders() {\n        return Object.keys(this.typeBundle.namedTypes)\n            .filter((typeName) => {\n                const typeDetails = this.typeBundle.namedTypes[typeName];\n                return typeDetails.typeSchema.kind === \"enum\";\n            })\n            .map((typeName) => {\n                const typeDetails = this.typeBundle.namedTypes[\n                    typeName\n                ] as unknown as fullEnumTypeDetails;\n                const helperClassName = typeDetails.moreInfo.helperClassName;\n                const isDatum = this.datumTypeName === typeName;\n\n                const generateFunc = /* -------------enum-reader-func--------------*/ `    /**\n        * reads UplcData *known to fit the **${typeName}*** enum type,\n        * for the ${this.bundle.program.name} script.\n        * #### Standard WARNING\n        * \n        * This is a low-level data-reader for use in ***advanced development scenarios***.\n        * \n        * Used correctly with data that matches the enum type, this reader\n        * returns strongly-typed data - your code using these types will be safe.\n        * \n        * On the other hand, reading non-matching data will not give you a valid result.  \n        * It may throw an error, or it may throw no error, but return a value that\n        * causes some error later on in your code, when you try to use it.\n        */\n    ${typeName}(d : UplcData) { \n        const typeHelper = this.bridge.types.${typeName};\n        const cast = typeHelper.\u1C7A\u1C7Acast;  \n\n        return cast.fromUplcData(d) as Ergo${typeName};        \n    } /* enumReader helper */\\n`;\n                //---------------/enum-reader-func--------------------\n                if (isDatum) {\n                    return (\n                        `datum = (d: UplcData) => { return this.${typeName}(d) }\\n` +\n                        generateFunc\n                    );\n                }\n                return generateFunc;\n            })\n            .join(\"\\n\");\n    }\n\n    includeStructReaders() {\n        return Object.keys(this.typeBundle.namedTypes)\n            .filter((typeName) => {\n                const typeDetails = this.typeBundle.namedTypes[typeName];\n                return typeDetails.typeSchema.kind === \"struct\";\n            })\n            .map((typeName) => {\n                const typeDetails = this.typeBundle.namedTypes[typeName];\n                const castMemberName = `\u1C7A\u1C7A${typeName}Cast`;\n                const isDatum = this.datumTypeName === typeName;\n                const func = /*-------------struct-reader-func--------------*/ `    /**\n        * reads UplcData *known to fit the **${typeName}*** struct type,\n        * for the ${this.bundle.program.name} script.\n        * #### Standard WARNING\n        * \n        * This is a low-level data-reader for use in ***advanced development scenarios***.\n        * \n        * Used correctly with data that matches the type, this reader\n        * returns strongly-typed data - your code using these types will be safe.\n        * \n        * On the other hand, reading non-matching data will not give you a valid result.  \n        * It may throw an error, or it may throw no error, but return a value that\n        * causes some error later on in your code, when you try to use it.\n        */\n    ${typeName}(d: UplcData) {\n        const cast = this.bridge.${castMemberName};\n        return cast.fromUplcData(d) //??? as Ergo${typeName};\n    } /* structReader helper */\\n`;\n                // ----------------struct-reader-func----------------\n                if (isDatum) {\n                    return (\n                        `datum = (d: UplcData) => { return this.${typeName}(d) }\\n` +\n                        func\n                    );\n                }\n                return func;\n            })\n            .join(\"\\n\");\n    }\n\n    additionalCastMemberDefs: Record<string, string> = {};\n\n    includeTypeAccessors() {\n        return (\n            `    /**\\n` +\n            `     * accessors for all the types defined in the \\`${this.bundle.program.name}\\` script\\n` +\n            `     * @remarks - these accessors are used to generate UplcData for each type\\n` +\n            `     */\\n` +\n            `    types = {\\n` +\n            this.includeEnumTypeAccessors() +\n            `\\n\\n` +\n            this.includeStructTypeAccessors() +\n            `    }    \\n\\n` +\n            this.includeCastMemberInitializers()\n        );\n    }\n\n    includeEnumTypeAccessors() {\n        const accessors = Object.keys(this.typeBundle.namedTypes)\n            .filter((typeName) => {\n                const typeDetails = this.typeBundle.namedTypes[typeName];\n                return typeDetails.typeSchema.kind === \"enum\";\n            })\n            .map((typeName) => {\n                const typeDetails = this.typeBundle.namedTypes[\n                    typeName\n                ] as unknown as fullEnumTypeDetails;\n                const helperClassName = typeDetails.moreInfo.helperClassName;\n\n                return (\n                    `      /**\\n` +\n                    `       * generates UplcData for the enum type ***${typeName}*** for the \\`${this.bundle.program.name}\\` script\\n` +\n                    `       */\\n` +\n                    `        ${typeName}: new ${helperClassName}({isMainnet: this.isMainnet}),`\n                );\n            })\n            .join(\"\\n\");\n\n        return accessors;\n    }\n\n    // emits accessors for all the struct types defined in the bundle\n    // for inclusion in the bridge's 'types' namespace\n    // gathers Cast initializers to include in the bridge class\n\n    includeStructTypeAccessors() {\n        const accessors = Object.keys(this.typeBundle.namedTypes)\n            .filter((typeName) => {\n                const typeDetails = this.typeBundle.namedTypes[typeName];\n                return typeDetails.typeSchema.kind === \"struct\";\n            })\n            .map((typeName) => {\n                const typeDetails = this.typeBundle.namedTypes[\n                    typeName\n                ] as unknown as fullTypeDetails;\n\n                const {\n                    canonicalTypeName,\n                    permissiveType,\n                    permissiveTypeName,\n                } = typeDetails;\n                const castMemberName = `\u1C7A\u1C7A${typeName}Cast`;\n                this.additionalCastMemberDefs[castMemberName] =\n                    `    /**\n                * uses unicode U+1c7a - sorts to the end */\\n` +\n                    `    ${castMemberName} = makeCast<${canonicalTypeName}, ${permissiveTypeName}>(\\n` +\n                    `        ${typeName}Schema,\\n` +\n                    `        { isMainnet: true, unwrapSingleFieldEnumVariants: true }\\n` +\n                    `    );\\n`;\n                return (\n                    `      /**\\n` +\n                    `       * generates UplcData for the enum type ***${typeName}*** for the \\`${this.bundle.program.name}\\` script\\n` +\n                    `       */\\n` +\n                    `        ${typeName}: (fields: ${permissiveTypeName} | ${permissiveType}) => {\n        return this.${castMemberName}.toUplcData(fields);\n    },`\n                );\n            })\n            .join(\"\\n\");\n\n        return accessors;\n    }\n    includeUtilityFunctions() {\n        // TODO: include any utility functions defined in the contract\n        return ``;\n    }\n\n    includeScriptNamedTypes(inputFile: string) {\n        // if (inputFile.match(/StructDatum/)) debugger;\n        const typeFile = inputFile.replace(/\\.bridge.ts$/, \".typeInfo.js\");\n        let relativeTypeFile = path.relative(path.dirname(inputFile), typeFile);\n        if (relativeTypeFile[0] !== \".\") {\n            relativeTypeFile = `./${relativeTypeFile}`;\n        }\n\n        return `\nimport type {\\n${Object.entries(this.typeBundle.namedTypes)\n            .map(\n                ([\n                    typeName,\n                    {\n                        canonicalTypeName,\n                        ergoCanonicalTypeName,\n                        permissiveTypeName,\n                    },\n                ]) => {\n                    return `    ${[\n                        canonicalTypeName,\n                        ergoCanonicalTypeName,\n                        permissiveTypeName,\n                    ]\n                        .filter((x) => !!x)\n                        .join(\", \")}`;\n                }\n            )\n            .join(\",\\n\")}\n} from \"${relativeTypeFile}\";\n\nexport type * as types from \"${relativeTypeFile}\";\nimport type * as types from \"${relativeTypeFile}\";\\n\\n`;\n    }\n\n    includeActivityCreator() {\n        // like datumAccessors, but without a need for reading\n        const activityDetails = this.activityTypeDetails;\n        if (!activityDetails) {\n            throw new Error(\n                `${this.bundle.constructor.name}: missing required activity type`\n            );\n        }\n\n        let schemaName = \"\";\n        let activityName;\n        switch (activityDetails.typeSchema.kind) {\n            case \"enum\":\n                activityName = activityDetails.typeSchema.name;\n                schemaName = `${activityName}Schema`;\n                break;\n            case \"variant\":\n                activityName = activityDetails.typeSchema.name;\n                schemaName = `${activityName}Schema`;\n                break;\n            case \"struct\":\n                activityName = activityDetails.typeSchema.name;\n                schemaName = `${activityName}Schema`;\n                break;\n            default:\n                schemaName = JSON.stringify(activityDetails.typeSchema);\n        }\n        const canonicalType =\n            activityDetails.canonicalTypeName! || activityDetails.canonicalType;\n        const permissiveType =\n            activityDetails.permissiveTypeName! ||\n            activityDetails.permissiveType;\n        const activityTypeName = activityDetails.canonicalTypeName!;\n        const castDef = `\n    /**\n     * @internal\n    */        \n    \u1C7A\u1C7AactivityCast = makeCast<\n        ${canonicalType}, ${permissiveType}\n    >(${schemaName}, { \n        isMainnet: this.isMainnet,\n        unwrapSingleFieldEnumVariants: true\n    }); // activityAccessorCast`;\n\n        if (activityDetails.typeSchema.kind === \"enum\") {\n            //  enum -------------------\n            const helperClassName = `${activityName}Helper`;\n            return `\n    /**\n     * generates UplcData for the activity type (***${activityTypeName}***) for the \\`${this.bundle.program.name}\\` script\n     */\n    activity : ${helperClassName}= new ${helperClassName}({isMainnet: this.isMainnet, isActivity: true}); // activityAccessor/enum\n        ${activityName}: ${helperClassName} = this.activity;\\n`;\n            // ---------------------------------\n        } else if (activityDetails.typeSchema.kind === \"struct\") {\n            //  struct? -------------------\n            return `${castDef}\n\n    /**\n     * generates UplcData for the activity type (***${activityTypeName}***) for the \\`${this.bundle.program.name}\\` script\n     * @remarks - same as {@link activity}\n     */\n    ${activityTypeName}(fields: ${activityTypeName}Like) {\n        return this.\u1C7A\u1C7AactivityCast.toUplcData(fields);\n    }\\n\\n`; // --------------------------\n        } else {\n            //  not an enum, not a struct; probably an unnamed type -------------------\n            const permissiveTypeInfo = `${activityDetails.permissiveType}`;\n            const helperClassName = `OtherActivityTypeHelper`;\n            const helperClassType = `callWith<${permissiveTypeInfo}, ${helperClassName}>`;\n            const helperClassTypeCast = \"as any\";\n            const helperClass = this.mkOtherDataHelperClass(\n                helperClassName,\n                activityDetails as unknown as fullTypeDetails\n            );\n            this.helperClasses[helperClassName] = helperClass;\n\n            const moreTypeGuidance = /*------------*/ `\n     * \n     * This accessor object is callable with the indicated argument-type\n     * @example - contract.mkDatum(arg: /* ... see the indicated callWith args \\\\*\\\\/)\\\\n`;\n            // ---------------------------------\n            const accessorVarietyAnnotation = ` // activityAccessor/other\\n`;\n            return (\n                \"\" +\n                `    /**\\n` +\n                `     * Helper class for generating TxOutputDatum for the ***activity type ${\n                    activityTypeName ? `(${activityTypeName})` : \"\"\n                }***\\n` +\n                `     * (\"redeemer\" type) for this \\`${this.bundle.program.name}\\` contract script. ${moreTypeGuidance}\\n` +\n                `     */\\n` +\n                `    activity: ${helperClassType}\\n     = new ${helperClassName}({}) ${helperClassTypeCast} ` +\n                accessorVarietyAnnotation\n            );\n        }\n    }\n\n    includeDatumAccessors() {\n        const datumDetails = this.datumTypeDetails;\n        if (!datumDetails) {\n            // debugger;\n            this.datumTypeDetails;\n            return `datum = undefined // no datum type defined for this bundle (minter / rewards script)\\n`;\n        }\n\n        if (datumDetails.typeSchema.kind === \"variant\") {\n            throw new Error(`Datum as specific enum-variant not yet supported`);\n            // can frame this up with the same approach as the other-datum-type\n        }\n\n        // We always create a helper class for datum access, whether its a struct, enum,\n        //  ... or other type (including primitives)\n        //  - TODO: convert existing code-gen for struct-creators to add helper classes\n        //  - TODO: trigger creation of datum-helper class for non-struct/non-enum\n        // This arrangement ensures that the 'datum' property is a uniform type\n        //   ... generally, that type is Option<DataBridge> (minters and rewards scripts will have null here)\n        //\n        // if the datum type is is an enum or struct, we ALSO generate an accessor with its type name\n        let typeNameAccessor = \"\";\n        let helperClassName = \"\";\n        let helperClassType = \"\";\n        let datumTypeName = this.datumTypeName;\n        const typeName =\n            (\"canonicalTypeName\" in datumDetails\n                ? datumDetails.canonicalTypeName\n                : \"\") || datumDetails.canonicalType;\n        const permissiveTypeName =\n            (\"permissiveTypeName\" in datumDetails\n                ? datumDetails.permissiveTypeName\n                : \"\") || datumDetails.permissiveType;\n\n        let moreTypeGuidance = \"\";\n        let helperClassTypeCast = \"\";\n        let datumAccessorVarietyAnnotation = \"\";\n        if (datumDetails.typeSchema.kind === \"enum\") {\n            //@ts-expect-error - todo: use type-branding & type-inspection function to mke this safer\n            const d: fullEnumTypeDetails = datumDetails as fullEnumTypeDetails;\n            const {\n                moreInfo: { helperClassName: hCN },\n            } = d;\n            if (!hCN)\n                throw new Error(\n                    `missing helperClassName for enum ${d.enumName}`\n                );\n            helperClassName = hCN;\n            helperClassType = hCN;\n            typeNameAccessor =\n                `\\n    /**\\n` +\n                `     * this is the specific type of datum for the \\`${this.bundle.program.name}\\` script\\n` +\n                `     */\\n` +\n                `    ${datumDetails.typeSchema.name}: ${helperClassType} = this.datum;`;\n            datumAccessorVarietyAnnotation = ` // datumAccessor/enum\\n`;\n        } else if (datumDetails.typeSchema.kind === \"struct\") {\n            //@ts-expect-error - todo: use type-branding & type-inspection function to mke this safer\n            const d: fullTypeDetails = datumDetails as fullTypeDetails;\n            const {\n                moreInfo: { helperClassName: hCN },\n            } = d;\n            if (!hCN)\n                throw new Error(\n                    `missing helperClassName for struct ${d.typeName}`\n                );\n            helperClassName = hCN;\n            const permissiveTypeInfo = `${d.permissiveTypeName} | ${d.permissiveType}`;\n            helperClassType = `callWith<${permissiveTypeInfo}, ${hCN}>`;\n            helperClassTypeCast = \"as any\";\n            moreTypeGuidance = `\n     * \n     * This accessor object is callable with the indicated argument-type\n     * @example - contract.mkDatum(arg: /* ... see the indicated callWith args \\\\*\\\\/)\n    *\n    * ${permissiveTypeName} is the same as the expanded type details given\\n`;\n            // -----\n\n            typeNameAccessor =\n                `\\n\\n    /**\\n` +\n                `     * this is the specific type of datum for the \\`${this.bundle.program.name}\\` script\\n` +\n                `     * normally, we suggest accessing the \\`datum\\` property instead.\\n` +\n                `     */\\n` +\n                `    ${datumDetails.typeSchema.name}: ${helperClassType} = this.datum;`;\n            datumAccessorVarietyAnnotation = ` // datumAccessor/struct\\n`;\n        } else {\n            // triggers generation of a helper class for this type\n            //  ... and also sets the type name to callWith<helper-class>\n\n            const permissiveTypeInfo = `${datumDetails.permissiveType}`;\n            helperClassName = `OtherDatumTypeHelper`;\n            helperClassType = `callWith<${permissiveTypeInfo}, ${helperClassName}>`;\n            helperClassTypeCast = \"as any\";\n            this.helperClasses[helperClassName] = this.mkOtherDataHelperClass(\n                helperClassName,\n                datumDetails as unknown as fullTypeDetails\n            );\n            moreTypeGuidance = `\n     * \n     * This accessor object is callable with the indicated argument-type\n     * @example - contract.mkDatum(arg: /* ... see the indicated callWith args \\\\*\\\\/)\\\\n`;\n            // ----\n            datumAccessorVarietyAnnotation = ` // datumAccessor/other\\n`;\n        }\n        return (\n            \"\" +\n            `    /**\\n` +\n            `     * Helper class for generating TxOutputDatum for the ***datum type ${\n                datumTypeName ? `(${datumTypeName})` : \"\"\n            }***\\n` +\n            `     * for this contract script. ${moreTypeGuidance}\\n` +\n            `     */\\n` +\n            `    datum: ${helperClassType}\\n     = new ${helperClassName}({isMainnet: this.isMainnet}) ${helperClassTypeCast} ` +\n            datumAccessorVarietyAnnotation +\n            typeNameAccessor +\n            `\\n\\n    readDatum : (d: UplcData) => Ergo${typeName} = (d) =>  {\\n` +\n            //            `        //return this.datum.\u1C7A\u1C7Acast.fromUplcData(d);\\n` +\n            `        return this.reader.${typeName}(d)\\n` +\n            `    }\\n`\n        );\n        // ----\n    }\n\n    mkOtherDataHelperClass(helperClassName: string, details: fullTypeDetails) {\n        const typeName =\n            (\"canonicalTypeName\" in details ? details.canonicalTypeName : \"\") ||\n            details.canonicalType;\n        const permissiveTypeName =\n            (\"permissiveTypeName\" in details\n                ? details.permissiveTypeName\n                : \"\") || details.permissiveType;\n        if (\n            details.typeSchema.kind != \"internal\" &&\n            (typeName || permissiveTypeName)\n        ) {\n            throw new Error(\n                `type name (${typeName}) and permissive type name (${permissiveTypeName}) are NOT expected for an other-data-type accessor (schema kind=${details.typeSchema.kind})`\n            );\n        }\n        const { canonicalType, permissiveType, typeSchema } = details;\n        const castDef =\n            `    /**\n        * @internal\n        * uses unicode U+1c7a - sorts to the end */\\n` +\n            `    \u1C7A\u1C7Acast = makeCast<\n        ${canonicalType}, ${permissiveType}\n    >(\n        ${JSON.stringify(typeSchema)}, \n        { isMainnet: this.isMainnet, unwrapSingleFieldEnumVariants: true }\n    ); // datumAccessorCast\\n`;\n\n        return `export class ${helperClassName} extends DataBridge {\n    isCallable = true\n    ${castDef}\n    \n    } // mkOtherDatumHelperClass\n    `;\n\n        //         const datumAccessor = `\n        //     /**\n        //      * Generates UplcData for the datum type (${typeName}) for the ${this.bundle.program.name} script\n        //      */\n        //     datum(x: ${permissiveTypeName}) {\n        //         return this.\u1C7A\u1C7AdatumCast.toUplcData(x);\n        //     }\\n`;\n\n        //         const readDatum = `\n        //         /**\n        //          * reads UplcData for the datum type (${typeName}) for the ${this.bundle.program.name} script\n        //          */\n        //         readDatum(d: UplcData) { return this.\u1C7A\u1C7AdatumCast.fromUplcData(d); }\\n`;\n\n        //         if (details.typeSchema.kind === \"struct\") {\n        //             return (\n        //                 castDef +\n        //                 readDatum +\n        //                 datumAccessor +\n        //                 `\n        //     /**\n        //      * generates UplcData for the datum type (${typeName}) for the ${this.bundle.program.name} script\n        //      * @remarks - same as {@link datum}\n        //      */\n        // ` +\n        //                 `    ${details.typeSchema.name}(fields: ${permissiveTypeName}) {\\n` +\n        //                 `        return this.\u1C7A\u1C7AdatumCast.toUplcData(fields);\\n` +\n        //                 `    } // datumAccessor/byName \\n`\n        //             );\n        //         }\n\n        //         // if it's not an enum or struct, there's no name to expose separately;\n        //         // just the accessor+readDatum is enough, with it supporting cast object.\n\n        //         return castDef + readDatum + datumAccessor;\n    }\n\n    helperClasses: Record<string, string> = {};\n\n    // iterate all the named types, generating helper classes for each\n    gatherHelperClasses() {\n        const classSources = [] as string[];\n        for (const [name, typeDetails] of Object.entries(\n            this.typeBundle.namedTypes\n        )) {\n            if (typeDetails.typeSchema.kind === \"enum\") {\n                const enumDetails =\n                    typeDetails as unknown as fullEnumTypeDetails;\n                this.helperClasses[name] = this.mkEnumHelperClass({\n                    typeDetails: enumDetails\n                });\n            } else if (typeDetails.typeSchema.kind === \"struct\") {\n                const structDetails = typeDetails as unknown as fullTypeDetails;\n                this.helperClasses[name] =\n                    this.mkStructHelperClass(structDetails);\n            }\n        }\n        return \"\";\n    }\n\n    includeAllHelperClasses() {\n        return Object.values(this.helperClasses).join(\"\\n\");\n    }\n\n    get redeemerTypeName() {\n        return this.activityTypeDetails.dataType.name;\n    }\n\n    nestedHelperClassName(options: {\n        typeDetails: fullEnumTypeDetails;\n        isActivity: boolean;\n    }) {\n        const {\n            typeDetails,\n            isActivity,\n        } = options;\n        let helperClassName =\n            typeDetails.moreInfo.helperClassName;\n\n        //  - matches \"Activities\" or \"Activity\":\n        if (isActivity && !helperClassName?.match(/Activit/)) {\n            helperClassName = `Activity${helperClassName}`;\n        }\n\n        return `${helperClassName}Nested`;\n    }\n\n    mkStructHelperClass(typeDetails: fullTypeDetails) {\n        const structName = typeDetails.typeName!;\n        return (\n            `/**\\n` +\n            ` * Helper class for generating UplcData for the struct ***${structName}*** type.\\n` +\n            ` * @public\\n` +\n            ` */\\n` +\n            `export class ${structName}Helper extends DataBridge {\\n` +\n            `    isCallable = true\\n` +\n            `   /**\n            * @internal\n            * uses unicode U+1c7a - sorts to the end */\\n` +\n            `    \u1C7A\u1C7Acast = makeCast<${typeDetails.canonicalTypeName}, ${typeDetails.permissiveTypeName}>(\\n` +\n            `        ${structName}Schema,\\n` +\n            `        { isMainnet: this.isMainnet, unwrapSingleFieldEnumVariants: true }\\n` +\n            `    );\\n\\n` +\n            `    // You might expect a function as follows.  We provide this interface and result, \\n` +\n            `    // using a proxy in the inheritance chain.\\n` +\n            `    // see the callableDataBridge type on the 'datum' property in the contract bridge.\\n` +\n            `    //\\n` +\n            `    //Also: if you're reading this, ask in our discord server about a \uD83C\uDF81 for curiosity-seekers! \\n` +\n            `    //\\n` +\n            `    // ${structName}(fields: ${typeDetails.permissiveTypeName}) {\\n` +\n            `    //    return this.\u1C7A\u1C7Acast.toUplcData(fields);\\n` +\n            `    //}\\n` +\n            `} //mkStructHelperClass \\n\\n`\n        );\n    }\n\n    mkEnumHelperClass(options: {\n        typeDetails: fullEnumTypeDetails;\n        isActivity?: boolean;\n        isNested?: \"isNested\";\n    }) {\n        const {\n            typeDetails,\n            isActivity = this.redeemerTypeName === typeDetails.enumName,\n            isNested,\n        } = options;\n        const enumName = typeDetails.enumName;\n        // const maybeNested = isNested ? \", Nested\" : \"\";\n        const isDatum = this.datumTypeName === enumName;\n        // console.log(this.datumTypeName, enumName, isDatum, \"-------------------------------------???\");\n        const parentClass = isActivity\n            ? `EnumBridge<isActivity>` // ${maybeNested}>`\n            : `EnumBridge<JustAnEnum>`; //${maybeNested}>`;\n        const normalType = isDatum ? \"InlineTxOutputDatum\" : \"UplcData\";\n\n        const helperClassName = isNested\n            ? this.nestedHelperClassName({\n                  typeDetails,\n                  isActivity,\n              })\n            : typeDetails.moreInfo.helperClassName;\n\n        return (\n            `/**\\n` +\n            ` * Helper class for generating ${normalType} for variants of the ***${enumName}*** enum type.\\n` +\n            ` * @public\\n` +\n            ` * @remarks\\n` +\n            ` * this class is not intended to be used directly.  Its methods are available through automatic accesors in the parent struct, contract-datum- or contract-activity-bridges.` +\n            ` */\\n` +\n            `export class ${helperClassName} extends ${parentClass} {\\n` +\n            `    /*mkEnumHelperClass*/\\n` +\n            `    /**\n            * @internal\n            *  uses unicode U+1c7a - sorts to the end */\\n` +\n            `    \u1C7A\u1C7Acast = makeCast<${typeDetails.canonicalTypeName}, ${typeDetails.permissiveTypeName}>(\\n` +\n            `        ${enumName}Schema,\\n` +\n            `        { isMainnet: this.isMainnet, unwrapSingleFieldEnumVariants: true }\\n` +\n            `    );\\n\\n` +\n            this.mkEnumVariantAccessors({\n                enumDetails: typeDetails,\n                isDatum,\n                isActivity,\n                isNested,\n            }) +\n            `\\n}/*mkEnumHelperClass*/\\n\\n`\n        );\n    }\n\n    mkNestedEnumAccessor(options: {\n        enumTypeDetails: fullEnumTypeDetails;\n        variantDetails: variantTypeDetails<dataBridgeTypeInfo>;\n        variantName: string;\n        parentContext: string;\n        fieldName: string;\n        oneField: anyTypeDetails<dataBridgeTypeInfo>;\n        isInActivity?: boolean;\n    }) {\n        const {\n            enumTypeDetails,\n            variantDetails,\n            variantName,\n            parentContext,\n            fieldName,\n            oneField,\n            isInActivity,\n        } = options;\n\n        const enumName = enumTypeDetails.enumName;\n        const isActivity = isInActivity || this.redeemerTypeName === enumName;\n        if (!isActivity) {\n            if (enumName.match(/Activit/) || parentContext.match(/Activit/)) {\n                // skip accessors (and helper-classes) for defined enums that will\n                // be used as activity-types; they'll have a separate path for generation.\n                return \"\";\n            }\n        }\n\n        const enumPathExpr = this.getEnumPathExpr(variantDetails);\n\n        const nestedEnumDetails = oneField.typeSchema as EnumTypeSchema;\n        const nestedEnumName = nestedEnumDetails.name;\n\n        const nestedEnumField: fullEnumTypeDetails = oneField as any;\n        const nestedHelperClassName = this.nestedHelperClassName({\n            typeDetails: nestedEnumField,\n            isActivity,\n        });\n\n        const nestedHelper = this.mkEnumHelperClass({\n            typeDetails: nestedEnumField,\n            isActivity,\n            isNested: \"isNested\",\n        });\n        if (this.helperClasses[nestedHelperClassName]) {\n            if (this.helperClasses[nestedHelperClassName] != nestedHelper) {\n                debugger;\n                throw new Error(\n                    `nestedHelperClassName already exists: ${nestedHelperClassName}\\n${this.helperClasses[nestedHelperClassName]}\\n----------------------------------------------------\\n${nestedHelper}\\n`\n                );\n            } else {\n                // throw new Error(\n                //     `exact duplicate nestedHelperClassName: ${nestedHelperClassName}`\n                // );\n                // return \"\"\n            }\n        }\n        // registers the nested helper class\n        this.helperClasses[nestedHelperClassName] = nestedHelper;\n\n        // const nestedHelperTypeParams = `<\\n        ${\n        //     isActivity ? \"isActivity\" : \"JustAnEnum\"\n        // }, Nested\\n        >`;\n\n        const nestedFieldName = fieldName;\n        return (\n            `    /**\\n` +\n            `     * access to different variants of the ***nested ${nestedEnumName}*** type needed for ***${enumName}:${variantName}***.\\n` +\n            `     */\\n` +\n            `    get ${variantName}() {\\n` +\n            `        const nestedAccessor = new ${nestedHelperClassName}({\n            isMainnet: this.isMainnet, isNested: true, isActivity: ${\n                isActivity ? \"true\" : \"false\"\n            } \n        });\\n` +\n            `        nestedAccessor.mkDataVia(\\n` +\n            `            (${nestedFieldName}: ${nestedEnumName}Like) => {\\n` +\n            `                return  this.mkUplcData({ ${variantName}: ${nestedFieldName} }, \n            ${enumPathExpr});\\n` +\n            `        });\\n` +\n            `        return nestedAccessor;\\n` +\n            `    } /* nested enum accessor */`\n        );\n    }\n\n    getEnumPath(variantDetails: variantTypeDetails<any>) {\n        const { parentType } = variantDetails.dataType.asEnumMemberType!;\n        const enumName =\n            variantDetails.dataType.asEnumMemberType?.parentType.name;\n        // parentType.path looks like __module__SomeModule__EnumName[]\n        const [_1, _module, moduleName, _enumPlusBracket] =\n            parentType.path.split(\"__\");\n        //result should be SomeModule::EnumName.variantName\n        return `${moduleName}::${enumName}.${variantDetails.variantName}`;\n    }\n\n    getEnumPathExpr(variantDetails: variantTypeDetails<any>) {\n        return JSON.stringify(this.getEnumPath(variantDetails));\n    }\n\n    mkEnumVariantAccessors(options: {\n        enumDetails: fullEnumTypeDetails;\n        isDatum: boolean;\n        isActivity: boolean;\n        isNested?: \"isNested\";\n    }) {\n        const {\n            enumDetails,\n            isDatum,\n            isActivity,\n            isNested,\n        } = options;\n        const accessors = Object.keys(enumDetails.variants)\n            .map((variantName) => {\n                const variantDetails = enumDetails.variants[variantName];\n                const fieldCount = variantDetails.fieldCount;\n                const normalType = isDatum ? \"InlineTxOutputDatum\" : \"UplcData\";\n\n                const enumPathExpr = this.getEnumPathExpr(variantDetails);\n                if (fieldCount === 0) {\n                    return (\n                        `/**\\n` +\n                        ` * (property getter): ${normalType} for ***${enumPathExpr}***\\n` +\n                        ` * @remarks - ***tagOnly*** variant accessor returns an empty ***constrData#${variantDetails.typeSchema.tag}***\\n` +\n                        ` */\\n` +\n                        `    get ${variantName}() {\\n` +\n                        `        const uplc = this.mkUplcData({ ${variantName}: {} }, \\n` +\n                        `            ${enumPathExpr});\\n` +\n                        (isDatum\n                            ? `        return makeInlineTxOutputDatum(uplc);\\n`\n                            : `        return uplc;\\n`) +\n                        `    } /* tagOnly variant accessor */`\n                    );\n                } else if (fieldCount === 1) {\n                    return this.mkSingleFieldVariantAccessor({\n                        enumTypeDetails: enumDetails,\n                        variantDetails,\n                        variantName,\n                        isDatum,\n                        isActivity,\n                        isNested,\n                    });\n                } else {\n                    return this.mkMultiFieldVariantAccessor({\n                        enumTypeDetails: enumDetails,\n                        variantDetails,\n                        variantName,\n                        isDatum,\n                        isActivity,\n                        isNested,\n                    });\n                }\n            })\n            .join(\"\\n\\n\");\n        return accessors;\n    }\n\n    private mkMultiFieldVariantAccessor(options: {\n        enumTypeDetails: fullEnumTypeDetails;\n        variantDetails: variantTypeDetails<dataBridgeTypeInfo>;\n        variantName: string;\n        isDatum?: boolean;\n        isActivity?: boolean;\n        isNested?: \"isNested\";\n    }) {\n        const {\n            enumTypeDetails,\n            variantDetails,\n            variantName,\n            isDatum = this.datumTypeName === enumTypeDetails.enumName,\n            isActivity = this.redeemerTypeName === enumTypeDetails.enumName,\n            isNested,\n        } = options;\n        function mkFieldType(fieldName: string, indent = 2): string {\n            const oneField = variantDetails.fields[fieldName];\n            let thatType = oneField.permissiveType;\n            if (\"permissiveTypeName\" in oneField) {\n                thatType = oneField.permissiveTypeName;\n            }\n            return (\n                `    `.repeat(indent) + `${fieldName}: ${thatType}`.trimEnd()\n            );\n        }\n        function unfilteredFields(indent = 2) {\n            return Object.keys(variantDetails.fields)\n                .map((x) => mkFieldType(x, indent))\n                .join(\",\\n\");\n        }\n        const { permissiveTypeName } = variantDetails;\n        const enumPath = this.getEnumPath(variantDetails);\n        const enumPathExpr = this.getEnumPathExpr(variantDetails);\n        const returnType = isActivity\n            ? \"isActivity\"\n            : isDatum\n            ? `InlineTxOutputDatum`\n            : \"UplcData\";\n        if (\"seed\" == Object.keys(variantDetails.fields)[0] && !isDatum) {\n            // && isSeededActivity\n            function filteredFields(\n                indent = 2,\n                callback = mkFieldType,\n                joiner = \",\\n\"\n            ) {\n                return Object.keys(variantDetails.fields)\n                    .filter((fieldName) => fieldName !== \"seed\")\n                    .map((x) => callback(x, indent))\n                    .join(joiner);\n            }\n\n            const activitySummary = `     * generates ${\n                isActivity ? \"isActivity/redeemer wrapper with\" : \"\"\n            } UplcData for ***${enumPathExpr}***, \\n`;\n\n            return (\n                `    /**\\n` +\n                activitySummary +\n                `     * given a transaction-context ***with a seed utxo*** and other field details\\n` +\n                `     * @remarks\\n` +\n                `     * See the \\`tcxWithSeedUtxo()\\` method in your contract's off-chain StellarContracts subclass \\n` +\n                `     * to create a context satisfying \\`hasSeed\\`.\\n` +\n                `     * See \\`$seeded$${variantName}}\\` for use in a context\\n` +\n                `     * providing an implicit seed utxo. \\n` +\n                (isNested\n                    ? `    * ##### Nested activity: \\n` +\n                      `    * this is connected to a nested-activity wrapper, so the details are piped through \\n` +\n                      `    * the parent's uplc-encoder, producing a single uplc object with \\n` +\n                      `    * a complete wrapper for this inner activity detail.\\n`\n                    : \"\") +\n                `     */\\n` +\n                `    ${variantName}(value: hasSeed, fields: { \\n${filteredFields(\n                    2\n                )} \\n` +\n                `    } ) : ${returnType}\\n` +\n                `    /**\\n` +\n                `     * generates ${\n                    isActivity ? \"isActivity/redeemer wrapper with\" : \"\"\n                } UplcData for ***${enumPathExpr}*** \\n` +\n                `     * with raw seed details included in fields.\\n` +\n                `     */\\n` +\n                `    ${variantName}(fields: ${permissiveTypeName} | {\\n${unfilteredFields(\n                    3\n                )}\\n    } ): ${returnType}\\n` +\n                `    ${variantName}(\\n` +\n                `        seedOrUf: hasSeed | ${permissiveTypeName}, \\n` +\n                `        filteredFields?: { \\n${filteredFields(3)}\\n` +\n                `    }) : ${returnType} {\\n` +\n                `        if (filteredFields) {\\n` +\n                `            const seedTxOutputId = this.getSeed(seedOrUf as hasSeed);\\n` +\n                `            const uplc = this.mkUplcData({\\n` +\n                `                ${variantName}: { seed: seedTxOutputId, ...filteredFields } \\n` +\n                `            }, ${enumPathExpr});\\n` +\n                `           return uplc;\\n` +\n                `        } else {\\n` +\n                `            const fields = seedOrUf as ${permissiveTypeName}; \\n` +\n                `           const uplc = this.mkUplcData({\\n` +\n                `                ${variantName}: fields \\n` +\n                `            }, ${enumPathExpr});\\n` +\n                `           return uplc;\\n` +\n                `        }\\n` +\n                `    } /*multiFieldVariant/seeded enum accessor*/ \\n\\n` +\n                `    /**\\n` +\n                activitySummary +\n                `     * @param fields - \\\\{ ` +\n                filteredFields(0, undefined, \", \").replace(\n                    /([<{}>])/g,\n                    \"\\\\$1\"\n                ) +\n                ` \\\\}\\n` +\n                `     * @remarks\\n` +\n                `    * ##### Seeded activity\\n` +\n                `    * This activity  uses the pattern of spending a utxo to provide a uniqueness seed.\\n` +\n                `     * ##### Activity contains implied seed\\n` +\n                `     * Creates a SeedActivity based on the provided args, reserving space for a seed to be \\n` +\n                `     * provided implicitly by a SeedActivity-supporting library function. \\n` +\n                `     *\\n` +\n                `     * #### Usage\\n` +\n                `     *   1. Call the \\`$seeded$${variantName}({ ` +\n                filteredFields(0, (fn) => fn, \", \") +\n                ` })\\`\\n ` +\n                `     *       method with the indicated (non-seed) details.\\n` +\n                `     *   2. Use the resulting activity in a seed-providing context, such as the delegated-data-controller's\\n` +\n                `     *       \\`mkTxnCreateRecord({activity})\\` method.\\n` +\n                (isNested\n                    ? `    * ##### Nested activity: \\n` +\n                      `    * this is connected to a nested-activity wrapper, so the details are piped through \\n` +\n                      `    * the parent's uplc-encoder, producing a single uplc object with \\n` +\n                      `    * a complete wrapper for this inner activity detail.\\n`\n                    : \"\") +\n                `     */\\n` +\n                `    $seeded$${variantName} = impliedSeedActivityMaker(this, \\n` +\n                `        this.${variantName} as (value: hasSeed, fields: { \\n${filteredFields(\n                    3\n                )} \\n` +\n                `        } ) => ${returnType}\\n` +\n                `    )\\n` +\n                `    /* coda: seeded helper in same multiFieldVariant/seeded */\\n`\n            );\n        }\n        return (\n            `    /**\\n` +\n            `     * generates ${\n                isActivity ? \"isActivity/redeemer wrapper with\" : \"\"\n            } ${\n                isDatum ? \"InlineTxOutputDatum\" : \"UplcData\"\n            } for ***${enumPathExpr}***\\n` +\n            `     * @remarks - ***${permissiveTypeName}*** is the same as the expanded field-types.\\n` +\n            (isNested\n                ? `    * ##### Nested activity: \\n` +\n                  `    * this is connected to a nested-activity wrapper, so the details are piped through \\n` +\n                  `    * the parent's uplc-encoder, producing a single uplc object with \\n` +\n                  `    * a complete wrapper for this inner activity detail.\\n`\n                : \"\") +\n            `     */\\n` +\n            `    ${variantName}(fields: ${permissiveTypeName} | { \\n` +\n            unfilteredFields() +\n            `\\n` +\n            `    }) : ${returnType} {\\n` +\n            `        const uplc = this.mkUplcData({\\n` +\n            `            ${variantName}: fields \\n` +\n            `        }, ${enumPathExpr});\\n` +\n            (isDatum\n                ? `        return makeInlineTxOutputDatum(uplc);\\n`\n                : `       return uplc;\\n`) +\n            `    } /*multiFieldVariant enum accessor*/`\n        );\n    }\n\n    private mkSingleFieldVariantAccessor(options: {\n        enumTypeDetails: fullEnumTypeDetails;\n        variantDetails: variantTypeDetails<dataBridgeTypeInfo>;\n        variantName: string;\n        isDatum?: boolean;\n        isActivity?: boolean;\n        isNested?: \"isNested\";\n    }) {\n        const {\n            enumTypeDetails,\n            variantDetails,\n            variantName,\n            isDatum = this.datumTypeName === enumTypeDetails.enumName,\n            isActivity = this.redeemerTypeName === enumTypeDetails.enumName,\n            isNested,\n        } = options;\n        const fieldName = Object.keys(variantDetails.fields)[0];\n        const oneField = variantDetails.fields[fieldName];\n        const enumName =\n            variantDetails.dataType.asEnumMemberType?.parentType.name;\n        const enumPathExpr = this.getEnumPathExpr(variantDetails);\n\n        const returnType = isActivity\n            ? \"isActivity\"\n            : isDatum\n            ? \"InlineTxOutputDatum\"\n            : \"UplcData\";\n\n        if (\"enum\" == oneField.typeSchema.kind) {\n            return this.mkNestedEnumAccessor({\n                enumTypeDetails,\n                variantDetails,\n                variantName,\n                parentContext: `${enumName}$${variantName}$$`,\n                fieldName,\n                oneField,\n                isInActivity: isActivity,\n            });\n        }\n        if (\"seed\" == fieldName && !isDatum) {\n            // && isSeededActivity\n            return (\n                `    /**\\n` +\n                `    * generates ${\n                    isActivity ? \"isActivity/redeemer wrapper with\" : \"\"\n                } UplcData for ***${enumPathExpr}***, \\n` +\n                `    * given a transaction-context (or direct arg) with a ***seed utxo*** \\n` +\n                `    * @remarks\\n` +\n                `    * ##### Seeded activity\\n` +\n                `    * This activity  uses the pattern of spending a utxo to provide a uniqueness seed.\\n` +\n                `    *  - to get a transaction context having the seed needed for this argument, \\n` +\n                `    *    see the \\`tcxWithSeedUtxo()\\` method in your contract's off-chain StellarContracts subclass.\\n` +\n                `    * - or see the {@link hasSeed} type for other ways to feed it with a TxOutputId.\\n` +\n                `    *  - in a context providing an implicit seed utxo, use \\n` +\n                `    *    the \\`$seeded$${variantName}}\\` variant of this activity instead\\n` +\n                `    *\\n ` +\n                (isNested\n                    ? `    * ##### Nested activity: \\n` +\n                      `    * this is connected to a nested-activity wrapper, so the details are piped through \\n` +\n                      `    * the parent's uplc-encoder, producing a single uplc object with \\n` +\n                      `    * a complete wrapper for this inner activity detail.\\n`\n                    : \"\") +\n                `    */\\n` +\n                `    ${variantName}(thingWithSeed: hasSeed | ${oneField.permissiveType}) \\n` +\n                `    : ${returnType} {\\n` +\n                `        const seedTxOutputId = this.getSeed(thingWithSeed);\\n` +\n                (isNested\n                    ? `\\n        // piped through parent's uplc-encoder\\n`\n                    : \"\") +\n                `        const uplc = this.mkUplcData({ \\n` +\n                `           ${variantName}: seedTxOutputId\\n` +\n                `        },${enumPathExpr});  \\n` +\n                `        return uplc;\\n` +\n                `    }  /*singleField/seeded enum variant*/\\n\\n` +\n                `    /**\\n` +\n                `     * generates ${\n                    isActivity ? \"isActivity/redeemer wrapper with\" : \"\"\n                } UplcData for ***${enumPathExpr}***\\n` +\n                `     * @remarks\\n` +\n                `    * ##### Seeded activity\\n` +\n                `    * This activity  uses the pattern of spending a utxo to provide a uniqueness seed.\\n` +\n                `     * ##### Activity contains implied seed\\n` +\n                `     * Creates a SeedActivity based on the provided args, reserving space for a seed to be \\n` +\n                `     * provided implicitly by a SeedActivity-supporting library function. \\n` +\n                `     * #### Usage\\n` +\n                `     * Access the activity-creator as a getter: \\`$seeded$${variantName}\\`\\n` +\n                `     *\\n` +\n                `     * Use the resulting activity-creator in a seed-providing context, such as the delegated-data-controller's\\n` +\n                `     * \\`mkTxnCreateRecord({activity, ...})\\` method.\\n` +\n                (isNested\n                    ? `    * #### Nested activity: \\n` +\n                      `    * this is connected to a nested-activity wrapper, so the details are piped through \\n` +\n                      `    * the parent's uplc-encoder, producing a single uplc object with \\n` +\n                      `    * a complete wrapper for this inner activity detail.\\n`\n                    : \"\") +\n                `     */\\n` +\n                `    get $seeded$${variantName}() {\\n` +\n                `        return impliedSeedActivityMaker(this,this.${variantName})() // called with no args needed\\n` +\n                `    } /* coda: seeded helper in same singleField/seeded enum variant*/\\n`\n            );\n        }\n        let thatType = oneField.permissiveType || \"\";\n        let expandedTypeNote = \"\";\n        if (\"permissiveTypeName\" in oneField) {\n            thatType = `${oneField.permissiveTypeName} | ${oneField.permissiveType}`;\n            expandedTypeNote = `     * @remarks - ***${oneField.permissiveTypeName}*** is the same as the expanded field-type.\\n`;\n        }\n        const argNameIsFieldName = fieldName;\n        return (\n            `    /**\\n` +\n            `     * generates ${\n                isActivity ? \"isActivity/redeemer wrapper with\" : \"\"\n            } ${\n                isDatum ? \"InlineTxOutputDatum\" : \"UplcData\"\n            } for ***${enumPathExpr}***\\n${expandedTypeNote}` +\n            (isNested\n                ? `    * @remarks\\n` +\n                  `    * #### Nested activity: \\n` +\n                  `    * this is connected to a nested-activity wrapper, so the details are piped through \\n` +\n                  `    * the parent's uplc-encoder, producing a single uplc object with \\n` +\n                  `    * a complete wrapper for this inner activity detail.\\n`\n                : \"\") +\n            `     */\\n` +\n            `    ${variantName}(\\n` +\n            `        ${argNameIsFieldName}: ${thatType.trimEnd()}\\n` +\n            `    ) : ${returnType} {\\n` +\n            `        const uplc = this.mkUplcData({ \\n` +\n            `           ${variantName}: ${argNameIsFieldName}\\n` +\n            `        }, ${enumPathExpr}); /*singleField enum variant*/\\n` +\n            (isDatum\n                ? `        return makeInlineTxOutputDatum(uplc);\\n`\n                : `       return uplc;\\n`) +\n            `    }`\n        );\n    }\n\n    includeNamedSchemas() {\n        const schemas = Object.entries(this.namedSchemas)\n            .map(([name, schema]) => {\n                const type =\n                    schema.kind === \"enum\"\n                        ? \"EnumTypeSchema\"\n                        : \"StructTypeSchema\";\n                return `export const ${name}Schema : ${type} = ${JSON.stringify(\n                    schema,\n                    null,\n                    4\n                )};`;\n            })\n            .join(\"\\n\\n\");\n        return schemas;\n    }\n\n    // gatherNonEnumDatumAccessors(datumTypeName: string) {\n    //     const details = this.datumTypeDetails as typeDetails;\n    //     const fields = Object.keys(details.fields).map(fieldName => {\n    //         return `${fieldName}: ${details.fields[fieldName].canonicalTypeName}`;\n    //     }).join(\", \");\n    //     return `get ${datumTypeName}() {\n    //         return this.toUplcData({ ${datumTypeName}: { ${fields} } });\n    //     }`;\n    // }\n}\n", "import type { TimeoutId } from \"./BatchSubmitController.js\";\n\nif (typeof Promise.withResolvers !== 'function') {\n    //@ts-expect-error\n    Promise.withResolvers = function() {\n      let resolve, reject;\n      const promise = new Promise((res, rej) => {\n        resolve = res;\n        reject = rej;\n      });\n      return { promise, resolve, reject };\n    };\n  }\n  \ntype hasWrap = {\n    wrap: Promise<any>\n}\ntype hasTimeout = {\n    wrap?: Promise<any>\n    timeout: number,\n    onTimeout: () => void,\n} \ntype noTimeout = Record<string, never>\ntype wrapOnly = hasWrap & noTimeout\ntype wrapWithTimeout = hasWrap & hasTimeout\ntype MCP_options = wrapOnly | hasTimeout | wrapWithTimeout\n\n\n/**\n * @public\n */\nexport type WrappedPromise<T> = {\n    promise: Promise<T>;\n    cancel: () => void;\n    status: \"pending\" | \"fulfilled\" | \"rejected\" | \"cancelled\" | \"timeout\",\n}\n\n/**\n * @public\n */\nexport type ResolveablePromise<T> = {\n    promise: Promise<T>;\n    status: \"pending\" | \"fulfilled\" | \"rejected\" | \"cancelled\" | \"timeout\",\n    resolve: (value?: T) => void;\n    reject: (reason?: Error) => void;\n    cancel: () => void;\n}\n\n/**\n * @public\n */\nexport function mkCancellablePromise<T>(\n    options?: MCP_options,\n) : MCP_options extends hasWrap ? WrappedPromise<T> : ResolveablePromise<T> {\n    const { \n        wrap: wrapped ,\n        timeout, \n        onTimeout,\n    } = options || {};\n\n    // const controller = new AbortController();\n    // const signal = controller.signal;\n\n    const { promise, resolve, reject } = Promise.withResolvers();\n    const cancel = () => {\n        cpObj.status = \"cancelled\"\n        if (timeoutId) clearTimeout(timeoutId);\n\n        reject(new Error(\"cancelled\"))\n        // controller.abort();\n    }\n    const wrappedResolve = (x) => {\n        resolve(x)\n        cpObj.status = \"fulfilled\"\n    }\n    const wrappedReject = (e) => {\n        cpObj.status=\"rejected\"\n        reject(e)\n    }\n    const cpObj = { \n        promise: promise as any,\n        status: \"pending\",\n        resolve: wrappedResolve, \n        reject: wrappedReject,\n        cancel \n    }\n\n    let timeoutId: TimeoutId | undefined = timeout ? setTimeout(() => {\n        // controller.abort();\n        if (cpObj.status !== \"cancelled\") {\n            cpObj.status = \"timeout\"\n            onTimeout?.();\n            reject(new Error(\"timeout\"));\n        }\n    }, timeout) : undefined;\n\n\n    promise.then(() => {\n        if (timeoutId) clearTimeout(timeoutId);\n        cpObj.status = \"fulfilled\"\n        timeoutId = undefined\n    }, () =>{\n        // prevent unhanded promise rejection.\n        // callers should still handle the rejection.\n    });\n\n    if (wrapped) {\n        wrapped.then(wrappedResolve, wrappedReject);\n        return { \n            promise: promise as any, \n            isWrapped: \"wraps an input promise; no separate resolve/reject\",\n            status: \"pending\",\n            cancel,\n        } as any // WrappedPromise<T>\n    }\n\n    return cpObj as any // ResolveablePromise<T>\n}\n", "let DEBUG : number;\nlet CARDANO_NETWORK: string;\nlet NODE_ENV: string;\nlet OPTIMIZE: number;\nlet BF_API_KEY: string;\n\nconst isNodeJS =typeof process !== 'undefined' \nconst cwd = isNodeJS ? process.cwd() : \"\"\n\nlet anyNEXTjsCue = isNodeJS && (process.env.NEXT_PUBLIC_DEBUG || \n    process.env.NEXT_PUBLIC_CARDANO_NETWORK || \n    process.env.NEXT_PUBLIC_OPTIMIZE || \n    process.env.NEXT_RUNTIME \n) \n\nif (\n    ( () => {\n        try {\n            //@ts-expect-error\n            return import.meta.env\n        } catch (e) {\n            return undefined\n        }\n    }\n)()) {\n    console.log(\"VITE env - using import.meta.env\");\n    //@ts-expect-error\n    DEBUG = parseInt(import.meta.env.VITE_DEBUG || \"0\");\n    //@ts-expect-error\n    CARDANO_NETWORK = import.meta.env.VITE_CARDANO_NETWORK || \"preprod\";\n    //@ts-expect-error\n    NODE_ENV = import.meta.env.DEV ? \"development\" : \"production\";\n    //@ts-expect-error\n    BF_API_KEY = import.meta.env.VITE_BF_API_KEY || \"\";\n    //@ts-expect-error\n    OPTIMIZE = parseInt(import.meta.env.VITE_OPTIMIZE || \"0\");\n} else if (anyNEXTjsCue) {\n    console.log(\"nextjs worker env - using NODE_ENV and NEXT_PUBLIC_*\");\n    DEBUG = parseInt(process.env.NEXT_PUBLIC_DEBUG || \"0\");\n    CARDANO_NETWORK = process.env.NEXT_PUBLIC_CARDANO_NETWORK || \"preprod\";\n    NODE_ENV = process.env.NODE_ENV || \"development\";\n    BF_API_KEY = process.env.NEXT_PUBLIC_BF_API_KEY || \"\";\n    OPTIMIZE = parseInt(process.env.NEXT_PUBLIC_OPTIMIZE || \"0\");\n} else {\n    console.log(\"non-vite, non-nextjs - consulting process.env keys directly\");\n    DEBUG = parseInt(process.env.DEBUG || \"0\");\n    CARDANO_NETWORK = process.env.CARDANO_NETWORK || \"preprod\";\n    NODE_ENV = process.env.NODE_ENV || \"development\";\n    BF_API_KEY = process.env.BF_API_KEY || \"\";\n    OPTIMIZE = parseInt(process.env.OPTIMIZE || \"0\");\n}\n\n// console.log(process.env);\nconsole.log(\"env:\", {DEBUG, CARDANO_NETWORK, NODE_ENV, BF_API_KEY, OPTIMIZE, cwd, });\n\n/**\n * @public\n */\nexport const environment = {\n    DEBUG,\n    CARDANO_NETWORK,\n    BF_API_KEY,\n    NODE_ENV,\n    OPTIMIZE,\n    cwd,\n};\n", "import { existsSync, readFileSync } from \"fs\";\nimport {\n    rollup,\n} from \"rollup\";\nimport esbuild from \"rollup-plugin-esbuild\";\nimport { heliosRollupLoader } from \"./heliosRollupLoader.js\";\nimport path from \"path\";\nimport { colors } from \"../../colors.js\";\nimport type { HeliosScriptBundle } from \"../scriptBundling/HeliosScriptBundle.js\";\nimport type { CapoHeliosBundle } from \"../scriptBundling/CapoHeliosBundle.js\";\nimport { environment } from \"../../environment.js\";\n\nconst processStart = Date.now();\n\nconst { DEBUG } = environment;\nexport type heliosSourceFileSeenHook = (heliosSourceId: string, outputFile: string) => void\ntype hlBundleOptions = {\n    projectRoot: string,\n    onHeliosSource?: heliosSourceFileSeenHook\n}\nexport async function rollupCreateHlbundledClass(\n    inputFile: string, \n    options: hlBundleOptions\n) {\n    // writes the output file next to the input file as *.hlBundled.mjs\n    const outputFile = inputFile.replace(\n        /\\.hlb\\.[tj]s$/,\n        \".hlBundled.mjs\" // ??? move to dist/ or .hltemp/?  hlbundle\n    );\n    if (inputFile == outputFile) {\n        throw new Error(`inputFile cannot be the same as outputFile`);\n    }\n    const { projectRoot, onHeliosSource } = options;\n\n    const buildStartTime = Date.now();\n\n    // throw new Error(inputFile);\n    DEBUG &&console.log(`\uD83D\uDCE6 StellarHeliosProject: loading ${inputFile}`);\n\n    let didWarn = false;\n    // console.log(colors.cyanBright( \"-------------------------=========================\"))\n    const bundle = await rollup({\n        input: inputFile,\n        external(id) {\n            return !/^[./]/.test(id);\n        },\n\n        onwarn(warning, warn) {\n            if (warning.code === \"UNUSED_EXTERNAL_IMPORT\") return;\n            if (warning.code === \"CIRCULAR_DEPENDENCY\") {\n                if (\n                    warning.message ==\n                        \"Circular dependency: src/StellarTxnContext.ts -> src/diagnostics.ts -> src/StellarTxnContext.ts\" ||\n                    warning.message ==\n                        \"Circular dependency: src/diagnostics.ts -> src/StellarTxnContext.ts -> src/delegation/jsonSerializers.ts -> src/diagnostics.ts\" ||\n                    warning.message ==\n                        \"Circular dependency: src/helios/CachedHeliosProgram.ts -> src/helios/CachedHeliosProgramFs.ts -> src/helios/CachedHeliosProgram.ts\" ||\n                    warning.message ==\n                        \"Circular dependency: src/helios/CachedHeliosProgram.ts -> src/helios/CachedHeliosProgramWeb.ts -> src/helios/CachedHeliosProgram.ts\" ||\n                    warning.message ==\n                        \"Circular dependency: src/diagnostics.ts -> src/StellarTxnContext.ts -> src/diagnostics.ts\" ||\n                    warning.message ==\n                        \"Circular dependency: src/diagnostics.ts -> src/delegation/jsonSerializers.ts -> src/diagnostics.ts\"\n                ) {\n                    if (didWarn) return;\n                    didWarn = true;\n                    // warn(\"    ... all the usual Circular dependencies...\")\n                    return;\n                }\n            }\n            warn(warning);\n        },\n        plugins: [\n            // stellarDeploymentHook(\"plugin\"),\n            heliosRollupLoader({\n                // todo make this right for the context\n                project: \"stellar-contracts\",\n                onHeliosSource(id) {\n                    if (onHeliosSource) {\n                        onHeliosSource(id, outputFile);\n                    }\n                },\n            }),\n            // !!! figure out how to make the bundle include the compiled & optimized\n            //   program, when options.compile is true.\n            esbuild({\n                tsconfig: \"./tsconfig.json\",\n                target: [\"node18\"],\n\n                sourceMap: false,\n            }),\n            // after the build is finished, append the list of input files\n            // in a way making it quick and easy to load an existing compiled\n            // file and let it check its own input files for changes.  Then\n            // we can save time and avoid this build step if everything is already good.\n        ],\n        // output: {\n        //     file: this.compiledProjectFilename,\n        //     sourcemap: true,\n        //     format: \"es\",\n        // },\n    }).catch((error) => {\n        console.error(\"Error during rollup of helios bundle:\", error);\n        throw error;\n    });\n\n    const result = await bundle.generate({ format: \"es\" });\n    if (result.output.length > 1) {\n        throw new Error(`unexpected: bundle should have one output`);\n    }\n    const compiled = result.output[0].code;\n    let buildTime = Date.now() - buildStartTime;\n\n    let needsWrite = true;\n    // if the file is not changed, skip write of the compiled file\n    if (existsSync(outputFile)) {\n        const existing = readFileSync(outputFile, \"utf-8\");\n        if (existing === compiled) {\n            DEBUG && console.log(\n                `\uD83D\uDCE6 StellarHeliosProject: unchanged bundle (${buildTime}ms): ${path.relative(projectRoot, outputFile)}`\n            );\n            needsWrite = false;\n        }\n    }\n    if (needsWrite) {\n        await bundle.write({\n            file: outputFile,\n            // sourcemap: true,  // ?? how to get this to work properly?  debugging goes to wrong site\n            format: \"es\",\n        });\n        buildTime = Date.now() - buildStartTime;\n        console.log(\n            `\uD83D\uDCE6 StellarHeliosProject: wrote compiled bundle (${buildTime}ms): ${outputFile}`\n        );\n    }\n    bundle.close();\n    // console.log(colors.cyanBright( \"^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\"))\n\n    const content = readFileSync(outputFile, \"utf-8\");\n    // spawn a program that emits the hash of the output file\n    const data : BufferSource = new TextEncoder().encode(content);\n    const hashBuffer = await crypto.subtle.digest(\"SHA-256\", data)\n\n    const hashArray = Array.from(new Uint8Array(hashBuffer)); // convert buffer to byte array\n    const hashHex = hashArray\n      .map((b) => b.toString(16).padStart(2, \"0\"))\n      .join(\"\").slice(0, 8); // convert bytes to hex string\n  \n    // console.log(colors.cyanBright( \"--- \"+outputFile) + \" \" + hashHex)\n\n    return import(`${outputFile}?t=${Date.now()}`).then((mod) => {\n        if (mod.default) {\n            const BundleClass = mod.default;\n            BundleClass.hash = hashHex;\n            BundleClass.compileTime = buildStartTime\n            BundleClass.afterDelay = (Date.now() - processStart )/1000\n            // debugger\n            return BundleClass as BundleClassWithLoadStats\n        } else {\n            throw new Error(`no default export in ${outputFile}`);\n        }\n    });\n}\n\nexport type BundleClassWithLoadStats = (typeof CapoHeliosBundle | typeof HeliosScriptBundle) & {\n    hash: string;\n    compileTime: number;\n    afterDelay: number;\n}\n", "/**\n * Provides a registry for script configurations that are deployed to the\n * on-chain enviorment.\n * @remarks\n *\n */\n\nimport {\n    makeMintingPolicyHash,\n    makeTxId,\n    makeValidatorHash,\n} from \"@helios-lang/ledger\";\nimport type { CapoConfig } from \"../CapoTypes.js\";\nimport type { DeployedProgramBundle } from \"../helios/CachedHeliosProgram.js\";\nimport type { configBaseWithRev } from \"../StellarContract.js\";\nimport type {\n    capoDelegateConfig,\n    minimalDelegateConfig,\n} from \"../delegation/RolesAndDelegates.js\";\nimport type { BasicMinterParams } from \"../minting/CapoMinter.js\";\n\n/**\n * type-safe factory function for creating a registry of scripts with their\n * deployment details for the on-chain environment\n * @remarks\n * use this in your Capo bundle's `config()` function\n *\n * The registry is indexed by each script's moduleName, and contains a list of\n * deployed configurations for that script, with configuration details,\n * on-chain script hash, and program CBOR.\n * @public\n */\nexport function mkDeployedScriptConfigs(x: AllDeployedScriptConfigs) {\n    return x;\n}\n/**\n * type-safe factory function for creating a Capo deployment details object\n * with details of its scripts deployed to the on-chain environment\n * @remarks\n * use this to make your Capo bundle's deployedDetails attribute.\n * @public\n */\nexport function mkCapoDeployment({\n    capo,\n}: // scripts,\nRequired<CapoDeployedDetails<\"json\">>) {\n    const { config, programBundle } = capo;\n    return {\n        // scripts,\n        capo: {\n            config: parseCapoJSONConfig(config),\n            programBundle,\n        } as DeployedScriptDetails<CapoConfig, \"native\">,\n    };\n}\n\n/**\n * @public\n */\ntype DelegateDeployment = {\n    config: minimalDelegateConfig;\n    scriptHash: string;\n    programBundle?: DeployedProgramBundle;\n};\n\n/**\n * type-safe factory function for creating a Delegate deployment details object\n * @public\n */\nexport function mkDelegateDeployment(\n    ddd: DelegateDeployment\n): DelegateDeployment {\n    return ddd;\n}\n\n/**\n * @public\n */\nexport type CapoDeployedDetails<form extends \"json\" | \"native\" = \"native\"> = {\n    capo?: DeployedScriptDetails<CapoConfig, form>;\n    minter? : DeployedScriptDetails<BasicMinterParams, form>\n    isNullDeployment?: boolean;\n};\n\n/**\n * @public\n */\nexport type AllDeployedScriptConfigs = {\n    [scriptModuleName: string]: ScriptDeployments;\n};\n\n/**\n * @public\n */\ntype DeployedConfigWithVariants = {\n    [name: string]: DeployedScriptDetails;\n} & {\n    singleton?: never;\n};\n\n/**\n * @public\n */\ntype DeployedSingletonConfig<CT extends configBaseWithRev = configBaseWithRev> =\n    {\n        singleton: DeployedScriptDetails<CT>;\n    };\n\n/**\n * @public\n */\nexport type ScriptDeployments =\n    | DeployedSingletonConfig\n    | DeployedConfigWithVariants;\n\n/**\n * @public\n */\nexport type DeployedScriptDetails<\n    CT extends configBaseWithRev = configBaseWithRev,\n    form extends \"json\" | \"native\" = \"native\"\n> =\n    | {\n          config: form extends \"json\" ? any : CT;\n          scriptHash?: number[];\n          programBundle?: DeployedProgramBundle;\n      }\n    | RequiredDeployedScriptDetails<CT>;\n\n/**\n * @public\n */\nexport type RequiredDeployedScriptDetails<\n    CT extends configBaseWithRev,\n    form extends \"json\" | \"native\" = \"native\"\n> = {\n    config: form extends \"json\" ? any : CT;\n    programBundle: DeployedProgramBundle;\n    scriptHash?: string;\n};\n\n/**\n * @public\n */\nexport type CapoConfigJSON = {\n    mph: {\n        bytes: string;\n    };\n    rev: bigint;\n    seedTxn?: {\n        bytes: string;\n    };\n    seedIndex: bigint;\n    rootCapoScriptHash: {\n        bytes: string;\n    };\n};\n\n/**\n * parses details needed for a Capo and its related minter to be instantiated\n * @public\n */\nexport function parseCapoJSONConfig(rawJsonConfig: CapoConfigJSON | string) {\n    const jsonConfig =\n        typeof rawJsonConfig === \"string\"\n            ? (JSON.parse(rawJsonConfig) as CapoConfigJSON)\n            : rawJsonConfig;\n\n    const { mph, rev, seedTxn, seedIndex, rootCapoScriptHash } = jsonConfig;\n\n    const outputConfig: any = {};\n    if (!mph) throw new Error(\"mph is required\");\n    if (!seedTxn) throw new Error(\"seedTxn is required\");\n    if (!seedIndex) throw new Error(\"seedIndex is required\");\n    if (!rootCapoScriptHash) throw new Error(\"rootCapoScriptHash is required\");\n\n    outputConfig.mph = makeMintingPolicyHash(mph.bytes);\n    outputConfig.rev = BigInt(rev || 1);\n    outputConfig.seedTxn = makeTxId(seedTxn.bytes);\n    outputConfig.seedIndex = BigInt(seedIndex);\n    outputConfig.rootCapoScriptHash = makeValidatorHash(\n        rootCapoScriptHash.bytes\n    );\n\n    return outputConfig as CapoConfig;\n}\n/**\n * parses details needed for a Capo minter to be instantiated\n * @public\n */\nexport function parseCapoMinterJSONConfig(\n    rawJSONConfig: Pick<CapoConfigJSON, \"seedTxn\" | \"seedIndex\">\n) {\n    const { seedTxn, seedIndex } = rawJSONConfig;\n    if (!seedTxn) throw new Error(\"seedTxn is required\");\n    if (!seedIndex) throw new Error(\"seedIndex is required\");\n\n    return {\n        seedTxn: makeTxId(seedTxn.bytes),\n        seedIndex: BigInt(seedIndex),\n    };\n}\n", "import {\n    Program,\n    type CompileOptions,\n    type ProgramProps,\n} from \"@helios-lang/compiler\";\nimport type { Source } from \"@helios-lang/compiler-utils\";\nimport {\n    decodeUplcProgramV2FromCbor,\n    deserializeUplcSourceMap,\n    makeUplcSourceMap,\n    type UplcProgramV2,\n    type UplcSourceMapJsonSafe,\n} from \"@helios-lang/uplc\";\nimport { bytesToHex } from \"@helios-lang/codec-utils\";\nimport { blake2b } from \"@helios-lang/crypto\";\nimport { extractName } from \"@helios-lang/compiler\";\n\nimport { textToBytes } from \"../HeliosPromotedTypes.js\";\nimport type { CompileOptionsForCachedHeliosProgram } from \"../HeliosPromotedTypes.js\";\n\nexport type CacheableProgramProps = ProgramProps & {\n    isTestnet: boolean; // non-optional\n    /**\n     * The cache key for the program. Defaults to the hash of the source code.\n     * If there is no source code, the cacheKey is required\n     */\n    cacheKey?: string;\n    /**\n     * The timeout, in milliseconds for waiting for another instance to finish compiling.\n     * The default timeout is 30 seconds.\n     */\n    timeout?: number;\n    /**\n     * The expected script hash for the program.  The compiled program is checked against\n     * this script hash, if provided.\n     */\n    expectedScriptHash?: string;\n    /**\n     * name of the script, which may be different from the name of the script's entry-point\n     * / main module\n     */\n    name?: string;\n};\n\ntype OptimizeOptions =\n    | false\n    | Omit<\n          Exclude<CompileOptions[\"optimize\"], boolean | undefined>,\n          \"iterSpecificOptions\" | \"commonSubExprCount\"\n      >;\n\n/**\n * @internal\n */\nexport type HeliosProgramCacheEntry = {\n    version: \"PlutusV2\" | \"PlutusV3\";\n    createdBy: string;\n    programElements: Record<string, string | Object>;\n    optimizeOptions: OptimizeOptions;\n    optimized?: UplcProgramV2; // | UplcProgramV3I;\n    unoptimized?: UplcProgramV2; //| UplcProgramV3I;\n    optimizedIR?: string;\n    unoptimizedIR?: string;\n    optimizedSmap?: UplcSourceMapJsonSafe;\n    unoptimizedSmap?: UplcSourceMapJsonSafe;\n};\n\n/**\n * @internal\n */\nexport type SerializedHeliosCacheEntry = {\n    version: \"PlutusV2\" | \"PlutusV3\";\n    createdBy: string;\n    programElements: Record<string, string | Object>;\n    optimizeOptions: OptimizeOptions;\n    optimized?: string;\n    unoptimized?: string;\n    optimizedIR?: string;\n    unoptimizedIR?: string;\n    optimizedSmap?: UplcSourceMapJsonSafe;\n    unoptimizedSmap?: UplcSourceMapJsonSafe;\n};\n\n/**\n * @internal\n */\nexport type DeployedProgramBundle = Pick<\n    SerializedHeliosCacheEntry,\n    | \"version\"\n    | \"programElements\"\n    | \"optimized\"\n    | \"unoptimized\"\n    | \"optimizedIR\"\n    | \"unoptimizedIR\"\n    | \"optimizedSmap\"\n    | \"unoptimizedSmap\"\n>;\n\n/**\n * @internal\n */\nexport type lockInfo<T> = {\n    lock: T;\n    release: () => void;\n};\n\n/**\n * @internal\n */\nexport type LockInfoForStrat<T extends CachedHeliosProgram> = Awaited<\n    ReturnType<T[\"acquireLock\"]>\n>;\n\nconst redirecToCorrectConstructor =\n    \"\uD83D\uDC22${this.id}: wrong direct use of new() constructor in CachedHeliosProgram; use forCurrentPlatform() instead\";\n\n/**\n * A Helios program that caches its compiled UPLC program.\n * @remarks\n * Only available in the node.js environment for now, by importing\n * HeliosProgramWithCacheAPI from the @stellar-contracts/HeliosProgramWithCacheAPI module.\n *\n * ### Feedback please?\n * Probably nobody ever sees this doc?  If you do, please let us know!\n * @public\n */\nexport class CachedHeliosProgram extends Program {\n    // static memoryCache = new Map<string, UplcProgramV2 | UplcProgramV3>();\n    props: CacheableProgramProps;\n    locks: Map<string, lockInfo<any>> = new Map();\n    programElements: Record<string, string | Object>;\n    cacheEntry: HeliosProgramCacheEntry | undefined;\n\n    sources: (Source | string)[];\n    static id: string =\n        globalThis?.id || Math.floor(Math.random() * 1000).toString();\n    id: string;\n\n    /**\n     * Creates a new CachedHeliosProgram.\n     * @remarks\n     * Expects the same arguments as the Helios {@link Program} constructor.\n     *\n     * Returns a Program subclass that also conforms to the CachedHeliosProgram interface.\n     *\n     * Use the {@link compileCached | compileCached()} method to compile the program.\n     * @public\n     */\n    constructor(mainSource: string | Source, props: CacheableProgramProps) {\n        super(mainSource, props);\n        this.sources = [mainSource, ...(props?.moduleSources || [])];\n        this.programElements = {};\n        this.id = this.subclass.id;\n        const effectiveProps = {\n            ...{\n                timeout: 30000,\n            },\n            ...(props || {}),\n        };\n        this.props = effectiveProps;\n\n        if (this.constructor === CachedHeliosProgram) {\n            throw new Error(redirecToCorrectConstructor);\n        }\n    }\n\n    /**\n     * Checks for the presence of a cache key, without attempting a lock.  Indicates\n     * whether the program is in the cache; if so, no lock is needed to read it.  Returns\n     * the cached program if found, or null if not found.  Must be implemented by each subclass\n     * as a platform-specific STATIC method.\n     */\n    static async ifCached(cacheKey: string): Promise<string | null> {\n        throw new Error(redirecToCorrectConstructor);\n    }\n\n    /**\n     * Acquires a lock for the given cache key.  Must be implemented by each subclass\n     * as a platform-specific STATIC method.  Blocks while waiting for the lock.  Returns\n     * the lock details or throws an error if the lock cannot be acquired.\n     * The method receives the cache key and the program properties, which includes\n     * the timeout to be used.\n     */\n    static async acquireLock(\n        cacheKey: string,\n        props: CacheableProgramProps\n    ): Promise<lockInfo<any>> {\n        throw new Error(redirecToCorrectConstructor);\n    }\n\n    /**\n     * Acquires a lock for the given cache key, but does not wait.  Must be implemented by each subclass\n     * as a platform-specific STATIC method.\n     */\n    static async acquireImmediateLock(\n        cacheKey: any,\n        props: CacheableProgramProps\n    ): Promise<lockInfo<any> | null> {\n        throw new Error(redirecToCorrectConstructor);\n    }\n\n    /**\n     * Stores a compiled UPLC program in the cache.  Must be implemented by each subclass\n     * as a platform-specific STATIC method.\n     */\n    static async cacheStore(\n        key: string,\n        value: string,\n        raw: HeliosProgramCacheEntry\n    ): Promise<void> {\n        throw new Error(redirecToCorrectConstructor);\n    }\n\n    static async initCacheFromBundle(\n        cacheEntries: Record<string, string | SerializedHeliosCacheEntry>\n    ): Promise<void> {\n        //!!! todo work on this more\n        for (const [key, value] of Object.entries(cacheEntries)) {\n            const found = await this.ifCached(key);\n            if (found) {\n                console.log(\n                    `\uD83D\uDC22${this.id}: duplicate key in compiler cache: ${key}`\n                );\n            }\n            if (\"string\" === typeof value) {\n                this.cacheStore(\n                    key,\n                    value,\n                    this.toHeliosProgramCacheEntry(JSON.parse(value))\n                );\n            } else {\n                const { version } = value;\n                if (version !== \"PlutusV2\" && version !== \"PlutusV3\") {\n                    console.log(\n                        `\uD83D\uDC22${this.id}: unknown version '${version}'' in compiler cache entry: ${key}; skipping`\n                    );\n                    continue;\n                }\n                try {\n                    programFromCacheEntry(value);\n                } catch (e: any) {\n                    console.log(e.message);\n                    console.log(\n                        `^^ \uD83D\uDC22${this.id}: error parsing CBOR program from cache entry: ${key}; skipping`\n                    );\n                    continue;\n                }\n\n                this.cacheStore(\n                    key,\n                    JSON.stringify(value),\n                    this.toHeliosProgramCacheEntry(value)\n                );\n            }\n        }\n    }\n\n    static toHeliosProgramCacheEntry(\n        value: SerializedHeliosCacheEntry\n    ): HeliosProgramCacheEntry {\n        throw new Error(\"todo\");\n    }\n\n    /**\n     * for vscode index view\n     * @internal\n     */\n    private async ______endStatics() {}\n\n    // hashObjectElements(obj: Record<string, string>): Record<string, string> {\n    //     return Object.fromEntries(\n    //         Object.entries(obj).map(([name, content]) => [\n    //             name,\n    //             bytesToHex(blake2b(textToBytes(content))),\n    //         ])\n    //     );\n    // }\n\n    /**\n     * transforms an object of strings, hashing its values\n     */\n    hashObjectEntries(obj: Record<string, string>): Record<string, string> {\n        return Object.fromEntries(\n            Object.entries(obj).map(([name, content]) => [\n                name,\n                bytesToHex(blake2b(textToBytes(content))),\n            ])\n        );\n    }\n\n    /**\n     * transforms an object of strings to a text representation in RFC822 \"headers\" style\n     */\n    objectToText(obj: Record<string, string | number | boolean>): string {\n        return Object.entries(obj)\n            .map(([name, content]) => `${name}: ${content}`)\n            .join(\"\\n\");\n    }\n\n    /**\n     * Builds an index of the source code hashes for the program elements\n     * (main script, other modules)\n     */\n    sourceHashIndex(): Record<string, string> {\n        return this.hashObjectEntries(\n            Object.fromEntries(\n                this.sources.map((s) => {\n                    const name =\n                        \"string\" === typeof s ? extractName(s) : s.name;\n                    const content = \"string\" === typeof s ? s : s.content;\n                    return [name, content];\n                })\n            )\n        );\n    }\n\n    /**\n     * Gathers the program elements needed for caching\n     */\n    gatherProgramElements(): Record<string, string | Object> {\n        return (this.programElements = {\n            ...this.sourceHashIndex(),\n            params: this.entryPoint.paramsDetails(),\n        });\n    }\n\n    computeInputsHash(options: CompileOptionsForCachedHeliosProgram): string {\n        const index = {\n            ...this.programElements,\n        };\n        const { params, ...otherElements } = index;\n        const elementsText = this.objectToText(otherElements as any);\n        const paramsContent = this.objectToText(params as any);\n        // let optimize: OptimizeOptions = options.optimize ?? {};\n        // if (true == optimize) optimize = {};\n        // const optimizeText =\n        // false == optimize ? \"unoptimized\" : this.objectToText(optimize);\n        const optimizeText = this.textOptimizeOptions(options);\n        const optimizeHash = bytesToHex(blake2b(textToBytes(optimizeText)));\n\n        const paramsHashText = this.objectToText(\n            this.hashObjectEntries({ params: paramsContent })\n        );\n        return bytesToHex(\n            blake2b(\n                textToBytes(\n                    elementsText +\n                        \"\\n\" +\n                        paramsHashText +\n                        \"\\n\" +\n                        optimizeHash +\n                        \"\\n\"\n                )\n            )\n        );\n    }\n\n    optimizeOptions(\n        options: CompileOptionsForCachedHeliosProgram\n    ): OptimizeOptions {\n        let optimize: OptimizeOptions =\n            true == options.optimize\n                ? {}\n                : (options.optimize as OptimizeOptions) ?? {};\n\n        return optimize;\n    }\n\n    textOptimizeOptions(options: CompileOptionsForCachedHeliosProgram): string {\n        let optimize = this.optimizeOptions(options);\n        if (false == optimize) return \"unoptimized\";\n        type justOptions = Exclude<OptimizeOptions, false>;\n        let o: justOptions = optimize as any;\n        return this.objectToText(\n            // sort the keys in optimize.\n            Object.fromEntries(\n                Object.entries(o).sort(([a], [b]) => a.localeCompare(b))\n            ) as justOptions\n        );\n    }\n\n    get preferredProgramName(): string {\n        return this.props.name || this.name;\n    }\n\n    getCacheKey(options: CompileOptionsForCachedHeliosProgram): string {\n        if (this.props.cacheKey) {\n            // for using ScriptHash as the caching key\n            return this.props.cacheKey;\n        }\n        const hashString = this.computeInputsHash(options);\n        const opt = false == options.optimize ? \"-unoptimized\" : \"\";\n\n        return `${this.preferredProgramName}${opt}-${hashString}`;\n    }\n\n    /**\n     * Compiles a Helios program to UPLC, with caching for performance\n     *\n     * ### Caching behavior\n     * This method seeks to quickly return a compiled version of the program, using\n     * a platform-specific cache (and lock) mechanism.\n     * #### Happy path\n     *  - if the program is found in the cache, it is immediately returned\n     * #### First compilation and cache-storage\n     *  - Otherwise, a lock is acquired and the program is compiled\n     *  - Once compiled, the cache entry is created for future use, and its lock is lifted\n     *\n     * #### When there is a compile already pending\n     *\n     * Once a Helios program starts compiling once, calling `compileCached()` on any\n     * instance of the same program with the same settings results in the same cache\n     * key.  This may occur in a different browser tab, service worker, node-js thread/worker,\n     * or a different node process.  In each case, the second `compileCached()` call:\n     *\n     *  - Issues a warning that it is waiting for another process to complete the compilation.\n     *  - waits up to 15 seconds (or the configured `timeout`) for a lock (indicating that\n     *    another instance is compiling the program already)\n     * - when the lock  is released, the compiled program is read from the cache, and returned.\n     *  - includes the unoptimized version of the UPLC program for logging\n     *\n     * #### When everything goes wrong\n     * If the process holding a lock doesn't succeed and doesn't release the lock, the\n     * lock goes stale automatically, and the lock fails (after the `timeout` period).  In\n     * this case, each instance of the program:\n     *\n     *   - makes a last attempt to compile the program\n     *   - If it fails, the local process will report the error normally, and no caching is done\n     *   - If it succeeds, the result is returned.\n     *   - it also tries to cache the result (if it can do so without delay)\n     *\n     *  - todo: measure the time cost of the \"has errors\" path.\n     *\n     * See Helios' {@link Program.compile} for more information about compiling Helios programs.\n     *\n     * import from stellar-contracts/CacheableProgramAPI in a node.js environment\n     * to access this method.  In the web environment, that import returns a different\n     * class with the same interface.\n     */\n    async compileWithCache(\n        optimizeOrOptions: boolean | CompileOptionsForCachedHeliosProgram\n    ): Promise<UplcProgramV2> {\n        // Promise<UplcProgramV2 | UplcProgramV3> {\n        const options: CompileOptionsForCachedHeliosProgram =\n            typeof optimizeOrOptions === \"boolean\"\n                ? { optimize: optimizeOrOptions }\n                : optimizeOrOptions;\n        const optimize = this.optimizeOptions(optimizeOrOptions as any);\n\n        const programElements = (this.programElements =\n            this.gatherProgramElements());\n\n        const start = Date.now();\n        const cacheKey = this.getCacheKey(options);\n        // const cachedProgram = CachedHeliosProgram.memoryCache.get(cacheKey);\n\n        const fromCache = await this.getFromCache(cacheKey);\n        if (fromCache) {\n            // const programCount = fromCache.alt ? 2 : 1;\n            console.log(`\uD83D\uDC22${this.id}: ${cacheKey}: from cache`);\n            const end1 = Date.now();\n            this.compileTime = {\n                fetchedCache: end1 - start,\n            }\n            return fromCache;\n        }\n        // not in cache.  Get the lock; if we get it, then we compile.  If not, we wait\n        // for the lock to be released by another instance.\n        const weMustCompile = await this.acquireImmediateLock(cacheKey);\n        const otherInstanceIsCompiling = !weMustCompile;\n        if (otherInstanceIsCompiling) {\n            console.log(\n                `\uD83D\uDC22${this.id}: waiting for pending compile: ${cacheKey}`\n            );\n            try {\n                const cacheEntry = await this.waitForCaching(cacheKey);\n                const program = programFromCacheEntry(cacheEntry);        \n                this.cacheEntry = deserializeHeliosCacheEntry(cacheEntry);\n                debugger\n                return program\n            } catch (e) {\n                console.log(\n                    `\uD83D\uDC22${this.id}: Failed getting cache-awaited program with cacheKey: ${cacheKey}; will compile in-process`\n                );\n                // if this happens, there should be a lock in the locks map... vvvvv\n            }\n        }\n        // we either are delayed from a failed wait-for-cache (with pending lock)\n        // ... or we got an immediate lock\n        let lock = weMustCompile || this.locks.get(cacheKey);\n        if (!lock) {\n            throw new Error(\n                `we should have a lock one way or other at this point`\n            );\n        }\n\n        try {\n            console.log(\n                `\uD83D\uDC22${this.id}: compiling program with cacheKey: ${cacheKey}`\n            );\n            const start = Date.now();\n            // slow!\n            const uplcProgram = this.compile(options);\n            const end1 = Date.now();\n            const cacheEntry: HeliosProgramCacheEntry = {\n                version: \"PlutusV2\",\n                createdBy: this.id,\n                optimizeOptions: optimize,\n                programElements,\n            };\n\n            if (uplcProgram.alt) {\n                cacheEntry.unoptimized = uplcProgram.alt;\n                cacheEntry.unoptimizedIR = uplcProgram.alt.ir;\n                cacheEntry.unoptimizedSmap = makeUplcSourceMap({\n                    term: uplcProgram.alt.root,\n                }).toJsonSafe();\n\n                cacheEntry.optimized = uplcProgram;\n                cacheEntry.optimizedIR = uplcProgram.ir;\n                cacheEntry.optimizedSmap = makeUplcSourceMap({\n                    term: uplcProgram.root,\n                }).toJsonSafe();\n            } else {\n                const sourceMap = makeUplcSourceMap({ term: uplcProgram.root });\n                if (false == options.optimize) {\n                    cacheEntry.unoptimized = uplcProgram;\n                    cacheEntry.unoptimizedIR = uplcProgram.ir;\n                    cacheEntry.unoptimizedSmap = sourceMap.toJsonSafe();\n                } else {\n                    cacheEntry.optimized = uplcProgram;\n                    cacheEntry.optimizedIR = uplcProgram.ir;\n                    cacheEntry.optimizedSmap = sourceMap.toJsonSafe();\n                }\n            }\n            this.cacheEntry = cacheEntry;\n            this.storeInCache(cacheKey, cacheEntry);\n            const end2 = Date.now();\n            this.compileTime = {\n                compiled: end1 - start,\n                stored: end2 - end1,\n            }\n            return uplcProgram;\n        } catch (e: any) {\n            debugger;\n            console.log(\n                `\uD83D\uDC22${this.id}: compiler cache: throwing compile error: ${e.message} (not caching) (dbpa)`\n            );\n            this.releaseLock(cacheKey);\n            throw e;\n        }\n    }\n    compileTime: {\n        compiled?: number,\n        stored?: number,\n        fetchedCache?: number,\n    } | undefined;\n\n    async waitForCaching(\n        cacheKey: string\n    ): Promise<SerializedHeliosCacheEntry> {\n        // we won't get the lock very quickly, but it should come through as\n        // soon as the other process finishes.\n        return this.acquireLock(cacheKey).then(async (lock) => {\n            if (lock) {\n                const cached = await this.ifCached(cacheKey);\n                if (cached) {\n                    lock?.release();\n                    return cached;\n                }\n                // things aren't great if we get here.  But we got the lock, so we can\n                // use it to store the program in the cache.\n                this.locks.set(cacheKey, lock);\n                console.log(\n                    `\uD83D\uDC22${this.id}: waitForCaching: Lock acquired but no cache entry.  Storing lock in map`\n                );\n                throw new Error(\n                    `Lock acquired but no cache entry for ${cacheKey}; compute locally then release this.locks[key].`\n                );\n            }\n            throw new Error(\n                `Lock for ${cacheKey} not acquired; compute locally (and try to populate the cache if possible)`\n            );\n        });\n    }\n\n    async getFromCache(\n        cacheKey: string\n    ): Promise<undefined | UplcProgramV2 /* | UplcProgramV3 */> {\n        const cacheEntry = await this.ifCached(cacheKey);\n        if (cacheEntry) {\n            this.cacheEntry = deserializeHeliosCacheEntry(cacheEntry)\n            // debugger\n            return programFromCacheEntry(cacheEntry);\n        }\n        return undefined;\n    }\n\n    get subclass(): typeof CachedHeliosProgram {\n        return this.constructor as typeof CachedHeliosProgram;\n    }\n\n    static checkPlatform(): \"web\" | \"nodejs\" {\n        // determine if in-browser or using node.js\n        // thanks to https://gist.github.com/rhysburnie/498bfd98f24b7daf5fd5930c7f3c1b7b\n\n        // alt: consider this approach https://stackoverflow.com/a/31090240\n\n        // thuthy\n        var _nodejs: any =\n            typeof process !== \"undefined\" &&\n            process.versions &&\n            process.versions.node;\n        if (_nodejs) {\n            _nodejs = {\n                version: process.versions.node,\n            };\n        }\n\n        // truthy\n        var _browser: any =\n            !_nodejs &&\n            (typeof window !== \"undefined\" || typeof self !== \"undefined\");\n        if (_browser) {\n            // _browser = {\n            //     window: false,\n            //     self: false,\n            //     $: false,\n            // };\n            if (typeof global === \"undefined\") {\n                if (typeof window !== \"undefined\") {\n                    global = window;\n                    _browser.window = true;\n                } else if (typeof self !== \"undefined\") {\n                    global = self;\n                    _browser.self = true;\n                }\n                // } else if (typeof $ !== \"undefined\") {\n                //     global = $;\n                //     _browser.$ = true;\n                // }\n            }\n        }\n\n        if (_nodejs) {\n            console.log(\"Node.js detected\");\n            return \"nodejs\";\n            // module.export = {\n            //     nodejs: _nodejs,\n            //     browser: _browser,\n            // };\n        }\n        console.log(\"Browser env detected\");\n        return \"web\";\n    }\n\n    /**\n     * for vscode index view\n     * @internal\n     */\n    async __vvv_______instanceToStatic() {}\n\n    async ifCached(\n        cacheKey: string\n    ): Promise<SerializedHeliosCacheEntry | null> {\n        const string = await this.subclass.ifCached(cacheKey);\n        if (string) {\n            try {\n                return JSON.parse(string) as SerializedHeliosCacheEntry;\n            } catch (e: any) {\n                console.log(\n                    `  -- \uD83D\uDC22${this.id}: cleaning up invalid cache entry for ${cacheKey}: ${e.message}`\n                );\n                // (cleanup implied by returning null)\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Acquires a lock for the given cache key, waiting according to the\n     * configured `timeout` for another instance to finish compiling.\n     *\n     * Throws an error if the timeout expires\n     */\n    async acquireLock(cacheKey: string) {\n        return this.subclass.acquireLock(cacheKey, this.props).then((lock) => {\n            this.locks.set(cacheKey, lock);\n            return lock;\n        });\n    }\n\n    /**\n     * Acquires a lock for the given cache key if it can do so immediately.\n     * Stores the lock in the instance's lock map.\n     */\n    async acquireImmediateLock(cacheKey: string) {\n        const lock = await this.subclass.acquireImmediateLock(\n            cacheKey,\n            this.props\n        );\n        if (lock) {\n            this.locks.set(cacheKey, lock);\n        }\n        return lock;\n    }\n\n    /**\n     * Stores a compiled UPLC program in the cache.\n     * Requires the lock to exist.\n     * Releases the lock after storing the program.\n     */\n    async storeInCache(\n        cacheKey: string,\n        value: HeliosProgramCacheEntry\n    ): Promise<void> {\n        if (!this.locks.has(cacheKey)) {\n            throw new Error(\n                `storeInCache: the lock for ${cacheKey} is not present`\n            );\n        }\n\n        return this.subclass\n            .cacheStore(\n                cacheKey,\n                stringifyCacheEntry(value),\n                value\n            )\n            .then(() => {\n                this.releaseLock(cacheKey);\n            });\n    }\n\n    /**\n     * Releases the lock for the given cache key.\n     * Removes the lock from the instance's lock map.\n     * Throws an error if the lock is not found.\n     */\n    releaseLock(cacheKey: string) {\n        const lock = this.locks.get(cacheKey);\n        if (lock) {\n            lock.release();\n            this.locks.delete(cacheKey);\n        } else {\n            throw new Error(`releaseLock: no lock found for ${cacheKey}`);\n        }\n    }\n}\n\nexport function stringifyCacheEntry(entry: HeliosProgramCacheEntry): string {\n    return JSON.stringify(\n        serializeCacheEntry(entry),\n        null,\n        2\n    );\n}\n\nexport function serializeCacheEntry(\n    entry: HeliosProgramCacheEntry): SerializedHeliosCacheEntry \n{\n    const { optimized, unoptimized } = entry;\n    return {\n        ...entry,\n        ...(optimized\n            ? { optimized: bytesToHex(optimized.toCbor()) }\n            : {}),\n        ...(unoptimized\n            ? { unoptimized: bytesToHex(unoptimized.toCbor()) }\n            : {}),\n    } as any;\n}\n\nexport function programFromCacheEntry(\n    fromCache: DeployedProgramBundle | SerializedHeliosCacheEntry\n): UplcProgramV2 {\n    //  | UplcProgramV3 {\n    // the program is a hex-string, accepted by both UplcProgramV2 and UplcProgramV3\n    const {\n        optimized,\n        optimizedIR,\n        unoptimized,\n        unoptimizedIR,\n        version,\n        optimizedSmap,\n        unoptimizedSmap,\n        // optimizeOptions,\n        // createdBy,\n        programElements\n    } = fromCache;\n    if (version !== \"PlutusV2\") throw new Error(`pv3supportpending`);\n    // TargetClass = version == \"PlutusV2\" ? UplcProgramV2 : UplcProgramV3;\n\n    const o = optimized\n        ? decodeUplcProgramV2FromCbor(optimized, {\n              ir: optimizedIR,\n              sourceMap: optimizedSmap,\n          })\n        : undefined;\n    const u = unoptimized\n        ? decodeUplcProgramV2FromCbor(unoptimized, {\n              ir: unoptimizedIR,\n              sourceMap: unoptimizedSmap,\n          })\n        : undefined;\n    if (o) {\n        if (u) {\n            return o.withAlt(u); // | UplcProgramV3;\n        }\n        return o;\n    }\n    if (!u) {\n        throw new Error(\n            `\uD83D\uDC22 No optimized or unoptimized program in cache entry: ${fromCache}`\n        );\n    }\n    return u;\n}\n\nexport function deserializeHeliosCacheEntry(\n    entry: SerializedHeliosCacheEntry\n): HeliosProgramCacheEntry {\n    const {\n        optimized,\n        optimizedIR,\n        unoptimized,\n        unoptimizedIR,\n        version,\n        optimizedSmap,\n        unoptimizedSmap,\n        optimizeOptions,\n        createdBy,\n        programElements\n    } = entry\n\n    return {\n        optimized: optimized ? decodeUplcProgramV2FromCbor(optimized) : undefined,\n        unoptimized: unoptimized ? decodeUplcProgramV2FromCbor(unoptimized) : undefined,\n        optimizedSmap: optimizedSmap || undefined, \n        //XXX it's already json-safe. deserializeUplcSourceMap(optimizedSmap).toJsonSafe() : undefined,\n        unoptimizedSmap: unoptimizedSmap || undefined,\n        //XXX it's already json-safe. deserializeUplcSourceMap(unoptimizedSmap).toJsonSafe(): undefined,\n        optimizeOptions,\n        version,\n        createdBy,\n        programElements,\n        optimizedIR,\n        unoptimizedIR,\n    };\n}\n", "import { bytesToHex } from \"@helios-lang/codec-utils\";\nimport { encodeBech32 } from \"@helios-lang/crypto\";\nimport { type Address, type AssetClass } from \"@helios-lang/ledger\";\nimport { type MintingPolicyHash } from \"@helios-lang/ledger\";\nimport { bytesToText } from \"../HeliosPromotedTypes.js\";\nimport {\n    txOutputIdAsString,\n    valueAsString,\n    assetsAsString,\n    policyIdAsString,\n    displayTokenName,\n} from \"../diagnostics.js\";\nimport type { ByteArrayData, IntData } from \"@helios-lang/uplc\";\nimport { checkValidUTF8 } from \"../utils.js\";\n\n/**\n * toJSON adapter for delegate links\n * @remarks\n * used for on-chain serialization of contract config details\n * @internal\n **/\nexport function delegateLinkSerializer(key: string, value: any) {\n    if (typeof value === \"bigint\") {\n        return value.toString();\n    } else if (\"bytes\" == key && Array.isArray(value)) {\n        return bytesToHex(value);\n    } else if (value?.kind == \"Address\") {\n        return value.toString();\n    } else if (\"tn\" == key && Array.isArray(value)) {\n        return bytesToText(value);\n    }\n    if (\"capo\" == key) return undefined;\n    if (\"uh\" == key) return '\"\u2039utxo helper\u203A\"';\n    if (\"capoBundle\" == key) return '\"\u2039capo bundle\u203A\"';\n\n    return value; // return everything else unchanged\n}\n\n/**\n *  this is NOT a jsonifier, but it emits nice-looking info onscreen when used with JSON.stringify (in arg2)\n * @public\n */\nexport function uplcDataSerializer(key: string, value: any, depth = 0) {\n    const indent = \"    \".repeat(depth);\n    const outdent = \"    \".repeat(Math.max(0, depth - 1));\n\n    if (typeof value === \"bigint\") {\n        return `big\u2039${value.toString()}n\u203A`;\n    } else if (\"bytes\" == key && Array.isArray(value)) {\n        // return `\u2039bytes\u2039${value.length}\u203A=${bytesToHex(value)}\u203A`;\n        return abbreviatedDetailBytes(`bytes\u2039${value.length}\u203A`, value, 40);\n    } else if (\"string\" == typeof value) {\n        return `'${value}'`; // JSON.stringify(value, null, 4);\n    } else if (value === null) {\n        return `\u2039null\u203A`;\n    } else if (\"undefined\" == typeof value) {\n        return `\u2039und\u203A`;\n    } else if (value.kind == \"Address\") {\n        const a = value as Address;\n        const cbor = a.toCbor();\n        // const b = decodeAddress(cbor)\n        return (\n            `\u2039${abbrevAddress(value)}\u203A = ` +\n            abbreviatedDetailBytes(`cbor\u2039${cbor.length}\u203A:`, cbor, 99)\n        );\n    } else if (value.kind == \"ValidatorHash\") {\n        return abbreviatedDetailBytes(\n            `script\u2039${value.bytes.length}\u203A`,\n            value.bytes\n        );\n    } else if (value.kind == \"MintingPolicyHash\") {\n        const v: MintingPolicyHash = value;\n        return `mph\u2039${policyIdAsString(v)}\u203A`;\n        // .toHex())}\u203A`;\n    } else if (value.kind == \"TxOutputId\") {\n        return `\u2039txoid:${txOutputIdAsString(value, 8)}\u203A`;\n    }\n    if (value.rawData) {\n        return uplcDataSerializer(key, value.rawData, Math.max(depth, 3));\n    }\n    if (value.kind == \"int\") {\n        const v: IntData = value;\n        return `IntData\u2039${v.value}\u203A`;\n    }\n    if (value.kind == \"bytes\") {\n        const v = value as ByteArrayData;\n        return abbreviatedDetailBytes(\n            `ByteArray\u2039${v.bytes.length}\u203A`,\n            v.bytes,\n            40\n        );\n    }\n    if (value.kind == \"Value\") {\n        return valueAsString(value);\n    }\n    if (value.kind == \"Assets\") {\n        return `assets:\u2039${assetsAsString(value)}\u203A`;\n    }\n    if (value.kind == \"AssetClass\") {\n        const ac = value as AssetClass;\n        return `assetClass:\u2039${policyIdAsString(ac.mph)} ${displayTokenName(\n            ac.tokenName\n        )}}\u203A`;\n    }\n    if (value.kind)\n        console.log(\"info: no special handling for KIND = \", value.kind);\n\n    if (\"tn\" == key && Array.isArray(value)) {\n        return bytesToText(value);\n    } else if (\"number\" == typeof value) {\n        return value.toString();\n    } else if (value instanceof Map) {\n        return `map\u2039${value.size}\u203A: { ${uplcDataSerializer(\n            \"\",\n            Object.fromEntries(value.entries()),\n            Math.max(depth, 3)\n        )}    }`;\n    } else if (Array.isArray(value) && value.length == 0) {\n        return \"[]\";\n    } else if (\n        Array.isArray(value) &&\n        value.every((v) => typeof v === \"number\")\n    ) {\n        return `${abbreviatedDetailBytes(`bytes\u2039${value.length}\u203A`, value, 40)}`;\n        // } else if (value.toString) {\n        //     return value.toString();\n    } else if (Array.isArray(value)) {\n        const inner = value.map((v) =>\n            uplcDataSerializer(\"\", v, Math.max(depth + 1, 3))\n        );\n        let extraNewLine = \"\";\n        let usesOutdent = \"\";\n        const multiLine = inner\n            .map((s) => {\n                const hasNewline = s.trim().includes(\"\\n\");\n                if (s.length > 40) {\n                    extraNewLine = \"\\n\";\n                    usesOutdent = outdent;\n                    return `${indent}${s}`;\n                } else {\n                    // console.log(\"length, hasNewline = \", s.length, hasNewline)\n                }\n                return s;\n            })\n            .join(`, ${extraNewLine}`);\n        // console.log(\"array uses newline/outdent\", {extraNewLine, usesOutdent});\n\n        return `[ ${extraNewLine}${multiLine}${extraNewLine}${usesOutdent} ]`;\n    }\n\n    if (!value) {\n        return JSON.stringify(value);\n    }\n    const keys = Object.keys(value);\n    if (keys.length == 0) {\n        return key ? \"\" : \"{}\";\n    }\n    if (keys.length == 1) {\n        const singleKey = keys[0];\n        const thisValue = value[singleKey];\n        let inner = uplcDataSerializer(\"\", thisValue, Math.max(depth, 3)) || \"\";\n        if (Array.isArray(thisValue)) {\n            if (!inner.length) {\n                inner = \"[ \u2039empty list\u203A ]\";\n            }\n        } else {\n            if (inner.length) inner = `{ ${inner} }`;\n        }\n        let s = `${singleKey}: ${inner}`;\n        // if (key) return `**1k** ${key}: ${s}`\n        return s;\n    }\n    let extraNewLine = \"\";\n    let usesOutdent = \"\";\n    let s = keys.map(\n        (k) =>\n            `${indent}${k}: ${\n                uplcDataSerializer(k, value[k], Math.max(depth + 1, 2))\n                //    JSON.stringify(value[k], datumSerializer, 4)\n                // }`).join(`,\\nz${indent}`);\n            }`\n    );\n    const multiLineItems = s.map((s) => {\n        if (s.length < 40 && !s.includes(\"\\n\")) {\n            return `${s}`;\n        } else {\n            extraNewLine = \"\\n\";\n            usesOutdent = outdent;\n            return `${s}`;\n        }\n        return s;\n    });\n    const multiLine = multiLineItems.join(`, ${extraNewLine}`);\n    s = `${multiLine}${extraNewLine}${usesOutdent}`;\n\n    if (key) return `{${extraNewLine}${s}}`;\n    return `\\n${s}`;\n}\n/**\n * short version of address for compact display\n * @public\n */\nexport function abbrevAddress(address: Address) {\n    return abbreviatedDetail(address.toString(), 12, false);\n}\n\n/**\n * short representation of bytes for compact display\n * @public\n */\nexport function abbreviatedDetailBytes(\n    prefix: string,\n    value: number[],\n    initLength = 8\n) {\n    const hext = bytesToHex(value);\n    const Len = value.length;\n    const text = checkValidUTF8(value)\n        ? ` \u2039\"${abbreviatedDetail(bytesToText(value), initLength)}\"\u203A`\n        : ``;\n\n    if (value.length <= initLength) return `${prefix}${hext}${text}`;\n    const checksumString = encodeBech32(\"_\", value).slice(-4);\n    return `${prefix}${hext.slice(0, initLength)}\u2026 \u2039${checksumString}\u203A${text}`;\n}\n\n/**\n * short version of hex string for compact display\n * @internal\n */\nexport function abbreviatedDetail(\n    hext: string,\n    initLength = 8,\n    countOmitted: boolean = false\n) {\n    if (process?.env?.EXPAND_DETAIL) {\n        return hext;\n    } else {\n        if (hext.length <= initLength) return hext;\n        const omittedCount = countOmitted ? hext.length - initLength - 4 : 0;\n        let omittedString = countOmitted ? `\u2039\u2026${omittedCount}\u2026\u203A` : \"\u2026\";\n        if (countOmitted && omittedCount < omittedString.length) {\n            omittedString = hext.slice(initLength, -4);\n        }\n        return `${hext.slice(0, initLength)}${omittedString}${hext.slice(-4)}`;\n    }\n}\n", "import type { Site } from \"@helios-lang/compiler-utils\";\nimport type { UplcLogger } from \"@helios-lang/uplc\";\n\ntype Group = {\n    name: string;\n    lines: (LineOrGroup)[];\n    result?: string;\n    collapsed?: boolean\n}\n\ntype LineOrGroup = string | Group;\n\nexport class UplcConsoleLogger implements UplcLogger {\n    didStart: boolean = false;\n    // lines: LineOrGroup[] = [];\n    lastMessage: string = \"\";\n    lastReason?: \"build\" | \"validate\";\n    history: string[] = [];\n    groupStack: Group[] = [{\n        name: \"\",\n        lines: []\n    }];\n\n    constructor() {\n        this.logPrint = this.logPrint.bind(this);\n        // this.printlnFunction = this.printlnFunction.bind(this);\n        this.reset = this.reset.bind(this);\n    }\n\n    get currentGroupLines() {\n        return this.groupStack.at(-1)!.lines;\n    }\n\n    get topLines() {\n        return this.groupStack.at(0)!.lines;\n    }\n\n    reset(reason: \"build\" | \"validate\") {\n        this.lastMessage = \"\";\n        this.lastReason = reason;\n        this.groupStack = [{\n            name: \"\",\n            lines: []\n        }];\n        // console.log(\"    ---- resetting printer due to \" + reason);\n        // this.didStart = false;\n        if (reason == \"build\") {\n            // throw new Error(`unexpected`)\n            // this.lines = [];\n            this.groupStack[0].lines = [];\n            return;\n        }\n        if (reason == \"validate\") {\n            this.flush();\n            return;\n        }\n    }\n    // log(...msgs: string[]) {\n    //     return this.logPrint(...msgs);\n    // }\n    // error(...msgs: string[]) {\n    //     return this.logError(...msgs, \"\\n\");\n    // }\n\n    // logPrintLn(...msgs: string[]) {\n    //     return this.logPrint(...msgs, \"\\n\");\n    // }\n\n    interesting = 0\n    logPrint(message: string, site?: Site) {\n        // if ( global.validating) debugger\n        // if (msg == \"no\") { debugger }\n        // if (this.lastReason && this.lastReason == \"validate\") {\n        //     debugger\n        // }\n\n        if (message.match(/STokMint/)) {\n            this.interesting = 1\n        }\n        // \uD83D\uDC23 = bird in egg (think \"nest\")\n        if (message.startsWith(\"\uD83D\uDC23\")) {\n            const groupName = message.replace(\"\uD83D\uDC23\", \"\").replace(\"\uD83D\uDDDC\uFE0F\", \"\");\n            const collapse = !!message.match(/^\uD83D\uDC23\uD83D\uDDDC\uFE0F/) \n\n            const nextGroup = {\n                name: groupName.replace(/^\\s+/, \"\"),\n                lines: [],\n                collapse\n            };\n            // console.log(\"Group start: \" + groupName);\n            this.currentGroupLines.push(nextGroup)\n            this.groupStack.push(nextGroup);\n            \n            return this;\n        } else if (message.startsWith(\"\uD83E\uDD5A \")) {\n            // \uD83E\uDD5A = egg (think \"close up that container\")\n            const rest = message.replace(\"\uD83E\uDD5A \", \"\");\n            if (this.groupStack.length == 1) {\n                const t = this.formatLines(this.topLines)\n                debugger\n                console.warn(\n                    \"Ignoring extra groupEnd() called in contract script\\n\"+t.join(\"\\n\")\n                );\n            } else {\n                // console.log(\"Group end: \" + rest);\n                this.currentGroup.result = rest\n                this.groupStack.pop()\n            }\n            return this\n        }\n        \n        if (\"string\" != typeof message) {\n            console.log(\"wtf\");\n        }\n        // if (message && message.at(-1) != \"\\n\") {\n        //     message += \"\\n\";\n        // }\n        this.lastMessage = message;\n        this.currentGroup.lines.push(...message.split(\"\\n\"));\n        return this;\n    }\n\n    get currentGroup() {\n        const group = this.groupStack.at(-1);\n        if (!group) {\n            debugger\n            throw new Error(\"Too many groupEnd()s called in contract script\");\n        }\n        return group;\n    }\n\n    logError(message: string, stack? : Site) {\n        this.logPrint(\"\\n\");\n        this.logPrint(\n            \"-\".repeat((process?.stdout?.columns || 65) - 8)\n        );\n        this.logPrint(\"--- \u26A0\uFE0F  ERROR: \" + message.trimStart() + \"\\n\");\n        this.logPrint(\n            \"-\".repeat((process?.stdout?.columns || 65) - 8) + \"\\n\"\n        );\n        // return this;\n    }\n    // printlnFunction(msg) {\n    //     console.log(\"                              ---- println\")\n    //     this.lines.push(msg);\n    //     this.lines.push(\"\\n\");\n    //     this.flushLines();\n    // }\n    toggler = 0;\n    toggleDots() {\n        this.toggler = 1 - this.toggler;\n    }\n    get isMine() {\n        return true;\n    }\n    resetDots() {\n        this.toggler = 0;\n    }\n    showDot() {\n        // \u25CC or \u25CF\n        const s = this.toggler ? \"\u2502   \u250A \" : \"\u2502 \u25CF \u250A \";\n        this.toggleDots();\n        return s;\n    }\n\n    fullHistory() {\n        return this.history.join(\"\\n\");\n    }\n    formattedHistory: string[] = [];\n    fullFormattedHistory() {\n        return this.formattedHistory.join(\"\\n\")\n    }\n\n    // formatGroupedOutput() {\n    //     const content: string[] = [];\n    //     const terminalWidth = process?.stdout?.columns || 65;\n    //     for (const group of this.groupStack) {\n    //         content.push(... this.formatGroup(group));\n\n    //         let {name, lines} = group;\n    //         if (name) name = `  ${name}  `;\n    //         const groupHeader = `\u256D${name}`;\n    //         content.push(groupHeader);\n    //         content.push(lines.map(line => ` \u2502 ${line}`).join(\"\\n\"));\n    //         let lastLine = lines.at(-1)\n    //         if (lastLine && lastLine.startsWith(\"\u2570\")) {\n    //             lastLine = `\u2570 ${lastLine.slice(1)}`;\n    //         }\n    //         content.push(lastLine);\n    //     }\n    // }\n\n    formatGroup(group: Group) : string[] {\n        let {name, lines, result=\"\"} = group;\n        const terminalWidth = process?.stdout?.columns || 65;\n\n        const content: string[] = [];\n        const groupHeader = `${name}`;\n        const formattedLines = this.formatLines(lines)\n        const indentedLines = formattedLines.map(line => `  \u2502 ${line}`);\n        // maybe an env option to prevent collapsing\n        const collapseThisGroup = false && group.collapsed; \n        if (collapseThisGroup) {\n            content.push(groupHeader + \" (+\" + formattedLines.length + \")\");\n        } else {\n            content.push(groupHeader);\n            content.push(... indentedLines);\n        }\n        const lastLine = formattedLines.at(-1);\n\n        const happySimpleResult = result && result == \"\u2705\" ?  \"\u2705\"  : \"\"\n        const noResult = !result\n        const noResultClosingLine = noResult ?  \"\u2508\".repeat(terminalWidth - 5) : \"\"\n\n        if ((noResult || happySimpleResult) && lastLine && lastLine?.match(/^\\s+\u2570/)) {\n            const innerLine = lastLine.replace(/^\\s+/, \"\")\n            // coalesces groups:\n            const marker = happySimpleResult || \"\u2508\"\n            let replacementLastLine =  `  \u2570${marker} ${innerLine}`;\n            // if (replacementLastLine.length < terminalWidth) {\n            //     const extra = \"\u2508\".repeat(terminalWidth - replacementLastLine.length - 1)\n            //     replacementLastLine += \" \" + extra\n            if (replacementLastLine.length > terminalWidth) {\n                const tooMuch = replacementLastLine.length - terminalWidth\n                if (replacementLastLine.endsWith(\"\u2508\".repeat(tooMuch))) {\n                    replacementLastLine = replacementLastLine.slice(0, -tooMuch)\n                }\n            }\n            // replacementLastLine = `  \u2570${marker} ${replacementLastLine}`;\n            if (collapseThisGroup) {\n                content.push(replacementLastLine)\n            } else {\n                content.splice(-1, 1, replacementLastLine)\n            }\n        } else if ((happySimpleResult || noResult) && lastLine?.match(/^\\s*\u2705/)) {\n            // combines the success-indicator on the last line\n            // with the \"close group\" indicator\n            const replacementLastLine = `  \u2570 ${lastLine.replace(/^\\s+/, \"\")}`;\n            if (collapseThisGroup) {\n                content.push(replacementLastLine)\n            } else {\n                content.splice(-1, 1, replacementLastLine)\n            }\n        } else if (result) {\n            const extraClosingLine = `  \u2570 ${result}`;\n            content.push(extraClosingLine)\n        } else {\n            const extraClosingLine = `  \u2570${noResultClosingLine}`;\n            content.push(extraClosingLine)\n        }\n\n        // content.push(lastLine);\n        return content;\n    }\n\n    formatLines(lines: LineOrGroup[]) : string[] {\n        const content: string[] = [];\n        for (const line of lines) {\n            if (typeof line == \"string\") {\n                content.push(line);\n            } else {\n                content.push(... this.formatGroup(line));\n            }\n        }\n        content.at(-1)?.replace(/\\n+$/, \"\");\n        while(content.at(-1)?.match(/^\\n?$/)) {\n            content.pop();\n        }\n        return content;\n    }\n\n    flushLines(footerString?: string) {\n        // this.lines.push(this.accumulator.join(\"\"))\n        let content: string[] = [];\n        // get terminal width if available:\n        const terminalWidth = process?.stdout?.columns || 65;\n        const formattedLines = this.formatLines(this.topLines);\n        this.history.push(formattedLines.join(\"\\n\"));\n        if (!this.didStart) {\n            this.didStart = true;\n            content.push(\"\u256D\u2508\u2508\u2508\u252C\" + \"\u2508\".repeat(terminalWidth - 5) + \"\\n\");\n            this.resetDots();\n        } else if (this.topLines.length) {\n            content.push(\"\u251C\u2508\u2508\u2508\u253C\" + \"\u2508\".repeat(terminalWidth - 5) + \"\\n\");\n            this.resetDots();\n        }\n        for (const line of formattedLines) {\n            //\"\u2502\" or \"\u250A\" or \"\u2506\" or \"\u2507\" // unicode tiny  circle \"\u00B7\"\n            content.push(`${this.showDot()}${line}\\n`);\n        }\n        // adds a little extra space before the footer\n        content.push(this.showDot() + \"\\n\");\n        // feed extra space if needed for the dots to look consistent\n        if (!this.toggler) {\n            content.push(this.showDot() + \"\\n\");\n        }\n        if (footerString) {\n            // if (!this.toggler && abortMarker) {\n            //     content.push(this.showDot());\n            // }\n            content.push(footerString);\n            // if (abortMarker) {\n            //     content.push(abortMarker);\n            // }\n        }\n        const joined = content.join(\"\");\n        this.formattedHistory.push(joined);\n        console.log(joined);\n        this.groupStack = [{\n            name: \"\",\n            lines: []\n        }]\n    }\n    finish() {\n        this.flushLines(\n            \"\u2570\u2508\u2508\u2508\u2534\" + \"\u2508\".repeat((process?.stdout?.columns || 65) - 5)\n        );\n        return this;\n    }\n\n    get groupLines() {\n        return this.groupStack.at(-1)?.lines || [];\n    }\n\n    flush() {\n        if (this.topLines.length) {\n            // console.log(\"    ---- flushing lines\");\n            if (this.lastMessage.at(-1) != \"\") {\n                this.groupLines.push(\"\");\n            }\n            this.flushLines();\n            //     \"\u2570,\"\u2508\"\n            // );\n        }\n        // console.log(\"\u2570 // \u2500\u2500\u2500\u2500\u2500\u2500\n        return this;\n    }\n    flushError(message: string = \"\") {\n        // if (this.lastMsg == message) {\n        //     this.lines.pop();\n        // }\n        if (this.lastMessage.at(-1) != \"\\n\") {\n            this.groupLines.push(\"\\n\");\n        }\n        if (message.at(-1) == \"\\n\") {\n            message = message.slice(0, -1);\n        }\n        const terminalWidth = process?.stdout?.columns || 65;\n        if (message) this.logError(message);\n        if (this.topLines.length) {\n            this.flushLines(\n                \"\u23BD\u23BC\u23BB\u23BA\u23BB\u23BA\u23BC\u23BC\u23BB\u23BA\u23BB\u23BD\u23BC\u23BA\u23BB\u23BB\u23BA\u23BC\u23BC\u23BB\u23BA\".repeat((terminalWidth - 2) / 21)\n            );\n        }\n        // this.didStart = false;\n        return this;\n    }\n}\n", "import {\n    dumpAny,\n    intWithGrouping,\n    lovelaceToAda,\n    txAsString,\n    utxosAsString,\n} from \"./diagnostics.js\";\nimport type { hasUutContext } from \"./CapoTypes.js\";\nimport { UutName } from \"./delegation/UutName.js\";\nimport type { ActorContext, SetupInfo } from \"./StellarContract.js\";\nimport { delegateLinkSerializer } from \"./delegation/jsonSerializers.js\";\nimport type { Cost, UplcData, UplcProgramV2 } from \"@helios-lang/uplc\";\nimport { UplcConsoleLogger } from \"./UplcConsoleLogger.js\";\nimport type { isActivity, SeedAttrs } from \"./ActivityTypes.js\";\nimport {\n    type TxBuilder,\n    type WalletHelper,\n    type Wallet,\n    makeTxBuilder,\n    makeWalletHelper,\n    makeTxChainBuilder,\n} from \"@helios-lang/tx-utils\";\nimport {\n    decodeTx,\n    makeAssets,\n    makeNetworkParamsHelper,\n    makePubKey,\n    makeTx,\n    makeTxBody,\n    makeTxCertifyingRedeemer,\n    makeTxMintingRedeemer,\n    makeTxRewardingRedeemer,\n    makeTxSpendingRedeemer,\n    makeTxWitnesses,\n    makeValue,\n    type Address,\n    type NetworkParams,\n    type PubKeyHash,\n    type Tx,\n    type TxId,\n    type TxInput,\n    type TxOutput,\n    type Value,\n} from \"@helios-lang/ledger\";\nimport { bytesToHex } from \"@helios-lang/codec-utils\";\nimport type { UtxoHelper } from \"./UtxoHelper.js\";\nimport type { IF_ISANY } from \"./helios/typeUtils.js\";\nimport type { Expand } from \"./helios/typeUtils.js\";\nimport { customAlphabet } from \"nanoid\";\nconst nanoid = customAlphabet(\"0123456789abcdefghjkmnpqrstvwxyz\", 12);\nimport { TxNotNeededError } from \"./utils.js\";\n\n/**\n * A txn context having a seedUtxo in its state\n * @public\n **/\nexport type hasSeedUtxo = StellarTxnContext<\n    anyState & {\n        seedUtxo: TxInput;\n    }\n>;\n\nexport type txBuiltOrSubmitted =\n    | \"built\"\n    | \"alreadyPresent\"\n    | \"signed\"\n    | \"submitted\";\nexport type resolvedOrBetter = \"resolved\" | txBuiltOrSubmitted;\n/**\n * @public\n */\nexport type TxDescription<\n    T extends StellarTxnContext,\n    PROGRESS extends\n        | \"buildLater!\"\n        | \"resolved\"\n        | \"alreadyPresent\"\n        | \"built\"\n        | \"signed\"\n        | \"submitted\",\n    TCX extends StellarTxnContext = IF_ISANY<T, StellarTxnContext<anyState>, T>,\n    otherProps extends Record<string, unknown> = {}\n> = {\n    description: string;\n    id: string;\n    parentId?: string;\n    depth: number;\n    moreInfo?: string;\n    optional?: boolean;\n    txName?: string;\n    tcx?: TCX | TxNotNeededError;\n    tx?: Tx;\n    stats?: BuiltTcxStats;\n    txCborHex?: string;\n    signedTxCborHex?: string;\n} & otherProps &\n    (PROGRESS extends \"alreadyPresent}\"\n        ? {\n              mkTcx: (() => TCX) | (() => Promise<TCX>);\n              tcx: TCX & { alreadyPresent: TxNotNeededError };\n          }\n        : PROGRESS extends resolvedOrBetter\n        ? {\n              mkTcx?: (() => TCX) | (() => Promise<TCX>) | undefined;\n              tcx: TCX;\n          }\n        : {\n              mkTcx: (() => TCX) | (() => Promise<TCX>);\n              tcx?: undefined;\n          }) &\n    (PROGRESS extends txBuiltOrSubmitted\n        ? {\n              tx: Tx;\n              txId?: TxId;\n              stats: BuiltTcxStats;\n              options: SubmitOptions;\n              txCborHex: string;\n          }\n        : {}) &\n    (PROGRESS extends \"signed\" | \"submitted\"\n        ? {\n              txId: TxId;\n              txCborHex: string;\n              signedTxCborHex: string;\n              walletTxId: TxId;\n          }\n        : {});\n\n/**\n * @public\n */\nexport type MultiTxnCallback<\n    T extends undefined | StellarTxnContext<any> = StellarTxnContext<any>,\n    TXINFO extends TxDescription<any, resolvedOrBetter, any> = TxDescription<\n        any,\n        \"resolved\"\n    >\n> =\n    | ((txd: TXINFO) => void)\n    | ((txd: TXINFO) => Promise<void>)\n    | ((txd: TXINFO) => T | false)\n    | ((txd: TXINFO) => Promise<T | false>);\n\n/**\n * A transaction context that includes additional transactions in its state for later execution\n * @remarks\n *\n * During the course of creating a transaction, the transaction-building functions for a contract\n * suite may suggest or require further transactions, which may not be executable until after the\n * current transaction is executed.  This type allows the transaction context to include such\n * future transactions in its state, so that they can be executed later.\n *\n * The future transactions can be executed using the {@link StellarTxnContext.queueAddlTxns}\n * helper method.\n * @public\n **/\nexport type hasAddlTxns<\n    TCX extends StellarTxnContext<anyState>,\n    existingStateType extends anyState = TCX[\"state\"]\n> = StellarTxnContext<\n    existingStateType & {\n        addlTxns: Record<string, TxDescription<any, \"buildLater!\">>;\n    }\n>;\n\nexport type otherAddlTxnNames<TCX extends StellarTxnContext<any>> = string &\n    TCX extends { state: { addlTxns: infer aTNs } }\n    ? keyof aTNs\n    : never;\n\n// type combinedAddlTxns<\n//     extraTxnName extends string,\n//     stateType extends anyState,\n//     existingTxns = stateType extends {addlTxns: any} ? stateType[\"addlTxns\"] : never,\n//     existingTxnNames extends string = string & keyof existingTxns\n// > = {\n//     addlTxns: {\n//         //prettier-ignore\n//         [txnName in (\n//             | extraTxnName\n//             | existingTxnNames\n//         )]: AddlTxInfo<any>\n//     }\n// } & stateType;\n\n//!!! if we could access the inputs and outputs in a building Tx,\n//  this might  not be necessary (unless it becomes a\n//   bigger-picture contextual container that serves various Stellar\n//   contract scripts with non-txn context for building a Tx)\n\n/**\n * A base state for a transaction context\n * @public\n **/\nexport interface anyState {\n    uuts: uutMap;\n}\n\n/**\n * A base state for a transaction context\n * @public\n **/\n// export type anyState = emptyState;\nexport type uutMap = Record<string, unknown>;\nexport const emptyUuts: uutMap = Object.freeze({});\n\n// type addInputArgs = Parameters<TxBuilder[\"spend\"]>;\ntype addRefInputArgs = Parameters<TxBuilder[\"refer\"]>;\n\ntype RedeemerArg = {\n    redeemer?: UplcData;\n};\n\nexport type TxDescriptionWithError = TxDescription<\n    any,\n    \"built\",\n    any,\n    {\n        error: string;\n    }\n>;\n\n/**\n * @public\n */\nexport type SubmitOptions = TxPipelineOptions & {\n    /**\n     * indicates additional signers expected for the transaction\n     */\n    signers?: Address[];\n    addlTxInfo?: Partial<\n        Omit<TxDescription<any, \"submitted\">, \"description\">\n    > & { description: string };\n    paramsOverride?: Partial<NetworkParams>;\n    /**\n     * useful most for test environment, so that a txn failure can be me marked\n     * as \"failing as expected\".  Not normally needed for production code.\n     */\n    expectError?: true;\n    /**\n     * Called when there is a detected error, before logging.  Probably only needed in test.\n     */\n    beforeError?: MultiTxnCallback<any, TxDescriptionWithError>;\n    /**\n     * Passed into the Helios TxBuilder's build()/buildUnsafe()\n     */\n    beforeValidate?: (tx: Tx) => MultiTxnCallback<any>;\n};\n\ntype MintUnsafeParams = Parameters<TxBuilder[\"mintPolicyTokensUnsafe\"]>;\ntype MintTokensParams = [\n    MintUnsafeParams[0],\n    MintUnsafeParams[1],\n    { redeemer: MintUnsafeParams[2] }\n];\n/**\n * Provides notifications for various stages of transaction submission\n */\ntype TxPipelineOptions = Expand<\n    TxSubmitCallbacks & {\n        fixupBeforeSubmit?: MultiTxnCallback;\n        whenBuilt?: MultiTxnCallback<any, TxDescription<any, \"built\">>;\n    }\n>;\n\nexport type TxSubmitCallbacks = {\n    onSubmitError?: MultiTxnCallback<\n        any,\n        TxDescription<any, \"built\", any, { error: string }>\n    >;\n    onSubmitted?: MultiTxnCallback<any, TxDescription<any, \"submitted\">>;\n};\n\ntype BuiltTcx = {\n    tx: Tx;\n} & BuiltTcxStats;\n\ntype BuiltTcxStats = {\n    willSign: PubKeyHash[];\n    walletMustSign: boolean;\n    wallet: Wallet;\n    wHelper: WalletHelper<any>;\n    costs: {\n        total: Cost;\n        [key: string]: Cost;\n    };\n};\n\nexport type FacadeTxnContext<S extends anyState = anyState> = hasAddlTxns<\n    StellarTxnContext<S>\n> & {\n    isFacade: true;\n};\n\n/**\n * Transaction-building context for Stellar Contract transactions\n * @remarks\n *\n * Uses same essential facade as Helios Tx.\n *\n * Adds a transaction-state container with strong typing of its contents,\n * enabling transaction-building code to use type-sensitive auto-complete\n * and allowing Stellar Contracts library code to require transaction contexts\n * having known states.\n *\n * Retains reflection capabilities to allow utxo-finding utilities to exclude\n * utxo's already included in the contract.\n *\n * @typeParam S - type of the context's `state` prop\n * @public\n **/\nexport class StellarTxnContext<S extends anyState = anyState> {\n    id: string = nanoid(5);\n    inputs: TxInput[] = [];\n    collateral?: TxInput;\n    outputs: TxOutput[] = [];\n    feeLimit?: bigint;\n    state: S;\n    allNeededWitnesses: (Address | PubKeyHash)[] = [];\n    otherPartySigners: PubKeyHash[] = [];\n    parentTcx?: StellarTxnContext<any>;\n    childReservedUtxos: TxInput[] = [];\n    parentId: string = \"\";\n    alreadyPresent: TxNotNeededError | undefined = undefined;\n    depth = 0;\n    declare setup: SetupInfo;\n    // submitOptions?: SubmitOptions\n    txb: TxBuilder;\n    txnName: string = \"\";\n    withName(name: string) {\n        this.txnName = name;\n        return this;\n    }\n\n    get wallet() {\n        return this.setup.actorContext.wallet!;\n    }\n\n    get uh(): UtxoHelper {\n        return this.setup.uh!;\n    }\n\n    get networkParams(): NetworkParams {\n        return this.setup.networkParams;\n    }\n\n    get actorContext(): ActorContext<any> {\n        return this.setup.actorContext;\n    }\n    /**\n     * Provides a lightweight, NOT complete, serialization for presenting the transaction context\n     * @remarks\n     * Serves rendering of the transaction context in vitest\n     * @internal\n     */\n    toJSON() {\n        return {\n            kind: \"StellarTxnContext\",\n            state: !!this.state\n                ? `{${Object.keys(this.state).join(\", \")}}`\n                : undefined,\n            inputs: `[${this.inputs.length} inputs]`,\n            outputs: `[${this.outputs.length} outputs]`,\n            isBuilt: !!this._builtTx,\n            hasParent: !!this.parentTcx,\n            //@ts-expect-error\n            addlTxns: this.state.addlTxns\n                ? [\n                      //@ts-expect-error\n                      ...Object.keys(this.state.addlTxns || {}),\n                  ]\n                : undefined,\n        };\n    }\n\n    logger = new UplcConsoleLogger();\n    constructor(\n        setup: SetupInfo,\n        state: Partial<S> = {},\n        parentTcx?: StellarTxnContext<any>\n    ) {\n        if (parentTcx) {\n            console.warn(\n                \"Deprecated use of 'parentTcx' - use includeAddlTxn() instead\" +\n                    \"\\n  ... setup.txBatcher.current holds an in-progress utxo set for all 'parent' transactions\"\n            );\n            throw new Error(`parentTcx used where? `);\n        }\n        Object.defineProperty(this, \"setup\", {\n            enumerable: false,\n            value: setup,\n        });\n        Object.defineProperty(this, \"_builtTx\", {\n            enumerable: false,\n            writable: true,\n        });\n\n        const isMainnet = setup.isMainnet;\n        this.isFacade = undefined;\n\n        if (\"undefined\" == typeof isMainnet) {\n            throw new Error(\n                \"StellarTxnContext: setup.isMainnet must be defined\"\n            );\n        }\n        this.txb = makeTxBuilder({\n            isMainnet,\n        });\n        // const { uuts = { ...emptyUuts }, ...moreState } = state;\n        //@ts-expect-error\n        this.state = {\n            ...state,\n            uuts: state.uuts || { ...emptyUuts },\n        };\n\n        const currentBatch = this.currentBatch;\n        const hasOpenBatch = currentBatch?.isOpen;\n        if (!currentBatch || currentBatch.isConfirmationComplete) {\n            this.setup.txBatcher.rotate(this.setup.chainBuilder);\n        }\n\n        if (!this.setup.isTest && !this.setup.chainBuilder) {\n            if (currentBatch.chainBuilder) {\n                // backfills the chainbuilder from the one auto-populated\n                // during `get TxBatcher.current()`\n                this.setup.chainBuilder = currentBatch.chainBuilder;\n            } else {\n                this.setup.chainBuilder = makeTxChainBuilder(\n                    this.setup.network\n                );\n            }\n        }\n\n        if (parentTcx) {\n            debugger;\n            throw new Error(`parentTcx used where? `);\n        }\n        this.parentTcx = parentTcx;\n    }\n\n    isFacade: true | false | undefined;\n    facade(this: StellarTxnContext): hasAddlTxns<this> & { isFacade: true } {\n        if (this.isFacade === false)\n            throw new Error(`this tcx already has txn material`);\n        if (this.parentTcx)\n            throw new Error(`no parentTcx allowed for tcx facade`);\n\n        const t: hasAddlTxns<this> = this as any;\n        t.state.addlTxns = t.state.addlTxns || {};\n        t.isFacade = true;\n        return this as any;\n    }\n    noFacade(situation: string) {\n        if (this.isFacade)\n            throw new Error(\n                `${situation}: ${\n                    this.txnName || \"this tcx\"\n                } is a facade for nested multi-tx`\n            );\n        this.isFacade = false;\n    }\n\n    withParent(tcx: StellarTxnContext<any>) {\n        this.noFacade(\"withParent\");\n        this.parentTcx = tcx;\n        return this;\n    }\n\n    get actorWallet() {\n        return this.actorContext.wallet;\n    }\n\n    dump(tx?: Tx): string;\n    dump(): Promise<string>;\n    dump(tx?: Tx): string | Promise<string> {\n        const t = tx || this.builtTx;\n        if (t instanceof Promise) {\n            return t.then((tx) => {\n                return txAsString(tx, this.setup.networkParams);\n            });\n        }\n        return txAsString(t, this.setup.networkParams);\n    }\n\n    includeAddlTxn<\n        TCX extends StellarTxnContext<anyState>,\n        RETURNS extends hasAddlTxns<TCX> = TCX extends hasAddlTxns<any>\n            ? TCX\n            : hasAddlTxns<TCX>\n    >(\n        this: TCX,\n        txnName: string,\n        txInfoIn: Omit<\n            TxDescription<any, \"buildLater!\">,\n            \"id\" | \"depth\" | \"parentId\"\n        > & {\n            id?: string;\n        }\n    ): RETURNS {\n        const txInfo: TxDescription<any, \"buildLater!\"> = {\n            ...(txInfoIn as any),\n        };\n        if (!txInfo.id)\n            txInfo.id =\n                //@ts-expect-error - the tcx is never there,\n                // but including the fallback assignment here for\n                // consistency about the policy of syncing to it.\n                txInfo.tcx?.id || nanoid(5);\n\n        txInfo.parentId = this.id;\n\n        txInfo.depth = (this.depth || 0) + 1;\n        const thisWithMoreType: RETURNS = this as any;\n        if (\"undefined\" == typeof this.isFacade) {\n            throw new Error(\n                `to include additional txns on a tcx with no txn details, call facade() first.\\n` +\n                    `   ... otherwise, add txn details first or set isFacade to false`\n            );\n        }\n        // if (thisWithMoreType.state.addlTxns?.[txnName]) {\n        //     debugger\n        //     throw new Error(\n        //         `addlTxns['${txnName}'] already included in this transaction:\\n` +\n        //             Object.keys(thisWithMoreType.state.addlTxns).map(\n        //                 (k) => ` \u2022 ${k}`\n        //             ).join(\"\\n\")\n        //     );\n        // }\n        thisWithMoreType.state.addlTxns = {\n            ...(thisWithMoreType.state.addlTxns || {}),\n            [txInfo.id]: txInfo,\n        };\n        return thisWithMoreType;\n    }\n\n    /**\n     * @public\n     */\n    get addlTxns(): Record<string, TxDescription<any, \"buildLater!\">> {\n        //@ts-expect-error\n        return this.state.addlTxns || {};\n    }\n\n    mintTokens(...args: MintTokensParams): StellarTxnContext<S> {\n        this.noFacade(\"mintTokens\");\n        const [policy, tokens, r = { redeemer: undefined }] = args;\n        const { redeemer } = r;\n        if (this.txb.mintPolicyTokensUnsafe) {\n            this.txb.mintPolicyTokensUnsafe(policy, tokens, redeemer);\n        } else {\n            //@ts-expect-error\n            this.txb.mintTokens(policy, tokens, redeemer);\n        }\n\n        return this;\n    }\n\n    getSeedAttrs<TCX extends hasSeedUtxo>(this: TCX): SeedAttrs {\n        this.noFacade(\"getSeedAttrs\");\n        // const { seedUtxo } = this.state;  // bad api-extractor!\n        const seedUtxo = this.state.seedUtxo;\n        // const { txId, utxoIdx: seedIndex } = seedUtxo.id; // ugh, api-extractor!\n        return { txId: seedUtxo.id.txId, idx: BigInt(seedUtxo.id.index) };\n    }\n\n    reservedUtxos(): TxInput[] {\n        this.noFacade(\"reservedUtxos\");\n        return this.parentTcx\n            ? this.parentTcx.reservedUtxos()\n            : ([\n                  ...this.inputs,\n                  this.collateral,\n                  ...this.childReservedUtxos,\n              ].filter((x) => !!x) as TxInput[]);\n    }\n\n    utxoNotReserved(u: TxInput): TxInput | undefined {\n        if (this.collateral?.isEqual(u)) return undefined;\n        if (this.inputs.find((i) => i.isEqual(u))) return undefined;\n        return u;\n    }\n\n    addUut<T extends string, TCX extends StellarTxnContext>(\n        this: TCX,\n        //!!! todo: type this more strongly by adding strong typing to the UutName itself?\n        uutName: UutName,\n        ...names: T[]\n    ): hasUutContext<T> & TCX {\n        this.noFacade(\"addUut\");\n        this.state.uuts = this.state.uuts || {};\n\n        for (const name of names) {\n            this.state.uuts[name] = uutName;\n        }\n\n        return this as hasUutContext<T> & TCX;\n    }\n\n    addState<TCX extends StellarTxnContext, K extends string, V>(\n        this: TCX,\n        key: K,\n        value: V\n    ): StellarTxnContext<{ [keyName in K]: V } & anyState> & TCX {\n        this.noFacade(\"addState\");\n        //@ts-expect-error\n        this.state[key] = value;\n        return this as StellarTxnContext<{ [keyName in K]: V } & anyState> &\n            TCX;\n    }\n\n    addCollateral(collateral: TxInput) {\n        this.noFacade(\"addCollateral\");\n        console.warn(\"explicit addCollateral() should be unnecessary unless a babel payer is covering it\")\n        \n        if (!collateral.value.assets.isZero()) {\n            throw new Error(\n                `invalid attempt to add non-pure-ADA utxo as collateral`\n            );\n        }\n        this.collateral = collateral;\n\n        this.txb.addCollateral(collateral);\n        return this;\n    }\n    getSeedUtxoDetails(this: hasSeedUtxo): SeedAttrs {\n        this.noFacade(\"getSeedUtxoDetails\");\n        const seedUtxo = this.state.seedUtxo;\n        return {\n            txId: seedUtxo.id.txId,\n            idx: BigInt(seedUtxo.id.index),\n        };\n    }\n\n    _txnTime?: Date;\n    /**\n     * Sets a future date for the transaction to be executed, returning the transaction context.  Call this before calling validFor().\n     *\n     * @remarks Returns the txn context.\n     * Throws an error if the transaction already has a txnTime set.\n     *\n     * This method does not itself set the txn's validity interval.  You MUST combine it with\n     * a call to validFor(), to set the txn's validity period.  The resulting transaction will\n     * be valid from the moment set here until the end of the validity period set by validFor().\n     *\n     * This can be used anytime to construct a transaction valid in the future.  This is particularly useful\n     * during test scenarios to verify time-sensitive behaviors.\n     *\n     * In the test environment, the network wil normally be advanced to this date\n     * before executing the transaction, unless a different execution time is indicated.\n     * Use the test helper's `submitTxnWithBlock(txn, {futureDate})` or `advanceNetworkTimeForTx()` methods, or args to\n     * use-case-specific functions that those methods.\n     */\n    futureDate<TCX extends StellarTxnContext<S>>(this: TCX, date: Date) {\n        this.noFacade(\"futureDate\");\n        if (this._txnTime) {\n            throw new Error(\n                \"txnTime already set; cannot set futureDate() after txnTime\"\n            );\n        }\n\n        const d = new Date(\n            Number(this.slotToTime(this.timeToSlot(BigInt(date.getTime()))))\n        );\n        // time emoji: \u23F0\n        console.log(\"  \u23F0\u23F0 setting txnTime to \", d.toString());\n        this._txnTime = d;\n        return this;\n    }\n\n    assertNumber(obj, msg = \"expected a number\") {\n        if (obj === undefined || obj === null) {\n            throw new Error(msg);\n        } else if (typeof obj == \"number\") {\n            return obj;\n        } else {\n            throw new Error(msg);\n        }\n    }\n\n    /**\n     * Calculates the time (in milliseconds in 01/01/1970) associated with a given slot number.\n     * @param slot - Slot number\n     */\n    slotToTime(slot: bigint): bigint {\n        let secondsPerSlot = this.assertNumber(\n            this.networkParams.secondsPerSlot\n        );\n\n        let lastSlot = BigInt(this.assertNumber(this.networkParams.refTipSlot));\n        let lastTime = BigInt(this.assertNumber(this.networkParams.refTipTime));\n\n        let slotDiff = slot - lastSlot;\n\n        return lastTime + slotDiff * BigInt(secondsPerSlot * 1000);\n    }\n\n    /**\n     * Calculates the slot number associated with a given time.\n     * @param time - Milliseconds since 1970\n     */\n    timeToSlot(time: bigint): bigint {\n        let secondsPerSlot = this.assertNumber(\n            this.networkParams.secondsPerSlot\n        );\n\n        let lastSlot = BigInt(this.assertNumber(this.networkParams.refTipSlot));\n        let lastTime = BigInt(this.assertNumber(this.networkParams.refTipTime));\n\n        let timeDiff = time - lastTime;\n\n        return (\n            lastSlot +\n            BigInt(Math.round(Number(timeDiff) / (1000 * secondsPerSlot)))\n        );\n    }\n\n    /**\n     * Identifies the time at which the current transaction is expected to be executed.\n     * Use this attribute in any transaction-building code that sets date/time values\n     * for the transaction.\n     * Honors any futureDate() setting or uses the current time if none has been set.\n     */\n    get txnTime() {\n        if (this._txnTime) return this._txnTime;\n        const now = Date.now();\n        const recent = now - 180_000;\n        const d = new Date(\n            Number(this.slotToTime(this.timeToSlot(BigInt(recent))))\n        );\n        // time emoji: \u23F0\n        console.log(\"\u23F0\u23F0setting txnTime to \", d.toString());\n        return (this._txnTime = d);\n    }\n\n    _txnEndTime?: Date;\n    get txnEndTime() {\n        if (this._txnEndTime) return this._txnEndTime;\n        throw new Error(\"call [optional: futureDate() and] validFor(durationMs) before fetching the txnEndTime\")\n    }\n        \n   /**\n     * Sets an on-chain validity period for the transaction, in miilliseconds\n     *\n     * @remarks if futureDate() has been set on the transaction, that\n     * date will be used as the starting point for the validity period.\n     *\n     * Returns the transaction context for chaining.\n     *\n     * @param durationMs - the total validity duration for the transaction.  On-chain\n     *  checks using CapoCtx `now(granularity)` can enforce this duration\n     */\n    validFor<TCX extends StellarTxnContext<S>>(\n        this: TCX,\n        durationMs: number\n    ): TCX {\n        this.noFacade(\"validFor\");\n        const startMoment = this.txnTime.getTime();\n\n        // if the desired duration is greater  the current validity period,\n        //   DO NOT constraint the validity period further.\n        // If the current validity period is greater than the desired duration,\n        //   we SHOULD constrain the tx validity to this more restrictive duration.\n        this._validityPeriodSet = true;\n        this.txb\n            .validFromTime(new Date(startMoment))\n            .validToTime(new Date(startMoment + durationMs));\n\n        return this;\n    }\n    _validityPeriodSet = false;\n    txRefInputs: TxInput[] = [];\n    /**\n     * adds a reference input to the transaction context\n     * @remarks\n     *\n     * idempotent version of helios addRefInput()\n     *\n     * @public\n     **/\n    addRefInput<TCX extends StellarTxnContext<S>>(\n        this: TCX,\n        input: TxInput<any>,\n        refScript?: UplcProgramV2\n    ) {\n        this.noFacade(\"addRefInput\");\n        if (!input) throw new Error(`missing required input for addRefInput()`);\n\n        if (this.txRefInputs.find((v) => v.id.isEqual(input.id))) {\n            console.warn(\"suppressing second add of refInput\");\n            return this;\n        }\n        if (this.inputs.find((v) => v.id.isEqual(input.id))) {\n            console.warn(\n                \"suppressing add of refInput that is already an input\"\n            );\n            return this;\n        }\n        this.txRefInputs.push(input);\n\n        //@ts-expect-error private field\n        const v2sBefore = this.txb.v2Scripts;\n        if (refScript) {\n            //@ts-expect-error on private method\n            this.txb.addV2RefScript(refScript);\n        }\n\n        this.txb.refer(input);\n        //@ts-expect-error private field\n        const v2sAfter = this.txb.v2Scripts;\n\n        // const t2 = this.txb.witnesses.scripts.length;\n        // if (t2 > t) {\n        if (v2sAfter.length > v2sBefore.length) {\n            console.log(\"       --- addRefInput added a script to tx.scripts\");\n        }\n\n        return this;\n    }\n\n    /**\n     * @deprecated - use addRefInput() instead.\n     */\n    addRefInputs<TCX extends StellarTxnContext<S>>(\n        this: TCX,\n        ...args: addRefInputArgs\n    ) {\n        throw new Error(`deprecated`);\n    }\n\n    addInput<TCX extends StellarTxnContext<S>>(\n        this: TCX,\n        input: TxInput,\n        r?: isActivity\n    ): TCX {\n        this.noFacade(\"addInput\");\n        if (r && !r.redeemer) {\n            console.log(\"activity without redeemer tag: \", r);\n            throw new Error(\n                `addInput() redeemer must match the isActivity type {redeemer: \u2039activity\u203A}\\n`\n                // JSON.stringify(r, delegateLinkSerializer)\n            );\n        }\n\n        //@ts-expect-error probing for pubKeyHash\n        if (input.address.pubKeyHash)\n            this.allNeededWitnesses.push(input.address);\n        this.inputs.push(input);\n        if (this.parentTcx) {\n            this.parentTcx.childReservedUtxos.push(input);\n        }\n        try {\n            this.txb.spendUnsafe(input, r?.redeemer);\n        } catch (e: any) {\n            // console.log(\"failed adding input to txn: \", dumpAny(this));\n            debugger;\n            throw new Error(\n                `addInput: ${e.message}` +\n                    \"\\n   ...TODO: dump partial txn from txb above.  Failed TxInput:\\n\" +\n                    dumpAny(input)\n            );\n        }\n\n        return this;\n    }\n\n    addOutput<TCX extends StellarTxnContext<S>>(\n        this: TCX,\n        output: TxOutput\n    ): TCX {\n        this.noFacade(\"addOutput\");\n        try {\n            this.txb.addOutput(output);\n            this.outputs.push(output);\n        } catch (e: any) {\n            console.log(\n                \"Error adding output to txn: \\n\" +\n                    \"  | inputs:\\n  | \" +\n                    utxosAsString(this.inputs, \"\\n  | \") +\n                    \"\\n  | \" +\n                    (dumpAny(this.outputs) as string)\n                        .split(\"\\n\")\n                        .join(\"\\n  |   \") +\n                    \"\\n... in context of partial tx above: failed adding output: \\n  |  \",\n                dumpAny(output),\n                \"\\n\" + e.message,\n                \"\\n   (see thrown stack trace below)\"\n            );\n            e.message =\n                `addOutput: ${e.message}` + \"\\n   ...see logged details above\";\n            throw e;\n        }\n\n        return this;\n    }\n\n    attachScript(...args: Parameters<TxBuilder[\"attachUplcProgram\"]>) {\n        throw new Error(\n            `use addScriptProgram(), increasing the txn size, if you don't have a referenceScript.\\n` +\n                `Use <capo>.txnAttachScriptOrRefScript() to use a referenceScript when available.`\n        );\n    }\n\n    /**\n     * Adds a UPLC program to the transaction context, increasing the transaction size.\n     * @remarks\n     * Use the Capo's `txnAttachScriptOrRefScript()` method to use a referenceScript\n     * when available. That method uses a fallback approach adding the script to the\n     * transaction if needed.\n     */\n    addScriptProgram(...args: Parameters<TxBuilder[\"attachUplcProgram\"]>) {\n        this.noFacade(\"addScriptProgram\");\n        this.txb.attachUplcProgram(...args);\n\n        return this;\n    }\n\n    wasModified() {\n        //@ts-expect-error private method\n        this.txb.wasModified();\n    }\n\n    _builtTx?: Tx | Promise<Tx>;\n    get builtTx() {\n        this.noFacade(\"builtTx\");\n        if (!this._builtTx) {\n            throw new Error(`can't go building the tx willy-nilly`);\n            return (this._builtTx = this.build().then(({ tx }) => {\n                return (this._builtTx = tx);\n            }));\n        }\n        return this._builtTx;\n    }\n\n    async addSignature(wallet: Wallet) {\n        this.noFacade(\"addSignature\");\n        const builtTx = await this.builtTx;\n        const sig = await wallet.signTx(builtTx);\n\n        builtTx.addSignature(sig[0]);\n    }\n\n    hasAuthorityToken(authorityValue: Value) {\n        return this.inputs.some(i => i.value.isGreaterOrEqual(authorityValue))\n    }\n\n    async findAnySpareUtxos(): Promise<TxInput[] | never> {\n        this.noFacade(\"findAnySpareUtxos\");\n        const mightNeedFees = 3_500_000n; // lovelace this.ADA(3.5);\n\n        const toSortInfo = this.uh.mkUtxoSortInfo(mightNeedFees);\n        const notReserved =\n            this.utxoNotReserved.bind(this) || ((u: TxInput) => u);\n\n        const uh = this.uh;\n        return uh\n            .findActorUtxo(\n                \"spares for tx balancing\",\n                notReserved,\n                {\n                    wallet: this.wallet,\n                    dumpDetail: \"onFail\",\n                },\n                \"multiple\"\n            )\n            .then(async (utxos) => {\n                if (!utxos) {\n                    throw new Error(\n                        `no utxos found for spares for tx balancing.  We can ask the user to send a series of 10, 11, 12, ... ADA to themselves or do it automatically`\n                    );\n                }\n\n                const allSpares = utxos\n                    .map(toSortInfo)\n                    .filter(uh.utxoIsSufficient)\n                    .sort(uh.utxoSortSmallerAndPureADA);\n\n                if (allSpares.reduce(uh.reduceUtxosCountAdaOnly, 0) > 0) {\n                    return allSpares\n                        .filter(uh.utxoIsPureADA)\n                        .map(uh.sortInfoBackToUtxo);\n                }\n                return allSpares.map(uh.sortInfoBackToUtxo);\n            });\n    }\n\n    async findChangeAddr(): Promise<Address> {\n        this.noFacade(\"findChangeAddr\");\n        // const {\n        //     actorContext: { wallet },\n        // } = this; // ugh, api-extractor!\n        const wallet = this.actorContext.wallet;\n        if (!wallet) {\n            throw new Error(\n                `\u26A0\uFE0F  ${this.constructor.name}: no this.actorContext.wallet; can't get required change address!`\n            );\n        }\n        let unused = (await wallet.unusedAddresses).at(0);\n        if (!unused) unused = (await wallet.usedAddresses).at(-1);\n        if (!unused)\n            throw new Error(\n                `\u26A0\uFE0F  ${this.constructor.name}: can't find a good change address!`\n            );\n        return unused;\n    }\n\n    /**\n     * Adds required signers to the transaction context\n     * @remarks\n     * Before a transaction can be submitted, signatures from each of its signers must be included.\n     * \n     * Any inputs from the wallet are automatically added as signers, so addSigners() is not needed\n     * for those.\n     */\n    async addSigners(...signers: PubKeyHash[]) {\n        this.noFacade(\"addSigners\");\n        \n        this.allNeededWitnesses.push(...signers);\n    }\n\n    async build(\n        this: StellarTxnContext<any>,\n        {\n            signers = [],\n            addlTxInfo = {\n                description: this.txnName ? \": \" + this.txnName : \"\",\n            },\n            beforeValidate,\n            paramsOverride,\n            expectError,\n        }: {\n            signers?: Address[];\n            addlTxInfo?: Pick<TxDescription<any, \"buildLater!\">, \"description\">;\n            beforeValidate?: (tx: Tx) => Promise<any> | any;\n            paramsOverride?: Partial<NetworkParams>;\n            expectError?: boolean;\n        } = {}\n    ): Promise<BuiltTcx> {\n        this.noFacade(\"build\");\n        console.timeStamp?.(`submit() txn ${this.txnName}`);\n        console.log(\"tcx build() @top\");\n\n        if (!this._validityPeriodSet) {\n            this.validFor(12 * 60 * 1000); // 12 minutes\n            // this.validFor(12 * 60 * 1000 * 60 * 24); // 12 days\n        }\n        let { description } = addlTxInfo;\n        if (description && !description.match(/^:/)) {\n            description = \": \" + description;\n        }\n        const {\n            actorContext: { wallet },\n        } = this;\n\n        let walletMustSign = false;\n        let tx: Tx;\n\n        const logger = this.logger;\n        if (wallet || signers.length) {\n            console.timeStamp?.(`submit(): findChangeAddr()`);\n            const changeAddress = await this.findChangeAddr();\n\n            console.timeStamp?.(`submit(): findAnySpareUtxos()`);\n            const spares = await this.findAnySpareUtxos();\n\n            const willSign = [...signers, ...this.allNeededWitnesses]\n                .map((addrOrPkh) => {\n                    if (addrOrPkh.kind == \"PubKeyHash\") {\n                        return addrOrPkh;\n                    } else if (addrOrPkh.kind == \"Address\") {\n                        if (addrOrPkh.era == \"Shelley\") {\n                            return addrOrPkh.spendingCredential.kind == \"PubKeyHash\"\n                                ? addrOrPkh.spendingCredential\n                                : undefined;\n                        } else {\n                            return undefined;\n                        }\n                    } else {\n                        return undefined;\n                    }\n                })\n                .filter((pkh) => !!pkh)\n                .flat(1) as PubKeyHash[];\n            console.timeStamp?.(`submit(): addSIgners()`);\n            this.txb.addSigners(...willSign);\n            const wHelper = wallet && makeWalletHelper(wallet);\n            const othersMustSign: PubKeyHash[] = [];\n            // determine whether we need to request signing from wallet.\n            // may involve adding signers to the txn\n            if (wallet && wHelper) {\n                for (const a of willSign) {\n                    if (await wHelper.isOwnAddress(a)) {\n                        walletMustSign = true;\n                    } else {\n                        othersMustSign.push(a);\n                    }\n                }\n                this.otherPartySigners = othersMustSign;\n                // if any inputs from the wallet were added as part of finalizing,\n                // add the wallet's signature to the txn\n                const inputs = this.txb.inputs;\n                if (!inputs) throw new Error(`no inputs in txn`);\n                for (const input of inputs) {\n                    if (!(await wHelper.isOwnAddress(input.address))) continue;\n                    this.allNeededWitnesses.push(input.address);\n                    walletMustSign = true;\n\n                    //@ts-expect-error on type-probe\n                    const pubKeyHash = input.address.pubKeyHash;\n\n                    if (pubKeyHash) {\n                        this.txb.addSigners(pubKeyHash);\n                    } else {\n                        //!!! todo: deal with \"native-script\" by traversing its\n                        //  struct and seeking the pubKeyHashes (or? other witnesses)\n                        //  that may be needed for signing.  That, or include the\n                        //  native-script information alongside the otherPartySigners,\n                        //  maybe as otherPartyScriptSigners or something.  The\n                        //  batch-submit-controller could take over the responsibility\n                        //  for finding signatures satisfactory for those.\n                    }\n                }\n            } else {\n                console.warn(\n                    \"txn build: no wallet/helper available for txn signining (debugging breakpoint available)\"\n                );\n                debugger; // eslint-disable-line no-debugger - keep for downstream troubleshooting\n            }\n            let capturedCosts: {\n                total: Cost;\n                [key: string]: Cost;\n            } = {\n                total: { cpu: 0n, mem: 0n },\n                slush: { cpu: 0n, mem: 0n },\n            };\n\n            const inputValues = this.inputs\n                .map((i) => i.value.assets)\n                .reduce((a, b) => a.add(b), makeAssets());\n            const outputValues = this.outputs\n                .map((o) => o.value.assets)\n                .reduce((a, b) => a.add(b), makeAssets());\n            const mintValues = this.txb.mintedTokens;\n            const netTxAssets = inputValues\n                .add(mintValues)\n                .subtract(outputValues);\n            if (!netTxAssets.isZero()) {\n                console.log(\n                    \"tx imbalance=\" + dumpAny(netTxAssets, this.networkParams)\n                );\n            }\n            try {\n                // the transaction can fail validation without throwing an error\n                tx = await this.txb.buildUnsafe({\n                    changeAddress,\n                    spareUtxos: spares,\n                    networkParams: {\n                        ...this.networkParams,\n                        ...paramsOverride,\n                    },\n                    logOptions: logger,\n                    beforeValidate,\n                    modifyExBudget: (txi, purpose, index, costs) => {\n                        capturedCosts[`${purpose} @${1 + index}`] = {\n                            ...costs,\n                        };\n\n                        // todo: use Ogmios API to just get the exact costs\n                        //   ... and report here when there is a diff.\n                        // Meanwhile, add a small amount (0.05 ADA) of padding\n                        //   ... to the computed costs, per involved script\n\n                        // temp? - + ~0.06 ada = 1.2x 0.05\n                        // const cpuSlush = 0n // BigInt(350_000_000n); // ~25k lovelace\n                        // const memSlush = 0n // BigInt(430_000n); // ~25k lovelace\n\n                        // without this, we **sometimes** get problems having enough\n                        // exBudget to cover the way the haskell node computes the\n                        // per-script execution costs.  Prevents \"out of budget\" errors\n                        // during script execution:\n                        const cpuSlush = BigInt(250_000_000n); // ~25k lovelace\n                        const memSlush = BigInt(50_000n); // ~25k lovelace\n\n                        //... but doesn't suffice to just add per-script slush:\n                        // this approach leads to escalating \"expected/actual fee\" messaging\n                        // const cpuSlush = BigInt( 350_000_000n * 13n / 10n); // ~25k lovelace/0.025 ADA\n                        // const memSlush = BigInt(430_000n * 13n / 10n); // ~25k lovelace/0.025 ADA\n\n                        capturedCosts.slush.cpu += cpuSlush;\n                        capturedCosts.slush.mem += memSlush;\n                        costs.cpu += cpuSlush;\n                        costs.mem += memSlush;\n\n                        capturedCosts.total.cpu += costs.cpu;\n                        capturedCosts.total.mem += costs.mem;\n                        if (\"minting\" == purpose) purpose = \"minting \";\n                        return costs;\n                    },\n                });\n                this._builtTx = tx;\n\n                this.txb.validToTime;\n\n                //!!! todo: come back to this later.  Blockfrost's endpoint for this\n                // seems to have some issues.  Ogmios itself seems to be fine.\n                //\n                // //@ts-expect-error on type-probe\n                // if (this.setup.network.evalTx) {\n                //     const partialTx = undoFeesFrom(tx)\n                //     console.log(bytesToHex(partialTx.toCbor()))\n                //     //@ts-expect-error on type-probe\n                //     const evalResult = await this.setup.network.evalTx(\n                //         partialTx\n                //     );\n                //     debugger\n                // }\n            } catch (e: any) {\n                // buildUnsafe shouldn't throw errors.\n\n                e.message +=\n                    \"; txn build failed (debugging breakpoint available)\\n\" +\n                    (netTxAssets.isZero()\n                        ? \"\"\n                        : \"tx imbalance=\" +\n                          dumpAny(netTxAssets, this.networkParams)) +\n                    `  inputs: ${dumpAny(this.inputs)}\\n` +\n                    `  outputs: ${dumpAny(this.outputs)}\\n` +\n                    `  mint: ${dumpAny(this.txb.mintedTokens)}\\n` +\n                    `  refInputs: ${dumpAny(this.txRefInputs)}\\n`;\n\n                logger.logError(`txn build failed: ${e.message}`);\n                if (tx!) logger.logPrint(dumpAny(tx!) as string);\n\n                logger.logError(\n                    `  (it shouldn't be possible for buildUnsafe to be throwing errors!)`\n                );\n                logger.flushError();\n\n                throw e;\n            }\n\n            if (tx.hasValidationError) {\n                const e = tx.hasValidationError;\n\n                //@ts-expect-error accessing the stack of something that might be a string instead\n                let heliosStack = e.stack?.split(\"\\n\") || undefined;\n                // locate the first TxImpl line in the stack trace.\n                // include it but remove remaining trace lines.\n                // heliosStack = heliosStack?.slice(\n                //     0, heliosStack.findIndex(l => l.match(/TxImpl/)) + 2\n                // ) || \"\"\n                // locate any lines like \"<helios>@at <anonymous>, [mkTv=<fn>, tvCharter=<fn>, mustFindInputRedeemer=<fn>, fromCip68Wrapper=<fn>, RelativeDelegateLink::tvAuthorityToken=<fn>, RelativeDelegateLink::acAuthorityToken=<fn>, RelativeDelegateLink::validatesUpdatedSettings=<fn>, RelativeDelegateLink::hasDelegateInput=<fn>, RelativeDelegateLink::hasValidOutput=<fn>, DelegateInput::genericDelegateActivity=<fn>], src/CapoHelpers.hl:761:9:0\"\n                // and transform it to a multi-line, indented function trace with the\n                // square-bracketed items indented to indicate the scope of the function they're provided to\n                heliosStack = heliosStack?.map((line: string) => {\n                    if (line.match(/<helios>@at/)) {\n                        line = line\n                            .replace(\n                                /<helios>@at /,\n                                \"   ... in helios function \"\n                            )\n                            .replace(\n                                /, \\[(.*)\\],/,\n                                (_, bracketed) => ``\n                                // ` with scope [\\n        ${\n                                //     bracketed.replace(/, /g, \",\\n        \")\n                                // }\\n      ]`\n                            );\n                    }\n                    return line;\n                });\n                debugger; // eslint-disable-line no-debugger - keep for downstream troubleshooting\n                const scriptContext =\n                    \"string\" == typeof e ? undefined : e.scriptContext;\n                logger.logError(\n                    `tx validation failure: \\n  \u274C ${\n                        //@ts-expect-error\n                        tx.hasValidationError.message || tx.hasValidationError\n                    }\\n` + (heliosStack?.join(\"\\n\") || \"\")\n                );\n                logger.flush();\n                // TODO: notify the currentBatch and let it reveal the script-context\n                // and tx-cbor.  KEEP THE console LOGGING for now ALSO.\n\n                const ctxCbor = scriptContext?.toCbor();\n                const cborHex = ctxCbor ? bytesToHex(ctxCbor) : \"\";\n                if (!expectError) {\n                    console.log(\n                        cborHex\n                            ? \"------------------- failed ScriptContext as cbor-hex -------------------\\n\" +\n                                  cborHex +\n                                  \"\\n\"\n                            : \"\",\n                        \"------------------- failed tx as cbor-hex -------------------\\n\" +\n                            bytesToHex(tx.toCbor()),\n                        \"\\n------------------^ failed tx details ^------------------\\n\" +\n                            \"(debugging breakpoint available)\"\n                    );\n                }\n            }\n\n            // tx.body.fee = tx.body.fee + BigInt(250_000n); // 25k lovelace\n            return {\n                tx,\n                willSign,\n                walletMustSign,\n                wallet,\n                wHelper,\n                costs: capturedCosts,\n            };\n        } else {\n            throw new Error(\"no 'actorContext.wallet'; can't make  a txn\");\n        }\n    }\n    log(...msgs: string[]) {\n        if (msgs.length > 1) {\n            debugger;\n            throw new Error(`no multi-arg log() calls`);\n        }\n        this.logger.logPrint(msgs[0]);\n        return this;\n    }\n    flush() {\n        this.logger.flush();\n        return this;\n    }\n    finish() {\n        this.logger.finish();\n        return this;\n    }\n\n    /**\n     * Submits the current transaction and any additional transactions in the context.\n     * @remarks\n     * To submit only the current transaction, use the `submit()` method.\n     *\n     * Uses the TxBatcher to create a new batch of transactions.  This new batch\n     * overlays a TxChainBuilder on the current network-client, using that facade\n     * to provide utxos for chained transactions in the batch.\n     *\n     * The signers array can be used to add additional signers to the transaction, and\n     * is passed through to the submit() for the current txn only; it is not used for\n     * any additional transactions.\n     *\n     * The beforeSubmit, onSubmitted callbacks are used for each additional transaction.\n     *\n     * beforeSubmit can be used to notify the user of the transaction about to be submitted,\n     * and can also be used to add additional signers to the transaction or otherwise modify\n     * it (by returning the modified transaction).\n     *\n     * onSubmitted can be used to notify the user that the transaction has been submitted,\n     * or for logging or any other post-submission processing.\n     */\n    async submitAll(this: StellarTxnContext<any>, options: SubmitOptions = {}) {\n        const currentBatch = this.currentBatch;\n        const hasOpenBatch = currentBatch?.isOpen;\n        // if (hasOpenBatch) {\n        //     console.warn(\n        //         `\u26A0\uFE0F  submitAll(): detected overlapping txn batches... \\n` +\n        //             `  ... that MIGHT be a developer error on our part.\\n` +\n        //             `  ... or, you might need to add your transaction to an existing batch \\n` +\n        //             `      (use otherTcx.includeAddlTxn(...))\\n` +\n        //             `  ... or, you might need to ensure you're waiting for an existing batch \\n` +\n        //             `      to finish (monitor setup.txBatcher.current for batch:confirmed)\\n` +\n        //             `\\nFinally, you might have an advanced use-case for building multiple \\n` +\n        //             `independent batches of transactions that don't need tx chaining between them. \\n\\n` +\n        //             `Please be welcome to log an issue with the project's support desk, \\n` +\n        //             `... and we'll see what we can do to help.`\n        //         );\n        //     throw new Error(`can't submitAll() with an existing open tx batch (wait for the existing batch to finish first`);\n        // }\n\n        //!!! remove because it's already done in the constructor?\n        // debugger\n        // if (!currentBatch || currentBatch.isConfirmationComplete) {\n        //     this.setup.txBatcher.rotate(this.setup.chainBuilder);\n        // }\n\n        // if (!this.setup.isTest && !this.setup.chainBuilder) {\n        //     if (currentBatch.chainBuilder) {\n        //         // backfills the chainbuilder from the one auto-populated\n        //         // during `get TxBatcher.current()`\n        //         this.setup.chainBuilder = currentBatch.chainBuilder;\n        //     } else {\n        //         this.setup.chainBuilder = makeTxChainBuilder(\n        //             this.setup.network\n        //         );\n        //     }\n        // }\n        //!!! ^^^ remove?\n\n        return this.buildAndQueueAll(options).then((batch) => {\n            return batch;\n            //            return currentBatch.$signAndSubmitAll().then(() => true);\n        });\n    }\n\n    /**\n     * augments a transaction context with a type indicator\n     * that it has additional transactions to be submitted.\n     * @public\n     * @remarks\n     * The optional argument can also be used to include additional\n     * transactions to be chained after the current transaction.\n     */\n    withAddlTxns<TCX extends StellarTxnContext<anyState>>(\n        this: TCX,\n        addlTxns: Record<string, TxDescription<any, \"buildLater!\">> = {}\n    ): hasAddlTxns<TCX> {\n        //@ts-expect-error\n        this.state.addlTxns = this.state.addlTxns || {};\n\n        for (const [name, txn] of Object.entries(addlTxns)) {\n            this.includeAddlTxn(name, txn);\n        }\n        return this as any;\n    }\n\n    async buildAndQueueAll(\n        this: StellarTxnContext<any>,\n        options: SubmitOptions = {}\n    ) {\n        const {\n            addlTxInfo = {\n                description: this.txnName\n                    ? this.txnName\n                    : \"\u2039unnamed tx\u203A\",\n                id: this.id,\n                tcx: this,\n            },\n            ...generalSubmitOptions\n        } = options;\n        if (options.paramsOverride) {\n            console.warn(\n                \"\u26A0\uFE0F  paramsOverride can be useful for extreme cases \\n\" +\n                    \"of troubleshooting tx execution by submitting an oversized tx \\n\" +\n                    \"with unoptimized contract scripts having diagnostic print/trace calls\\n\" +\n                    \"to a custom preprod node having overloaded network params, thus allowing \\n\" +\n                    \"such a transaction to be evaluated end-to-end by the Haskell evaluator using \\n\" +\n                    \"the cardano-node's script-budgeting mini-protocol.\\n\\n\" +\n                    \"This will cause problems for regular transactions (such as requiring very large collateral)\" +\n                    \"Be sure to remove any params override if you're not dealing with \\n\" +\n                    \"one of those very special situations. \\n\"\n            );\n            debugger;\n        }\n\n        if (this.isFacade == false) {\n            return this.buildAndQueue({\n                ...generalSubmitOptions,\n                addlTxInfo,\n            }).then(() => {\n                if (this.state.addlTxns) {\n                    // this gives early registration of nested txns from top-level txns\n                    console.log(\n                        `\uD83C\uDF84\u26C4\uD83C\uDF81 ${this.id}   -- B&QA - registering addl txns`\n                    );\n                    return this.queueAddlTxns(options).then(() => {\n                        return this.currentBatch;\n                    });\n\n                    // .then((x) => {\n                    //     return this.currentBatch.$signAndSubmitAll()\n                    //     // this.setup.chainBuilder = undefined;\n                    //     // return x;\n                    // });\n                }\n                return this.currentBatch\n            });\n        } else if (this.state.addlTxns) {\n            if (this.isFacade) {\n                this.currentBatch.$txInfo(this.id)?.transition(\"isFacade\");\n            }\n\n            // this gives early registration of nested txns from top-level txns\n            console.log(\n                `\uD83C\uDF84\u26C4\uD83C\uDF81 ${this.id}   -- B&QA - registering txns in facade`\n            );\n            return this.queueAddlTxns(generalSubmitOptions).then(() => {\n                return this.currentBatch;\n            });\n        }\n        console.warn(`\u26A0\uFE0F  submitAll(): no txns to queue/submit`, this);\n        throw new Error(\n            `unreachable? -- nothing to do for submitting this tcx`\n        );\n    }\n\n    get currentBatch() {\n        return this.setup.txBatcher.current;\n    }\n\n    /**\n     * Submits only the current transaction.\n     * @remarks\n     * To also submit additional transactions, use the `submitAll()` method.\n     */\n    async buildAndQueue(\n        this: StellarTxnContext<any>,\n        submitOptions: SubmitOptions = {}\n    ) {\n        let {\n            signers = [],\n            addlTxInfo,\n            paramsOverride,\n            expectError,\n            beforeError,\n            beforeValidate,\n            whenBuilt,\n            fixupBeforeSubmit,\n            onSubmitError,\n            onSubmitted,\n        } = submitOptions;\n\n        // console.log(\"buildAndQueue with setup\", this.setup);\n        this.noFacade(\"submit\");\n        if (!addlTxInfo) {\n            debugger;\n            throw new Error(`expecting addlTxInfo to be passed`);\n            addlTxInfo = {\n                description: this.txnName\n                    ? \": \" + this.txnName\n                    : \"\u2039unnamed tx\u203A\",\n                id: nanoid(5),\n                tcx: this,\n            };\n        }\n        const {\n            logger,\n            setup: { network },\n        } = this;\n        const {\n            tx,\n            willSign,\n            walletMustSign,\n            wallet,\n            wHelper,\n            costs = {\n                total: { cpu: 0n, mem: 0n },\n            },\n        } = await this.build({\n            signers,\n            paramsOverride,\n            addlTxInfo,\n            beforeValidate,\n            expectError,\n        });\n        let { description, id } = addlTxInfo;\n        if (!id) {\n            id = addlTxInfo.id = this.id;\n        }\n        const addlTxInfo2: TxDescription<any, \"buildLater!\"> = {\n            ...addlTxInfo,\n        } as any;\n\n        const txStats = {\n            costs: costs,\n            wallet: wallet,\n            walletMustSign,\n            wHelper,\n            willSign,\n        };\n        const errMsg =\n            tx.hasValidationError && tx.hasValidationError.toString();\n        if (errMsg) {\n            // console.log(`submit(): FAILED tx.validate(): ${errMsg}`);\n            // console.profileEnd?.(\"tx.validate()\");\n            // @ts-ignore\n            // if (console.profileEnd) {\n            //     debugger;\n            // }\n\n            logger.logPrint(`\u26A0\uFE0F  txn validation failed: ${description}\\n${errMsg}\\n`);\n            logger.logPrint(this.dump(tx));\n            this.emitCostDetails(tx, costs);\n            logger.flush();\n            logger.logError(`FAILED submitting tx: ${description}`);\n            logger.logPrint(errMsg);\n            if (expectError) {\n                logger.logPrint(\n                    `\\n\\n\uD83D\uDCA3\uD83C\uDF89 \uD83D\uDCA3\uD83C\uDF89 \uD83C\uDF89 \uD83C\uDF89 transaction failed (as expected)`\n                );\n            }\n\n            const txErrorDescription: TxDescriptionWithError = {\n                ...addlTxInfo2,\n                tcx: this,\n                error: errMsg,\n                tx,\n                stats: txStats,\n                options: submitOptions,\n                txCborHex: bytesToHex(tx.toCbor()),\n            };\n            this.currentBatch.txError(txErrorDescription);\n\n            let errorHandled;\n            if (beforeError) {\n                errorHandled = await beforeError(txErrorDescription);\n            }\n            logger.flushError();\n            if (\n                errMsg.match(\n                    /multi:Minting: only dgData activities ok in mintDgt/\n                )\n            ) {\n                console.log(\n                    `\u26A0\uFE0F  mint delegate for multiple activities should be given delegated-data activities, not the activities of the delegate`\n                );\n            }\n            if (!errorHandled) {\n                debugger;\n                throw new Error(errMsg);\n            }\n        }\n        // const elapsed = t2 - t1;\n        // console.log(\n        //     // stopwatch emoji: \u23F1\n        //     `          :::::::::: \u23F1 tx validation time: ${elapsed}ms \u23F1`\n        // );\n        // result: validations for non-trivial txns can take ~800+ ms\n        //  - validations with simplify:true, ~250ms - but ...`\n        //    ... with elided error messages that don't support negative-testing very well\n        for (const pkh of willSign) {\n            if (!pkh) continue;\n            if (tx.body.signers.find((s) => pkh.isEqual(s))) continue;\n            throw new Error(\n                `incontheeivable! all signers should have been added to the builder above`\n            );\n        }\n\n        const txDescr: TxDescription<any, \"built\"> = {\n            ...addlTxInfo2,\n            tcx: this,\n            tx,\n            txId: tx.id(),\n            options: submitOptions,\n            stats: txStats,\n            txCborHex: bytesToHex(tx.toCbor()),\n        };\n        const { currentBatch } = this;\n        const txState = currentBatch.$txStates[id];\n\n        logger.logPrint(`tx transcript: ${description}\\n`);\n        logger.logPrint(this.dump(tx));\n        this.emitCostDetails(tx, costs);\n        logger.logPrint(`end: ${description}`);\n        logger.flush();\n\n        // hands off wallet signing & tx-completion to the batcher.\n        console.timeStamp?.(`tx: add to current-tx-batch`);\n        currentBatch.$addTxns(txDescr);\n        this.setup.chainBuilder?.with(txDescr.tx);\n        await whenBuilt?.(txDescr);\n    }\n    emitCostDetails(tx: Tx, costs: { total: Cost; [key: string]: Cost }) {\n        const { logger } = this;\n        const {\n            maxTxExCpu,\n            maxTxExMem,\n            maxTxSize,\n            //@ts-expect-error on our synthetic attributes\n            origMaxTxSize = maxTxSize,\n            //@ts-expect-error on our synthetic attributes\n            origMaxTxExMem = maxTxExMem,\n            //@ts-expect-error on our synthetic attributes\n            origMaxTxExCpu = maxTxExCpu,\n            exCpuFeePerUnit,\n            exMemFeePerUnit,\n            txFeePerByte,\n            txFeeFixed,\n        } = this.networkParams;\n        const oMaxSize: number = origMaxTxSize;\n        const oMaxMem: number = origMaxTxExMem;\n        const oMaxCpu: number = origMaxTxExCpu;\n\n        const { total, ...otherCosts } = costs;\n        const txSize = tx.calcSize();\n        const txFeeCalc = Number(tx.calcMinFee(this.networkParams));\n        const txFee = tx.body.fee;\n\n        const cpuFee = BigInt((Number(total.cpu) * exCpuFeePerUnit).toFixed(0));\n        const memFee = BigInt((Number(total.mem) * exMemFeePerUnit).toFixed(0));\n        const sizeFee = BigInt(txSize * txFeePerByte);\n        const nCpu = Number(total.cpu);\n        const nMem = Number(total.mem);\n        let refScriptSize = 0;\n        for (const anyInput of [...tx.body.inputs, ...tx.body.refInputs]) {\n            const refScript = anyInput.output.refScript;\n            if (refScript) {\n                const scriptSize = refScript.toCbor().length;\n                refScriptSize += scriptSize;\n            }\n        }\n        let multiplier = 1.0;\n        let refScriptsFee = 0n;\n        let refScriptsFeePerByte = this.networkParams.refScriptsFeePerByte;\n        let refScriptCostDetails: string[] = [];\n        const tierSize = 25600;\n        let alreadyConsumed = 0;\n        for (\n            let tier = 0;\n            tier * tierSize < refScriptSize;\n            tier += 1, multiplier *= 1.2\n        ) {\n            const topOfThisTier = (1 + tier) * tierSize;\n            const consumedThisTier = Math.min(\n                tierSize,\n                refScriptSize - alreadyConsumed\n            );\n            alreadyConsumed += consumedThisTier;\n            const feeThisTier = Math.round(\n                consumedThisTier * multiplier * refScriptsFeePerByte\n            );\n            refScriptsFee += BigInt(feeThisTier);\n            refScriptCostDetails.push(\n                `\\n      -- refScript tier${\n                    1 + tier\n                } (${consumedThisTier} \u00D7 ${multiplier}) \u00D7${refScriptsFeePerByte} = ${lovelaceToAda(\n                    feeThisTier\n                )}`\n            );\n        }\n\n        // for (let i = 0; i < refScriptSize; i += 25600, multiplier *= 1.2) {\n        //     const chunkSize = Math.min(25600, refScriptSize - i)\n        //     const feeThisChunk = chunkSize * multiplier * refScriptsFeePerByte\n        //     refScriptsFee += BigInt(feeThisChunk)\n        //     refScriptCostDetails.push(\n        //         `\\n      -- refScript tier${i} (${chunkSize} bytes) \u00D7 ${multiplier} = ${lovelaceToAda(feeThisChunk)}`\n        //     )\n        // }\n        const fixedTxFeeBigInt = BigInt(txFeeFixed);\n\n        const remainderUnaccounted =\n            txFee -\n            cpuFee -\n            memFee -\n            sizeFee -\n            fixedTxFeeBigInt -\n            refScriptsFee;\n\n        if (nCpu > oMaxCpu || nMem > oMaxMem || txSize > oMaxSize) {\n            logger.logPrint(\n                \"\uD83D\uDD25\uD83D\uDD25\uD83D\uDD25\uD83D\uDD25  THIS TX EXCEEDS default (overridden in test env) limits on network params  \uD83D\uDD25\uD83D\uDD25\uD83D\uDD25\uD83D\uDD25\\n\" +\n                    `  -- cpu ${intWithGrouping(nCpu)} = ${(\n                        (100 * nCpu) /\n                        oMaxCpu\n                    ).toFixed(1)}% of ${intWithGrouping(\n                        oMaxCpu\n                    )} (patched to ${intWithGrouping(maxTxExCpu)})\\n` +\n                    `  -- mem ${nMem} = ${((100 * nMem) / oMaxMem).toFixed(\n                        1\n                    )}% of ${intWithGrouping(\n                        oMaxMem\n                    )} (patched to ${intWithGrouping(maxTxExMem)})\\n` +\n                    `  -- tx size ${intWithGrouping(txSize)} = ${(\n                        (100 * txSize) /\n                        oMaxSize\n                    ).toFixed(1)}% of ${intWithGrouping(\n                        oMaxSize\n                    )} (patched to ${intWithGrouping(maxTxSize)})\\n`\n            );\n        }\n        const scriptBreakdown =\n            Object.keys(otherCosts).length > 0\n                ? `\\n    -- per script (with % blame for actual costs):` +\n                  Object.entries(otherCosts)\n                      .map(\n                          ([key, { cpu, mem }]) =>\n                              `\\n      -- ${key}: cpu ${lovelaceToAda(\n                                  Number(cpu) * exCpuFeePerUnit\n                              )} = ${(\n                                  (Number(cpu) / Number(total.cpu)) *\n                                  100\n                              ).toFixed(1)}%, mem ${lovelaceToAda(\n                                  Number(mem) * exMemFeePerUnit\n                              )} = ${(\n                                  (Number(mem) / Number(total.mem)) *\n                                  100\n                              ).toFixed(1)}%`\n                      )\n                      .join(\"\")\n                : \"\";\n\n        logger.logPrint(\n            `costs: ${lovelaceToAda(txFee)}` +\n                `\\n  -- fixed fee = ${lovelaceToAda(txFeeFixed)}` +\n                `\\n  -- tx size fee = ${lovelaceToAda(sizeFee)}` +\n                ` (${intWithGrouping(txSize)} bytes = ${(\n                    Number((1000 * txSize) / oMaxSize) / 10\n                ).toFixed(1)}% of tx size limit)` +\n                `\\n  -- refScripts fee = ${lovelaceToAda(refScriptsFee)}` +\n                refScriptCostDetails.join(\"\") +\n                `\\n  -- scripting costs` +\n                `\\n    -- cpu units ${intWithGrouping(total.cpu)}` +\n                ` = ${lovelaceToAda(cpuFee)}` +\n                ` (${(\n                    Number((1000n * total.cpu) / BigInt(oMaxCpu)) / 10\n                ).toFixed(1)}% of cpu limit/tx)` +\n                `\\n    -- memory units ${intWithGrouping(total.mem)}` +\n                ` = ${lovelaceToAda(memFee)}` +\n                ` (${(\n                    Number((1000n * total.mem) / BigInt(oMaxMem)) / 10\n                ).toFixed(1)}% of mem limit/tx)` +\n                scriptBreakdown +\n                `\\n  -- remainder ${lovelaceToAda(\n                    remainderUnaccounted\n                )} unaccounted-for`\n        );\n    }\n\n    /**\n     * Executes additional transactions indicated by an existing transaction\n     * @remarks\n     *\n     * During the off-chain txn-creation process, additional transactions may be\n     * queued for execution.  This method is used to register those transactions,\n     * along with any chained transactions THEY may trigger.\n     *\n     * The TxBatcher and batch-controller classes handle wallet-signing\n     * and submission of the transactions for execution.\n     * @public\n     **/\n    async queueAddlTxns(\n        this: hasAddlTxns<any>,\n        pipelineOptions?: TxPipelineOptions\n    ) {\n        const { addlTxns } = this.state;\n        if (!addlTxns) return;\n\n        // return this.submitTxns(Object.values(addlTxns), callback);\n        return this.submitTxnChain({\n            ...pipelineOptions,\n            txns: Object.values(addlTxns),\n        });\n    }\n\n    /**\n     * Resolves a list of tx descriptions to full tcx's, without handing any of their\n     * any chained/nested txns.\n     * @remarks\n     * if submitEach is provided, each txn will be submitted as it is resolved.\n     * If submitEach is not provided, then the network must be capable of tx-chaining\n     * use submitTxnChain() to submit a list of txns with chaining\n     */\n    async resolveMultipleTxns(\n        txns: TxDescription<any, \"buildLater!\">[],\n        pipelineOptions?: TxPipelineOptions\n    ) {\n        //         as [\n        //         string,\n        //         TxDescription<any, \"buildLater!\">\n        //     ][]\n\n        for (const [txName, addlTxInfo] of Object.entries(txns)) {\n            const { id } = addlTxInfo;\n            let txTracker = this.currentBatch.$txInfo(id);\n            if (!txTracker) {\n                this.currentBatch.$addTxns(addlTxInfo);\n                txTracker = this.currentBatch.$txInfo(id);\n            }\n        }\n        /* yield to allow rendering */\n        await new Promise((res) => setTimeout(res, 5));\n\n        for (const [txName, addlTxInfo] of Object.entries(txns)) {\n            const { id, depth, parentId } = addlTxInfo;\n            let txTracker = this.currentBatch.$txInfo(id);\n\n            txTracker.$transition(\"building\");\n            /* yield to allow rendering */\n            await new Promise((res) => setTimeout(res, 5));\n\n            // IS resolving.  WILL BE resolved\n            const txInfoResolved: TxDescription<any, \"resolved\"> =\n                addlTxInfo as any;\n            const { txName, description } = txInfoResolved;\n            let alreadyPresent: TxNotNeededError | undefined = undefined;\n            console.log(\"  -- before: \" + description);\n            const tcx = (\n                \"function\" == typeof addlTxInfo.mkTcx\n                    ? await (async () => {\n                          console.log(\n                              \"  creating TCX just in time for: \" + description\n                          );\n\n                          const tcx = await addlTxInfo.mkTcx();\n                          tcx.parentId = parentId || \"\";\n                          tcx.depth = depth;\n                          if (id) {\n                              this.currentBatch.changeTxId(id, tcx.id);\n                              txInfoResolved.id = tcx.id;\n                          } else {\n                              addlTxInfo.id = tcx.id;\n                              console.warn(\n                                  `expected id to be set on addlTxInfo; falling back to JIT-generated id in new tcx`\n                              );\n                          }\n                          return tcx;\n                      })().catch((e) => {\n                          if (e instanceof TxNotNeededError) {\n                              alreadyPresent = e;\n                              const tcx = new StellarTxnContext(\n                                  this.setup\n                              ).withName(\n                                  `addlTxInfo already present: ${description}`\n                              );\n                              tcx.alreadyPresent = alreadyPresent;\n                              return tcx;\n                          }\n                          throw e;\n                      })\n                    : (() => {\n                          console.log(\n                              \"  ---------------- warning!!!! addlTxInfo is already built!\"\n                          );\n                          debugger;\n                          throw new Error(\" unreachable - right?\");\n                          return addlTxInfo.tcx;\n                      })()\n            ) as StellarTxnContext;\n            if (\"undefined\" == typeof tcx) {\n                throw new Error(\n                    `no txn provided for addlTx ${txName || description}`\n                );\n            }\n            txInfoResolved.tcx = tcx;\n            if (tcx.alreadyPresent) {\n                console.log(\n                    \"  -- tx effects are already present; skipping: \" +\n                        txName || description\n                );\n                this.currentBatch.$addTxns(txInfoResolved);\n                continue;\n            }\n\n            const replacementTcx =\n                (pipelineOptions?.fixupBeforeSubmit &&\n                    ((await pipelineOptions.fixupBeforeSubmit(\n                        txInfoResolved\n                    )) as typeof replacementTcx | boolean)) ||\n                tcx;\n            if (false === replacementTcx) {\n                console.log(\"callback cancelled txn: \", txName);\n                continue;\n            }\n            if (replacementTcx !== true && replacementTcx !== tcx) {\n                console.log(\n                    `callback replaced txn ${txName} with a different txn: `,\n                    dumpAny(replacementTcx)\n                );\n            }\n\n            // if the callback returns true or void, we execute the txn as already resolved.\n            // if it returns an alternative txn, we use that instead.\n            const effectiveTcx: StellarTxnContext =\n                true === replacementTcx ? tcx : replacementTcx || tcx;\n            // console.log(\"   -- submitTxns: -> txn: \", txName, description);\n            // console.log(\"   ----> effective tx\", effectiveTcx);\n\n            txInfoResolved.tcx = effectiveTcx;\n\n            //!!! was just buildAndQueue, but that was executing\n            // in \"breadth-first\" order (good for registration)\n            //    (i.e. in consecutive layers of discovered txns)\n            // ... instead of executing depth-first (good for tx-chaining).\n            // We want all txns to be registered as soon as they're\n            //   known to be a tx to be made.  But for each such tx,\n            //   we want its chained txns to be executed BEFORE moving on\n            //   to build any of those other registered txns.\n\n            // //@ts-expect-error\n            // if (this.setup.stopped) return;\n            // if (description == \"+ on-chain refScript: minter\") {\n            //     //@ts-expect-error\n            //     this.setup.stopped = true\n            //     break\n            // }\n            await effectiveTcx.buildAndQueueAll({\n                ...pipelineOptions,\n                addlTxInfo: txInfoResolved,\n            });\n            // console.log(\"   -- submitTxns: <- txn: \", txName, description);\n            // m oved into submit()\n            // if (callbacks?.onSubmitted) {\n            // console.log(\"   -- submitTxns: triggering onSubmit callback\");\n            // await callbacks.onSubmitted(txInfoResolved);\n            // console.log(\"   -- submitTxns: onSubmitted callback completed\");\n            // }\n        }\n    }\n\n    /**\n     * To add a script to the transaction context, use `attachScript`\n     *\n     * @deprecated - invalid method name; use `addScriptProgram()` or capo's `txnAttachScriptOrRefScript()` method\n     **/\n    addScript() {}\n\n    async submitTxnChain(\n        options: {\n            txns?: TxDescription<any, \"buildLater!\">[];\n        } & TxPipelineOptions = {\n            //@ts-expect-error because the type of this context doesn't\n            //   guarantee the presence of addlTxns.  But it might be there!\n            txns: this.state.addlTxns || [],\n        }\n    ) {\n        //@ts-expect-error on probing for a maybe-undefined entry:\n        const addlTxns = this.state.addlTxns;\n\n        const { txns, onSubmitError } = options;\n        const newTxns: TxDescription<any, \"buildLater!\">[] =\n            txns || addlTxns || [];\n        let chainedTxns: TxDescription<any, \"buildLater!\">[] = [];\n\n        const txChainSubmitOptions: TxPipelineOptions = {\n            onSubmitError,\n            // txns,  // see newTxns\n            fixupBeforeSubmit: (txinfo) => {\n                //   ... in regular execution environment, this is a no-op by default\n                options.fixupBeforeSubmit?.(txinfo);\n            },\n            whenBuilt: async (txinfo) => {\n                const { id: parentId, tx } = txinfo;\n                const stackedPromise = options.whenBuilt?.(txinfo);\n                const more: Record<string, TxDescription<any, \"buildLater!\">> =\n                    //@ts-expect-error on optional prop\n                    txinfo.tcx.state.addlTxns || {};\n                console.log(\"  \u2705 \" + txinfo.description);\n                const moreTxns = Object.values(more);\n\n                for (const nested of moreTxns) {\n                    nested.parentId = parentId;\n                }\n                console.log(\n                    `\uD83C\uDF84\u26C4\uD83C\uDF81 ${parentId}   -- registering nested txns ASAP`\n                );\n                this.currentBatch.$addTxns(moreTxns);\n\n                /* yield to allow rendering */\n                await new Promise((res) => setTimeout(res, 5));\n\n                // if (moreTxns.length) {\n                //     // gathers the next layer of txns to be resolved & built\n                //     chainedTxns.push(...moreTxns);\n                //     console.log(\n                //         \" + chained txns: \\n\" +\n                //             moreTxns\n                //                 .map((t) => `   \uD83D\uDFE9 ${t.description}\\n`)\n                //                 .join(\"\")\n                //     );\n                // }\n                return stackedPromise;\n            },\n            onSubmitted: (txinfo) => {\n                //@ts-expect-error triggering the test-network-emulator's tick\n                //   ... in regular execution environment, this is a no-op by default\n                this.setup.network.tick?.(1);\n            },\n        };\n        let chainDepth = 0;\n        const isolatedTcx = new StellarTxnContext(this.setup);\n        console.log(\"\uD83D\uDC1D\uD83D\uDE3E\uD83D\uDC3B\uD83E\uDD80\");\n        isolatedTcx.id = this.id;\n        console.log(\n            \"at d=0: submitting addl txns: \\n\" +\n                newTxns.map((t) => `  \uD83D\uDFE9 ${t.description}\\n`).join(\"\")\n        );\n\n        const t = isolatedTcx.resolveMultipleTxns(\n            newTxns,\n            txChainSubmitOptions\n        );\n\n        const allPromises = [] as Promise<any>[];\n        chainDepth = 0;\n        allPromises.push(t);\n\n        await t;\n        return;\n        while (chainedTxns.length) {\n            const nextChain: typeof chainedTxns = [];\n            chainDepth++;\n\n            for (const { tcx } of chainedTxns) {\n                // if (tcx.state) {\n                //     debugger\n                // } else {\n                //     const { addlTxns: nestedAddlTxns } = (tcx.state || {}) as {\n                //         addlTxns?: Record<\n                //             string,\n                //             TxDescription<any, \"buildLater!\">\n                //         >;\n                //     };\n                //     if (!nestedAddlTxns) continue;\n                //     nextChain.push(...Object.values(nestedAddlTxns));\n                // }\n            }\n            console.log(\n                ` \uD83D\uDC1E\uD83D\uDC1E\uD83D\uDC1E\uD83D\uDC1E submitting ${chainedTxns.length} transactions at depth ${chainDepth}`\n            );\n            console.log(\n                chainedTxns.map((t) => `  \uD83D\uDFE9 ${t.description}\\n`).join(\"\")\n            );\n            const thisBatch = chainedTxns;\n            chainedTxns = [];\n\n            const isolatedTcx = new StellarTxnContext(this.setup);\n            isolatedTcx.id = this.id;\n\n            const t = isolatedTcx.resolveMultipleTxns(\n                thisBatch,\n                txChainSubmitOptions\n            );\n            allPromises.push(t);\n            await t;\n            console.log(\n                \"\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nSubmitted transactions at depth \" +\n                    chainDepth\n            );\n            chainedTxns = nextChain;\n        }\n        return Promise.all(allPromises);\n    }\n}\n\n// /**\n//  * Given a fully built transaction, returns a new transaction with the fees removed\n//  * @remarks\n//  * The result is suitable for submission to Ogmios' tx-evaluation endpoint\n//  * that uses Haskell's CEK interpreter to give us the costs for the transaction.\n//  *\n//  * TODO: use this to cross-check Helios' CEK budgeting and ensure we\n//  * make a txn that will be accepted by the network\n//  */\n// export function undoFeesFrom(\n//     t: Tx,\n//     { isValid: validity = true }: { isValid?: boolean } = {}\n// ): Tx {\n//     const tb = t.body;\n//     const pTxB = makeTxBody({\n//         dcerts: tb.dcerts,\n//         fee: BigInt(0),\n//         minted: tb.minted,\n//         refInputs: tb.refInputs,\n//         inputs: tb.inputs,\n//         outputs: tb.outputs,\n//         signers: tb.signers,\n//         withdrawals: tb.withdrawals,\n//         collateral: tb.collateral,\n//         collateralReturn: tb.collateralReturn,\n//         firstValidSlot: tb.firstValidSlot,\n//         lastValidSlot: tb.lastValidSlot,\n//         metadataHash: tb.metadataHash,\n//         scriptDataHash: tb.scriptDataHash,\n//         totalCollateral: tb.totalCollateral,\n//     });\n\n//     const txW = makeTxWitnesses({\n//         ...t.witnesses,\n//         redeemers: t.witnesses.redeemers.map((r) => {\n//             switch (r.kind) {\n//                 case \"TxCertifyingRedeemer\":\n//                     return makeTxCertifyingRedeemer(r.dcertIndex, r.data);\n//                 case \"TxMintingRedeemer\":\n//                     return makeTxMintingRedeemer(r.policyIndex, r.data);\n//                 case \"TxSpendingRedeemer\":\n//                     return makeTxSpendingRedeemer(r.inputIndex, r.data);\n//                 case \"TxRewardingRedeemer\":\n//                     return makeTxRewardingRedeemer(r.withdrawalIndex, r.data);\n//             }\n//         }),\n//     });\n//     return makeTx(pTxB, txW, validity, t.metadata);\n// }\n", "import type { ErrorMap } from \"./delegation/RolesAndDelegates.js\";\nimport { StellarTxnContext } from \"./StellarTxnContext.js\";\nimport {\n    makeByteArrayData,\n    type ByteArrayData,\n    type UplcProgramV2,\n} from \"@helios-lang/uplc\";\nimport {\n    uplcDataSerializer,\n    abbreviatedDetail,\n    abbreviatedDetailBytes,\n} from \"./delegation/jsonSerializers.js\";\nimport {\n    type Value,\n    type Address,\n    type Tx,\n    type TxId,\n    type TxInput,\n    type TxOutput,\n    type TxOutputId,\n    type NetworkParams,\n    type Assets,\n    type MintingPolicyHash,\n    type TxRedeemer,\n    type TxOutputDatum,\n    makeAddress,\n    makeNetworkParamsHelper,\n} from \"@helios-lang/ledger\";\nimport { bytesToHex } from \"@helios-lang/codec-utils\";\nimport {\n    bytesToText,\n    textToBytes,\n    type InlineDatum,\n} from \"./HeliosPromotedTypes.js\";\nimport type { UtxoDisplayCache } from \"./StellarContract.js\";\n\n/**\n * converts a hex string to a printable alternative, with no assumptions about the underlying data\n * @remarks\n *\n * Unlike Helios' bytesToText, hexToPrintable() simply changes printable characters to characters,\n * and represents non-printable characters in '\u2039XX\u203A' format.\n * @param hexStr - hex input\n * @public\n **/\nexport function hexToPrintableString(hexStr: string) {\n    let result = \"\";\n    for (let i = 0; i < hexStr.length; i += 2) {\n        let hexChar = hexStr.substring(i, i + 2);\n        let charCode = parseInt(hexChar, 16);\n\n        // ASCII printable characters are in the range 32 (space) to 126 (~)\n        if (charCode >= 32 && charCode <= 126) {\n            result += String.fromCharCode(charCode);\n        } else {\n            result += `\u2039${hexChar}\u203A`;\n        }\n\n        // todo decode utf8 parts using bytesToText(...substring...)\n        // int         required_len;\n        // if (key[0] >> 7 == 0)\n        //     required_len = 1;\n        // else if (key[0] >> 5 == 0x6)\n        //     required_len = 2;\n        // else if (key[0] >> 4 == 0xE)\n        //     required_len = 3;\n        // else if (key[0] >> 5 == 0x1E)\n        //     required_len = 4;\n        // else\n        //     return (0);\n        // return (strlen(key) == required_len && chars_are_folow_uni(key + 1));\n    }\n    return result;\n}\n\n/**\n * Displays a token name in a human-readable form\n * @remarks\n * Recognizes CIP-68 token names and displays them in a special format.\n * @param nameBytesOrString - the token name, as a string or byte array\n * @public\n */\nexport function displayTokenName(nameBytesOrString: string | number[]) {\n    // check if it is a cip-68 token name by inspecting the first 4 bytes.  If they don't match the cip-68 pattern, display using stringToPrintableString.\n    // if it has a cip-68 tag in the first 4 bytes, show the cip-68 tag as `\u2039cip68/{tag}\u203A` and append the rest of the token name as a string.\n    // inspect the first 4 bytes by:\n    //  - converting them to hex\n    //  - checking if the first and last nibbles are 0's (if not, then it is not a cip-68 token name)\n    //  - removing the first and last nibbles, shifting the hex string to the left by 1 nibble to get a 2-byte tag and 1 byte of checksum\n    //  - separating the cip-68 tag from the checksum\n    //  - parsing the cip-68 tag as a number (parseInt(numHex, 16))\n\n    let nameString = \"\";\n    let cip68Tag = \"\";\n    let cip68TagHex = \"\";\n    let checksum = \"\";\n    let tagBytes = \"\";\n    let nameBytesHex = \"\";\n    let nameBytesString = \"\";\n    let isCip68 = false;\n    if (typeof nameBytesOrString === \"string\") {\n        // convert the bytes of the string to hex\n        nameBytesHex = Buffer.from(textToBytes(nameBytesOrString)).toString(\n            \"hex\"\n        );\n        nameString = nameBytesOrString;\n    } else {\n        nameBytesHex = Buffer.from(nameBytesOrString).toString(\"hex\");\n        nameString = stringToPrintableString(nameBytesOrString);\n    }\n    // check if the first 4 bytes are a cip-68 token name\n    if (nameBytesHex.length >= 8) {\n        // check if the first and last nibbles are 0's\n        if (\n            nameBytesHex.substring(0, 1) === \"0\" &&\n            nameBytesHex.substring(7, 8) === \"0\"\n        ) {\n            // remove the first and last nibbles\n            cip68TagHex = nameBytesHex.substring(1, 5);\n            checksum = nameBytesHex.substring(5, 7);\n\n            // separate the cip-68 tag from the checksum\n            cip68Tag = parseInt(cip68TagHex, 16).toString();\n            nameString = stringToPrintableString(nameBytesOrString.slice(4));\n\n            // TODO: check the crc-8 checksum of the tag\n            isCip68 = true;\n        }\n    }\n    if (isCip68) {\n        nameString = `\u2039cip68/${cip68Tag}\u203A${nameString}`;\n    } else {\n        nameString = stringToPrintableString(nameBytesOrString);\n    }\n    return nameString;\n}\n\n/**\n * Presents a string in printable form, even if it contains non-printable characters\n *\n * @remarks\n * Non-printable characters are shown in '\u2039XX\u203A' format.\n * @public\n */\nexport function stringToPrintableString(str: string | number[]) {\n    if (\"string\" != typeof str) {\n        // use a TextEncoder to identify if it is a utf8 string\n        try {\n            return new TextDecoder(\"utf-8\", { fatal: true }).decode(\n                new Uint8Array(str as number[])\n            );\n        } catch (e) {\n            // if it is not a utf8 string, fall back to printing what's printable and showing hex for other bytes\n            str = Buffer.from(str as number[]).toString(\"hex\");\n        }\n    }\n    let result = \"\";\n    for (let i = 0; i < str.length; i++) {\n        let charCode = str.charCodeAt(i);\n\n        // ASCII printable characters are in the range 32 (space) to 126 (~)\n        if (charCode >= 32 && charCode <= 126) {\n            result += str[i];\n        } else {\n            result += `\u2039${charCode.toString(16)}\u203A`;\n        }\n    }\n    return result;\n}\n\n/**\n * Converts an array of [ policyId, \u2039tokens\u203A ] tuples for on-screen presentation\n * @remarks\n *\n * Presents policy-ids with shortened identifiers, and shows a readable & printable\n * representation of token names even if they're not UTF-8 encoded.\n * @public\n **/\nexport function assetsAsString(\n    a: Assets,\n    joiner = \"\\n    \",\n    showNegativeAsBurn?: \"withBURN\",\n    mintRedeemers?: Record<number, string>\n) {\n    const assets = a.assets;\n    return (\n        assets?.map(([policyId, tokenEntries], index) => {\n            let redeemerInfo = mintRedeemers?.[index] || \"\";\n            if (redeemerInfo) {\n                redeemerInfo = `\\n        r = ${redeemerInfo} `;\n            }\n            const tokenString = tokenEntries\n                .map(([nameBytes, count]: [number[], bigint]) => {\n                    // const nameString =  hexToPrintableString(nameBytes.hex);\n                    const nameString = displayTokenName(nameBytes);\n\n                    const negWarning =\n                        count < 1n\n                            ? showNegativeAsBurn\n                                ? \"\uD83D\uDD25 \"\n                                : \" \u26A0\uFE0F NEGATIVE\u26A0\uFE0F\"\n                            : \"\";\n                    const burned =\n                        count < 1\n                            ? showNegativeAsBurn\n                                ? \"- BURN \uD83D\uDD25 \"\n                                : \"\"\n                            : \"\";\n                    return `${negWarning} ${count}\u00D7\uD83D\uDCB4 ${nameString} ${burned}`;\n                })\n                .join(\"+\");\n            return `\u2991${policyIdAsString(\n                policyId\n            )} ${tokenString} ${redeemerInfo}\u2992`;\n        }) || []\n    ).join(joiner);\n}\n\n/**\n * Converts a MintingPolicyHash to a printable form\n * @public\n **/\nexport function policyIdAsString(p: MintingPolicyHash) {\n    const pIdHex = p.toHex();\n    const abbrev = abbreviatedDetail(pIdHex);\n    return `\uD83C\uDFE6 ${abbrev}`;\n}\n\n/**\n * Converts lovelace to approximate ADA, in consumable 3-decimal form\n * @public\n **/\nexport function lovelaceToAdaOld(l: bigint | number) {\n    const asNum = parseInt(l.toString());\n    const ada =\n        (asNum && `${(Math.round(asNum / 1000) / 1000).toFixed(3)} ADA`) || \"\";\n    return ada;\n}\n\n/**\n * Converts lovelace to approximate ADA, in consumable 3-decimal form\n * @public\n */\nexport function lovelaceToAda(lovelace: bigint | number): string {\n    const asNum = parseInt(lovelace.toString());\n    // input: 6004000 should output 6_004.000\n    // input: 700396001000 should output 700_396.001\n    // input: 400202 should output 0.400_202\n    const whole = Math.floor(asNum / 1_000_000).toFixed(0);\n    let fraction = (asNum % 1_000_000).toFixed(0); // \"\"\n    fraction = fraction.padStart(6, \"0\");\n    const wholeWithSeparators = whole.replace(/\\B(?=(\\d{3})+(?!\\d))/g, \"_\");\n    let fractionWithSeparators = fraction\n        .replace(/(\\d{3})(?=\\d)/g, \"$1_\")\n        .replace(/^-/, \"\"); // remove leading - if any\n    return `${wholeWithSeparators}.${fractionWithSeparators} ADA`;\n}\n\n/**\n * Converts a bigint or number to a string with commas as thousands separators\n * @public\n */\nexport function intWithGrouping(i : bigint | number) {\n    const whole = Math.floor(Number(i)).toFixed(0);\n    const fraction = Math.abs(Number(i) - Math.floor(Number(i))).toFixed(0);\n    const wholeWithSeparators = whole.replace(/\\B(?=(\\d{3})+(?!\\d))/g, \"_\");\n    const fractionWithSeparators = fraction\n        .replace(/(\\d{3})(?=\\d)/g, \"$1_\")\n    return `${wholeWithSeparators}.${fractionWithSeparators}`;\n}\n/**\n * Converts a Value to printable form\n * @public\n **/\nexport function valueAsString(v: Value) {\n    const ada = lovelaceToAda(v.lovelace);\n    const assets = assetsAsString(v.assets);\n    return [ada, assets].filter((x) => !!x).join(\" + \");\n}\n\n/**\n * Converts a Tx to printable form\n * @public\n **/\nexport function txAsString(tx: Tx, networkParams?: NetworkParams): string {\n    const outputOrder = [\n        [\"body\", \"inputs\"],\n        [\"body\", \"minted\"],\n        [\"body\", \"outputs\"],\n        [\"body\", \"refInputs\"],\n        [\"witnesses\", \"redeemers\"],\n        [\"body\", \"signers\"],\n        [\"witnesses\", \"v2refScripts\"],\n        [\"witnesses\", \"v2scripts\"],\n        [\"witnesses\", \"nativeScripts\"],\n        [\"body\", \"collateral\"],\n        [\"body\", \"collateralReturn\"],\n        [\"body\", \"scriptDataHash\"],\n        [\"body\", \"metadataHash\"],\n        [\"witnesses\", \"signatures\"],\n        [\"witnesses\", \"datums\"],\n        [\"body\", \"lastValidSlot\"],\n        [\"body\", \"firstValidSlot\"],\n        [\"body\", \"fee\"],\n    ];\n\n    let details = \"\";\n    if (!networkParams) {\n        console.warn(\n            new Error(`dumpAny: no networkParams; can't show txn size info!?!`)\n        );\n    }\n\n    const networkParamsHelper = networkParams\n        ? makeNetworkParamsHelper(networkParams)\n        : undefined;\n\n    // const d = tx.dump();\n    const seenRedeemers = new Set();\n\n    const allRedeemers = tx.witnesses.redeemers as any;\n    let hasIndeterminate = false;\n    const inputRedeemers: Record<\n        string | number,\n        { r?: TxRedeemer; display: string }\n    > = Object.fromEntries(\n        allRedeemers\n            .map((x: TxRedeemer, index: number) => {\n                // debugger;\n                if (x.kind != \"TxSpendingRedeemer\") return undefined;\n                // if (!(\"inputIndex\" in x)) return undefined;\n                const { inputIndex } = x;\n                const isIndeterminate = inputIndex == -1;\n                if (isIndeterminate) hasIndeterminate = true;\n                const inpIndex = isIndeterminate ? `\u2039unk${index}\u203A` : inputIndex;\n                if (!x.data) debugger;\n                const showData = x.data.rawData\n                    ? uplcDataSerializer(\"\", x.data.rawData)\n                    : x.data?.toString() || \"\u2039no data\u203A\";\n                return [inpIndex, { r: x, display: showData }];\n            })\n            .filter((x) => !!x)\n    );\n    if (hasIndeterminate)\n        inputRedeemers[\"hasIndeterminate\"] = {\n            r: undefined,\n            display: \"\u2039unk\u203A\",\n        };\n\n    const mintRedeemers = Object.fromEntries(\n        allRedeemers\n            .map((x) => {\n                if (\"TxMintingRedeemer\" != x.kind) return undefined;\n                if (\"number\" != typeof x.policyIndex) {\n                    debugger;\n                    throw new Error(`non-mint redeemer here not yet supported`);\n                }\n                if (!x.data) debugger;\n\n                const showData =\n                    (x.data.rawData\n                        ? uplcDataSerializer(\"\", x.data.rawData)\n                        : x.data?.toString() || \"\u2039no data\u203A\") +\n                    \"\\n\" +\n                    bytesToHex(x.data.toCbor());\n\n                return [x.policyIndex, showData];\n            })\n            .filter((x) => !!x)\n    );\n\n    //!!! todo: improve interface of tx so useful things have a non-private api\n    //!!! todo: get back to type-safety in this diagnostic suite\n    for (const [where, x] of outputOrder) {\n        let item = tx[where][x];\n        let skipLabel = false;\n        if (Array.isArray(item) && !item.length) continue;\n\n        if (!item) continue;\n        if (\"inputs\" == x) {\n            item = `\\n  ${item\n                .map((x: TxInput, i) => {\n                    const { r, display } =\n                        inputRedeemers[i] ||\n                        inputRedeemers[\"hasIndeterminate\"] ||\n                        {};\n                    if (!display && x.datum?.data) debugger;\n                    tx;\n                    if (r) seenRedeemers.add(r);\n                    return txInputAsString(\n                        x,\n                        /* unicode blue arrow right -> */ \"\u27A1\uFE0F  \" + `@${1 + i} `,\n                        i,\n                        display // || \"\u2039failed to find redeemer info\u203A\"\n                    );\n                })\n                .join(\"\\n  \")}`;\n        }\n        if (\"refInputs\" == x) {\n            item = `\\n  ${item\n                .map((x) => txInputAsString(x, \"\u2139\uFE0F  \"))\n                .join(\"\\n  \")}`;\n        }\n        if (\"collateral\" == x) {\n            //!!! todo: group collateral with inputs and reflect it being spent either way,\n            //     IFF it is also a tx `input`\n            //!!! todo: move collateral to bottom with collateralReturn,\n            //     IFF it is not part of the tx `inputs`\n            item = item.map((x) => txInputAsString(x, \"\uD83D\uDD2A\")).join(\"\\n    \");\n        }\n        if (\"minted\" == x) {\n            if (!item.assets.length) {\n                continue;\n            }\n            item = `\\n   \u2747\uFE0F  ${assetsAsString(\n                item,\n                \"\\n   \u2747\uFE0F  \",\n                \"withBURN\",\n                mintRedeemers\n            )}`;\n        }\n        if (\"outputs\" == x) {\n            item = `\\n  ${item\n                .map((x, i) =>\n                    txOutputAsString(\n                        x,\n                        \"\uD83D\uDD39\" /* <-- unicode blue bullet */ + `${i} <-`\n                    )\n                )\n                .join(\"\\n  \")}`;\n        }\n        if (\"firstValidSlot\" == x || \"lastValidSlot\" == x) {\n            if (networkParamsHelper) {\n                const slotTime = new Date(networkParamsHelper.slotToTime(item));\n                const timeDiff = (slotTime.getTime() - Date.now()) / 1000;\n                // format timeDiff with explicit plus or minus sign:\n                const sign = timeDiff > 0 ? \"+\" : \"-\";\n                const timeDiffString =\n                    sign + Math.abs(timeDiff).toFixed(1) + \"s\";\n\n                item = `${item} ${slotTime.toLocaleDateString()} ${slotTime.toLocaleTimeString()} (now ${timeDiffString})`;\n            }\n        }\n\n        if (\"signers\" == x) {\n            item = item.map((x) => {\n                const hex = x.toHex();\n                return `\uD83D\uDD11#${hex.slice(0, 6)}\u2026${hex.slice(-4)}`;\n            });\n        }\n\n        if (\"fee\" == x) {\n            item = lovelaceToAda(item);\n\n            // tx.profileReport.split(\"\\n\")[0];\n            // todo: find profile info and restore it here\n        }\n\n        if (\"collateralReturn\" == x) {\n            skipLabel = true;\n            item = `  ${txOutputAsString(\n                item,\n                `0  <- \u2753`\n            )} conditional: collateral change (returned in case of txn failure)`;\n        }\n        if (\"scriptDataHash\" == x) {\n            item = bytesToHex(item);\n        }\n\n        if (\"datums\" == x && !Object.entries(item || {}).length) continue;\n        if (\"signatures\" == x) {\n            if (!item) continue;\n            item = item.map((s) => {\n                const addr = makeAddress(true, s.pubKeyHash);\n                const hashHex = s.pubKeyHash.toHex();\n                return `\uD83D\uDD8A\uFE0F ${addrAsString(addr)} = \uD83D\uDD11\u2026${hashHex.slice(-4)}`;\n            });\n            if (item.length > 1) item.unshift(\"\");\n            item = item.join(\"\\n    \");\n        }\n        if (\"redeemers\" == x) {\n            if (!item) continue;\n\n            //!!! todo: augment with mph when that's available from the Activity.\n            item = item.map((x) => {\n                // console.log(\"redeemer keys\", ...[ ...Object.keys(x2) ], x2.dump());\n                // const isIndeterminate = x.inputIndex == -1;\n                // if (isIndeterminate) indeterminateRedeemerDetails = true;\n                // debugger\n                // const indexInfo = isIndeterminate\n                //     ? `spend txin #\u2039tbd\u203A`\n                // if (x.kind == \"TxSpendingRedeemer\") {\n                //     debugger\n                // }\n                const indexInfo =\n                    x.kind == \"TxMintingRedeemer\"\n                        ? `minting policy ${x.policyIndex}`\n                        : `spend txin \u27A1\uFE0F  @${1 + x.inputIndex}`;\n\n                const showData = seenRedeemers.has(x)\n                    ? \"(see above)\"\n                    : x.data.fromData\n                    ? uplcDataSerializer(\"\", x.data.fromData)\n                    : x.data.toString();\n                return `\uD83C\uDFE7  ${indexInfo} ${showData}`;\n            });\n            if (item.length > 1) item.unshift(\"\");\n            item = item.join(\"\\n    \");\n        }\n        if (\"v2Scripts\" == x) {\n            if (!item) continue;\n            item = item.map((s) => {\n                try {\n                    const mph = s.mintingPolicyHash.toHex();\n                    // debugger\n                    return `\uD83C\uDFE6 ${mph.slice(0, 8)}\u2026${mph.slice(-4)} (minting): ${\n                        s.serializeBytes().length\n                    } bytes`;\n                } catch (e) {\n                    const vh = s.validatorHash;\n\n                    const vhh = vh.toHex();\n                    const addr = makeAddress(true, vh);\n                    // debugger\n                    return `\uD83D\uDCDC ${vhh.slice(0, 8)}\u2026${vhh.slice(\n                        -4\n                    )} (validator at ${addrAsString(addr)}): ${\n                        s.serializeBytes().length\n                    } bytes`;\n                }\n            });\n            if (item.length > 1) item.unshift(\"\");\n            item = item.join(\"\\n    \");\n        }\n        if (\"v2RefScripts\" == x) {\n            item = `${item.length} - see refInputs`;\n            // todo: @helios give us refScripts outside of dump(), which only shows us hex.\n        }\n\n        if (!item) continue;\n        details += `${skipLabel ? \"\" : \"  \" + x + \": \"}${item}\\n`;\n    }\n    try {\n        details += `  txId: ${tx.id().toHex()}`;\n        if (networkParams) details += `  \\n\\nsize: ${tx.toCbor().length} bytes`;\n    } catch (e) {\n        details = details + `(Tx not yet finalized!)`;\n        if (networkParams) details += `\\n  - NOTE: can't determine txn size\\n`;\n    }\n    return details;\n}\n\n/**\n * Converts a TxInput to printable form\n * @remarks\n *\n * Shortens address and output-id for visual simplicity; doesn't include datum info\n * @public\n **/\nexport function txInputAsString(\n    x: TxInput,\n    prefix = \"-> \",\n    index?: number,\n    redeemer?: string\n): string {\n    const { output: oo } = x;\n    const redeemerInfo = redeemer ? `\\n    r = ${redeemer}` : \" \u2039no redeemer\u203A\";\n    const datumInfo =\n        oo.datum?.kind == \"InlineTxOutputDatum\" ? datumSummary(oo.datum) : \"\";\n\n    return `${prefix}${addrAsString(x.address)}${showRefScript(\n        oo.refScript as any\n    )} ${valueAsString(x.value)} ${datumInfo} = \uD83D\uDCD6 ${txOutputIdAsString(\n        x.id\n    )}${redeemerInfo}`;\n}\n\n/**\n * Converts a list of UTxOs to printable form\n * @remarks\n *\n * ... using {@link utxoAsString}\n * @public\n **/\nexport function utxosAsString(\n    utxos: TxInput[],\n    joiner = \"\\n\",\n    utxoDCache?: UtxoDisplayCache\n): string {\n    return utxos.map((u) => utxoAsString(u, \" \uD83D\uDCB5\", utxoDCache)).join(joiner);\n}\n/**\n * Converts a TxOutputId to printable form\n * @public\n */\nexport function txOutputIdAsString(x: TxOutputId, length = 8): string {\n    return (\n        txidAsString(x.txId, length) +\n        \"\uD83D\uDD39\" /* <-- unicode blue bullet */ +\n        `#${x.index}`\n    );\n}\n\n/**\n * Converts a TxId to printable form\n * @remarks\n *\n * ... showing only the first 6 and last 4 characters of the hex\n * @public\n **/\nexport function txidAsString(x: TxId, length = 8): string {\n    const tid = x.toHex();\n    return `${tid.slice(0, length)}\u2026${tid.slice(-4)}`;\n}\n\n/**\n * converts a utxo to printable form\n * @remarks\n *\n * shows shortened output-id and the value being output, plus its datum\n * @internal\n **/\nexport function utxoAsString(\n    x: TxInput,\n    prefix = \"\uD83D\uDCB5\",\n    utxoDCache?: UtxoDisplayCache\n): string {\n    return ` \uD83D\uDCD6 ${txOutputIdAsString(x.id)}: ${txOutputAsString(\n        x.output,\n        prefix,\n        utxoDCache,\n        x.id\n    )}`;\n}\n\n/**\n * converts a Datum to a printable summary\n * @remarks\n *\n * using shortening techniques for the datumHash\n * @public\n **/\nexport function datumSummary(d: TxOutputDatum | null | undefined): string {\n    if (!d) return \"\"; //\"\u2039no datum\u203A\";\n\n    // debugger\n    const dh = d.hash.toHex();\n    const dhss = `${dh.slice(0, 8)}\u2026${dh.slice(-4)}`;\n    if (d.kind == \"InlineTxOutputDatum\") {\n        const attachedData = d.data.rawData;\n        if (attachedData) {\n            return `\\n    d\u2039inline:${dhss} - ${\n                uplcDataSerializer(\"\", attachedData) //.slice(1,-1)\n            }=${d.toCbor().length} bytes\u203A`;\n        } else {\n            return `d\u2039inline:${dhss} - ${d.toCbor().length} bytes\u203A`;\n        }\n    }\n    return `d\u2039hash:${dhss}\u2026\u203A`;\n}\n// /**\n//  * @internal\n//  */\n// export function datumExpanded(d: Datum | null | undefined): string {\n//     if (!d) return \"\";\n//     if (!d.isInline()) return \"\";\n//     const data = bytesToHex(d.data?.toCbor());\n//     return `\\n    d = ${data}`;\n// }\n\n/**\n * Displays a short summary of any provided reference script\n * @remarks\n *\n * detailed remarks\n * @param \u2039pName\u203A - descr\n * @typeParam \u2039pName\u203A - descr (for generic types)\n * @public\n **/\nexport function showRefScript(rs?: UplcProgramV2 | null) {\n    if (!rs) return \"\";\n    const hash = rs.hash();\n    const hh = bytesToHex(hash);\n    const size = rs.toCbor().length;\n    const rshInfo = `${hh.slice(0, 8)}\u2026${hh.slice(-4)}`;\n    return ` \u2039\uD83D\uDCC0 refScript\uD83D\uDCDC ${rshInfo}: ${size} bytes\u203A +`;\n}\n\n/**\n * Converts a txOutput to printable form\n * @remarks\n *\n * including all its values, and shortened Address.\n * @public\n **/\nexport function txOutputAsString(\n    x: TxOutput,\n    prefix = \"<-\",\n    utxoDCache?: UtxoDisplayCache,\n    txoid?: TxOutputId\n): string {\n    if (utxoDCache && !txoid) {\n        throw new Error(\n            `txOutputAsString: must provide txoid when using cache`\n        );\n    }\n    let cache = utxoDCache?.get(txoid!);\n    if (cache) {\n        return `\u267B\uFE0F ${cache} (same as above)`;\n    }\n    cache = `${prefix} ${addrAsString(x.address)}${showRefScript(\n        x.refScript as any\n    )} ${valueAsString(x.value)}`;\n    utxoDCache?.set(txoid!, cache);\n\n    return `${cache} ${datumSummary(x.datum)}`;\n}\n\n/**\n * Renders an address in shortened bech32 form, with prefix and part of the bech32 suffix\n * @remarks\n * @param address - address\n * @public\n **/\nexport function addrAsString(address: Address): string {\n    const bech32 = address.toString();\n    // const uplc = address.toUplcData?.();\n    // const hex = bytesToHex(uplc.toCbor());\n    return `${bech32.slice(0, 14)}\u2026${bech32.slice(-4)}`;\n    // + ` = `+abbreviatedDetailBytes(\"\u2039cbor:\", uplc.toCbor(), 99)+\"\u203A\"\n}\n\n/**\n * Converts an Errors object to a string for onscreen presentation\n * @public\n **/\nexport function errorMapAsString(em: ErrorMap, prefix = \"  \") {\n    return Object.keys(em)\n        .map((k) => `in field ${prefix}${k}: ${JSON.stringify(em[k])}`)\n        .join(\"\\n\");\n}\n\n/**\n * Converts a list of ByteArrays to printable form\n * @remarks\n *\n * ... using {@link hexToPrintableString}\n * @public\n **/\nexport function byteArrayListAsString(\n    items: ByteArrayData[],\n    joiner = \"\\n  \"\n): string {\n    return (\n        \"[\\n  \" +\n        items.map((ba) => byteArrayAsString(ba)).join(joiner) +\n        \"\\n]\\n\"\n    );\n}\n\n/**\n * Renders a byteArray in printable form, assuming it contains (mostly) text\n * @remarks\n *\n * Because it uses {@link hexToPrintableString | hexToPrintableString()}, it will render any non-printable\n * characters using \u2039hex\u203A notation.\n * @param ba - the byte array\n * @public\n **/\nexport function byteArrayAsString(ba: ByteArrayData): string {\n    return hexToPrintableString(ba.toHex());\n}\n\n/**\n * Converts any (supported) input arg to string\n * @remarks\n *\n * more types to be supported TODO\n * @public\n **/\nexport function dumpAny(\n    x:\n        | undefined\n        | Tx\n        | StellarTxnContext\n        | Address\n        | MintingPolicyHash\n        | Value\n        | Assets\n        | TxOutputId\n        | TxOutput\n        | TxOutput[]\n        | TxInput\n        | TxInput[]\n        | TxId\n        | number[]\n        | ByteArrayData\n        | ByteArrayData[],\n    networkParams?: NetworkParams,\n    forJson = false\n) {\n    if (\"undefined\" == typeof x) return \"\u2039undefined\u203A\";\n    //@ts-expect-error probing type \n    if (x?.kind == \"Assets\") {\n        return `assets: ${assetsAsString(x as Assets)}`;\n    }\n    if (Array.isArray(x)) {\n        if (!x.length) return \"\u2039empty array\u203A\";\n\n        const firstItem = x[0];\n        if (\"number\" == typeof firstItem) {\n            return (\n                `num array: \u2039\"${ \n                    byteArrayAsString(makeByteArrayData(x as number[]))\n                }\"\u203A`\n            );\n        }\n        if (firstItem.kind == \"TxOutput\") {\n            return (\n                \"tx outputs: \\n\" +\n                (x as TxOutput[]).map((txo: TxOutput) => txOutputAsString(txo)).join(\"\\n\")\n            );\n        }\n\n        if (firstItem.kind == \"TxInput\") {\n            return \"utxos: \\n\" + utxosAsString(x as TxInput[]);\n        }\n\n        //@ts-expect-error on this type probe\n        if (firstItem.kind == \"ByteArrayData\") {\n            return (\n                \"byte array list:\\n\" + byteArrayListAsString(x as ByteArrayData[])\n            );\n        }\n\n        if (\"object\" == typeof firstItem) {\n            // debugger;\n            if (firstItem instanceof Uint8Array) {\n                return `byte array: \u2039\"${byteArrayAsString(firstItem)}\"\u203A`;\n            }\n            return (\n                `[` +\n                x\n                    .map((item) => JSON.stringify(item, betterJsonSerializer))\n                    .join(\", \") +\n                `]`\n            );\n        }\n\n        console.log(\"firstItem\", firstItem);\n        throw new Error(\n            `dumpAny(): unsupported array type: ${typeof firstItem}`\n        );\n    }\n\n    if (\"bigint\" == typeof x) {\n        return (x as bigint).toString();\n    }\n    if (x instanceof StellarTxnContext) {\n        debugger;\n        throw new Error(`use await build() and dump the result instead.`);\n    }\n\n    const xx = x;\n\n    if (x.kind == \"TxOutput\") {\n        return txOutputAsString(x as TxOutput);\n    }\n\n    if (xx.kind == \"Tx\") {\n        return txAsString(xx, networkParams);\n    }\n\n    if (xx.kind == \"TxOutputId\") {\n        return txOutputIdAsString(xx);\n    }\n\n    if (xx.kind == \"TxId\") {\n        return txidAsString(xx);\n    }\n\n    if (xx.kind == \"TxInput\") {\n        return utxoAsString(xx);\n    }\n    if (xx.kind == \"Value\") {\n        return valueAsString(xx);\n    }\n    if (xx.kind == \"Address\") {\n        return addrAsString(xx);\n    }\n    if (xx.kind == \"MintingPolicyHash\") {\n        return policyIdAsString(xx);\n    }\n    if (forJson) return xx;\n\n    if (\"object\" == typeof x) {\n        return `{${Object.entries(x)\n            .map(([k, v]) => `${k}: ${dumpAny(v as any, networkParams)}`)\n            .join(\",\\n\")}}`;\n    }\n    debugger;\n    return \"dumpAny(): unsupported type or library mismatch\";\n}\n\n/**\n * @public\n */\nexport const betterJsonSerializer = (key, value) => {\n    return dumpAny(value, undefined, true);\n};\n\nif (\"undefined\" == typeof window) {\n    globalThis.peek = dumpAny;\n} else {\n    //@ts-expect-error\n    window.peek = dumpAny;\n}\n"],
  "mappings": "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",
  "names": ["path", "existsSync", "readFileSync", "createFilter", "blake2b", "bytesToHex", "readFileSync", "path", "path", "path", "path", "filteredFields", "path", "filename", "readFileSync", "cwd", "existsSync", "readFileSync", "path", "DEBUG", "existsSync", "readFileSync", "path", "start", "bytesToHex", "makeAssets", "bytesToHex", "tx", "makeAssets", "bytesToHex", "txName", "tcx", "t", "isolatedTcx", "makeNetworkParamsHelper", "bytesToHex", "p", "makeNetworkParamsHelper", "bytesToHex", "x", "delegateLinkSerializer", "bytesToHex", "abbreviatedDetailBytes", "extraNewLine", "usesOutdent", "multiLine", "s", "path", "existsSync", "createFilter", "p", "readFileSync", "scriptHash", "programBundle", "config", "delegateLinkSerializer", "bytesToHex", "blake2b"]
}
