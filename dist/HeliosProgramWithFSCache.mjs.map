{
  "version": 3,
  "sources": ["../src/helios/CachedHeliosProgramFS.ts", "../src/helios/CachedHeliosProgram.ts", "../src/HeliosPromotedTypes.ts"],
  "sourcesContent": ["import * as lockfile from \"proper-lockfile\";\nimport { readFile, writeFile } from \"fs/promises\";\nimport { existsSync, mkdirSync } from \"fs\";\n\nimport {\n    CachedHeliosProgram,\n    type CacheableProgramProps,\n    type HeliosProgramCacheEntry,\n    type lockInfo,\n    type LockInfoForStrat,\n    type SerializedHeliosCacheEntry,\n} from \"./CachedHeliosProgram.js\";\nimport type { Source } from \"@helios-lang/compiler-utils\";\n\nconst cacheStore = \".hltemp/cache\";\n\nexport class CachedHeliosProgramFS extends CachedHeliosProgram {\n    constructor(mainSource: string | Source, props: CacheableProgramProps) {\n        // if the cacheStore directory doesn't exist, create it.\n        if (!existsSync(cacheStore)) {\n            console.log(\n                `\uD83D\uDC22${CachedHeliosProgram.id} Creating helios compiler cache in ${cacheStore}`\n            );\n            mkdirSync(cacheStore, { recursive: true });\n        }\n        super(mainSource, props);\n    }\n    \n    static checkFile(srcFilename: string): boolean | null {\n        return existsSync(srcFilename);\n    }\n\n    static async ifCached(cacheKey: string): Promise<string | null> {\n        if (existsSync(`${cacheStore}/${cacheKey}`)) {\n            const result = await readFile(`${cacheStore}/${cacheKey}`, \"utf8\");\n            try {\n                console.log(\n                    `\uD83D\uDC22${this.id}: compiler cache entry: ${cacheKey}: ${result.length} bytes`\n                );\n                const parsed = JSON.parse(result);\n                const { unoptimized, optimized } = parsed;\n                console.log(\n                    `   unoptimized=${\n                        unoptimized?.length / 2\n                    } bytes, optimized=${optimized?.length / 2} bytes`\n                );\n            } catch (e) {\n                console.log(\n                    `\uD83D\uDC22${this.id}: parse error -> cache miss: ${cacheKey}`\n                );\n                return null;\n            }\n            return result;\n        }\n        console.log(`\uD83D\uDC22${this.id}: compiler cache miss: ${cacheKey}`);\n        return null;\n    }\n\n    static async acquireImmediateLock(\n        cacheKey: any,\n        props: CacheableProgramProps\n    ): Promise<LockInfoForStrat<CachedHeliosProgramFS> | null> {\n        const filename = `${cacheStore}/${cacheKey}`;\n        let created = false;\n        if (!existsSync(filename)) {\n            // create it empty\n            await writeFile(filename, \"\");\n            created = true;\n            console.log(\n                `\uD83D\uDC22${this.id}: compiler cache: create and lock ${cacheKey}`\n            );\n        }\n        return lockfile\n            .lock(filename, {\n                stale: props.timeout,\n                update: 1000,\n            })\n            .then((release) => {\n                if (!created) {\n                    console.log(\n                        `\uD83D\uDC22${this.id}: compiler cache: lock acquired for ${cacheKey}`\n                    );\n                }\n                return {\n                    lock: null,\n                    cacheKey,\n                    release: release,\n                };\n            })\n            .catch((err) => {\n                // probably want this to be silent, if all is well.\n                if (created) {\n                    console.log(\n                        `\uD83D\uDC22${this.id}: compiler cache: immediate lock not available for ${cacheKey}: ${err.message}`\n                    );\n                }\n                return null;\n            });\n    }\n\n    static async acquireLock(\n        cacheKey: any,\n        props: CacheableProgramProps\n    ): Promise<lockInfo<null>> {\n        const filename = `${cacheStore}/${cacheKey}`;\n        if (!existsSync(filename)) {\n            // create it empty\n            await writeFile(filename, \"\");\n            console.log(`\uD83D\uDC22${this.id}: compiler cache: creating ${cacheKey}`);\n        }\n        return lockfile\n            .lock(filename, {\n                retries: {\n                    factor: 1.41,\n                    minTimeout: 200,\n                    maxTimeout: props.timeout,\n                    randomize: true,\n                    maxRetryTime: props.timeout,\n                },\n                stale: 15000,\n                update: 1000,\n            })\n            .then((release) => {\n                console.log(\n                    `\uD83D\uDC22${this.id}: compiler cache: lock acquired for ${cacheKey}`\n                );\n                \n\n                return {\n                    lock: null,\n                    cacheKey,\n                    release: release,\n                };\n            });\n    }\n\n    static async cacheStore(\n        key: string,\n        value: string,\n        object: HeliosProgramCacheEntry\n    ): Promise<void> {\n        console.log(\n            `\uD83D\uDC22${this.id}: compiler cache: storing ${key}: ${value.length} bytes`\n        );\n        await writeFile(`${cacheStore}/${key}`, value);\n        if (object.optimizedIR) {\n            await writeFile(\n                `${cacheStore}/${key}-ir-optimized`,\n                object.optimizedIR\n            );\n        }\n        if (object.unoptimizedIR) {\n            await writeFile(\n                `${cacheStore}/${key}-ir-unoptimized`,\n                object.unoptimizedIR\n            );\n        }\n    }\n};\n", "import {\n    Program,\n    type CompileOptions,\n    type ProgramProps,\n} from \"@helios-lang/compiler\";\nimport type { Source } from \"@helios-lang/compiler-utils\";\nimport {\n    decodeUplcProgramV2FromCbor,\n    deserializeUplcSourceMap,\n    makeUplcSourceMap,\n    type UplcProgramV2,\n    type UplcSourceMapJsonSafe,\n} from \"@helios-lang/uplc\";\nimport { bytesToHex } from \"@helios-lang/codec-utils\";\nimport { blake2b } from \"@helios-lang/crypto\";\nimport { extractName } from \"@helios-lang/compiler\";\n\nimport { textToBytes } from \"../HeliosPromotedTypes.js\";\nimport type { CompileOptionsForCachedHeliosProgram } from \"../HeliosPromotedTypes.js\";\n\nexport type CacheableProgramProps = ProgramProps & {\n    isTestnet: boolean; // non-optional\n    /**\n     * The cache key for the program. Defaults to the hash of the source code.\n     * If there is no source code, the cacheKey is required\n     */\n    cacheKey?: string;\n    /**\n     * The timeout, in milliseconds for waiting for another instance to finish compiling.\n     * The default timeout is 30 seconds.\n     */\n    timeout?: number;\n    /**\n     * The expected script hash for the program.  The compiled program is checked against\n     * this script hash, if provided.\n     */\n    expectedScriptHash?: string;\n    /**\n     * name of the script, which may be different from the name of the script's entry-point\n     * / main module\n     */\n    name?: string;\n};\n\ntype OptimizeOptions =\n    | false\n    | Omit<\n          Exclude<CompileOptions[\"optimize\"], boolean | undefined>,\n          \"iterSpecificOptions\" | \"commonSubExprCount\"\n      >;\n\n/**\n * @internal\n */\nexport type HeliosProgramCacheEntry = {\n    version: \"PlutusV2\" | \"PlutusV3\";\n    createdBy: string;\n    programElements: Record<string, string | Object>;\n    optimizeOptions: OptimizeOptions;\n    optimized?: UplcProgramV2; // | UplcProgramV3I;\n    unoptimized?: UplcProgramV2; //| UplcProgramV3I;\n    optimizedIR?: string;\n    unoptimizedIR?: string;\n    optimizedSmap?: UplcSourceMapJsonSafe;\n    unoptimizedSmap?: UplcSourceMapJsonSafe;\n};\n\n/**\n * @internal\n */\nexport type SerializedHeliosCacheEntry = {\n    version: \"PlutusV2\" | \"PlutusV3\";\n    createdBy: string;\n    programElements: Record<string, string | Object>;\n    optimizeOptions: OptimizeOptions;\n    optimized?: string;\n    unoptimized?: string;\n    optimizedIR?: string;\n    unoptimizedIR?: string;\n    optimizedSmap?: UplcSourceMapJsonSafe;\n    unoptimizedSmap?: UplcSourceMapJsonSafe;\n};\n\n/**\n * @internal\n */\nexport type DeployedProgramBundle = Pick<\n    SerializedHeliosCacheEntry,\n    | \"version\"\n    | \"programElements\"\n    | \"optimized\"\n    | \"unoptimized\"\n    | \"optimizedIR\"\n    | \"unoptimizedIR\"\n    | \"optimizedSmap\"\n    | \"unoptimizedSmap\"\n>;\n\n/**\n * @internal\n */\nexport type lockInfo<T> = {\n    lock: T;\n    release: () => void;\n};\n\n/**\n * @internal\n */\nexport type LockInfoForStrat<T extends CachedHeliosProgram> = Awaited<\n    ReturnType<T[\"acquireLock\"]>\n>;\n\nconst redirecToCorrectConstructor =\n    \"\uD83D\uDC22${this.id}: wrong direct use of new() constructor in CachedHeliosProgram; use forCurrentPlatform() instead\";\n\n/**\n * A Helios program that caches its compiled UPLC program.\n * @remarks\n * Only available in the node.js environment for now, by importing\n * HeliosProgramWithCacheAPI from the @stellar-contracts/HeliosProgramWithCacheAPI module.\n *\n * ### Feedback please?\n * Probably nobody ever sees this doc?  If you do, please let us know!\n * @public\n */\nexport class CachedHeliosProgram extends Program {\n    // static memoryCache = new Map<string, UplcProgramV2 | UplcProgramV3>();\n    props: CacheableProgramProps;\n    locks: Map<string, lockInfo<any>> = new Map();\n    programElements: Record<string, string | Object>;\n    cacheEntry: HeliosProgramCacheEntry | undefined;\n\n    sources: (Source | string)[];\n    static id: string =\n        globalThis?.id || Math.floor(Math.random() * 1000).toString();\n    id: string;\n\n    /**\n     * Creates a new CachedHeliosProgram.\n     * @remarks\n     * Expects the same arguments as the Helios {@link Program} constructor.\n     *\n     * Returns a Program subclass that also conforms to the CachedHeliosProgram interface.\n     *\n     * Use the {@link compileCached | compileCached()} method to compile the program.\n     * @public\n     */\n    constructor(mainSource: string | Source, props: CacheableProgramProps) {\n        super(mainSource, props);\n        this.sources = [mainSource, ...(props?.moduleSources || [])];\n        this.programElements = {};\n        this.id = this.subclass.id;\n        const effectiveProps = {\n            ...{\n                timeout: 30000,\n            },\n            ...(props || {}),\n        };\n        this.props = effectiveProps;\n\n        if (this.constructor === CachedHeliosProgram) {\n            throw new Error(redirecToCorrectConstructor);\n        }\n    }\n\n    /**\n     * Checks for the presence of a cache key, without attempting a lock.  Indicates\n     * whether the program is in the cache; if so, no lock is needed to read it.  Returns\n     * the cached program if found, or null if not found.  Must be implemented by each subclass\n     * as a platform-specific STATIC method.\n     */\n    static async ifCached(cacheKey: string): Promise<string | null> {\n        throw new Error(redirecToCorrectConstructor);\n    }\n\n    /**\n     * Acquires a lock for the given cache key.  Must be implemented by each subclass\n     * as a platform-specific STATIC method.  Blocks while waiting for the lock.  Returns\n     * the lock details or throws an error if the lock cannot be acquired.\n     * The method receives the cache key and the program properties, which includes\n     * the timeout to be used.\n     */\n    static async acquireLock(\n        cacheKey: string,\n        props: CacheableProgramProps\n    ): Promise<lockInfo<any>> {\n        throw new Error(redirecToCorrectConstructor);\n    }\n\n    /**\n     * Acquires a lock for the given cache key, but does not wait.  Must be implemented by each subclass\n     * as a platform-specific STATIC method.\n     */\n    static async acquireImmediateLock(\n        cacheKey: any,\n        props: CacheableProgramProps\n    ): Promise<lockInfo<any> | null> {\n        throw new Error(redirecToCorrectConstructor);\n    }\n\n    /**\n     * Stores a compiled UPLC program in the cache.  Must be implemented by each subclass\n     * as a platform-specific STATIC method.\n     */\n    static async cacheStore(\n        key: string,\n        value: string,\n        raw: HeliosProgramCacheEntry\n    ): Promise<void> {\n        throw new Error(redirecToCorrectConstructor);\n    }\n\n    static async initCacheFromBundle(\n        cacheEntries: Record<string, string | SerializedHeliosCacheEntry>\n    ): Promise<void> {\n        //!!! todo work on this more\n        for (const [key, value] of Object.entries(cacheEntries)) {\n            const found = await this.ifCached(key);\n            if (found) {\n                console.log(\n                    `\uD83D\uDC22${this.id}: duplicate key in compiler cache: ${key}`\n                );\n            }\n            if (\"string\" === typeof value) {\n                this.cacheStore(\n                    key,\n                    value,\n                    this.toHeliosProgramCacheEntry(JSON.parse(value))\n                );\n            } else {\n                const { version } = value;\n                if (version !== \"PlutusV2\" && version !== \"PlutusV3\") {\n                    console.log(\n                        `\uD83D\uDC22${this.id}: unknown version '${version}'' in compiler cache entry: ${key}; skipping`\n                    );\n                    continue;\n                }\n                try {\n                    programFromCacheEntry(value);\n                } catch (e: any) {\n                    console.log(e.message);\n                    console.log(\n                        `^^ \uD83D\uDC22${this.id}: error parsing CBOR program from cache entry: ${key}; skipping`\n                    );\n                    continue;\n                }\n\n                this.cacheStore(\n                    key,\n                    JSON.stringify(value),\n                    this.toHeliosProgramCacheEntry(value)\n                );\n            }\n        }\n    }\n\n    static toHeliosProgramCacheEntry(\n        value: SerializedHeliosCacheEntry\n    ): HeliosProgramCacheEntry {\n        throw new Error(\"todo\");\n    }\n\n    /**\n     * for vscode index view\n     * @internal\n     */\n    private async ______endStatics() {}\n\n    // hashObjectElements(obj: Record<string, string>): Record<string, string> {\n    //     return Object.fromEntries(\n    //         Object.entries(obj).map(([name, content]) => [\n    //             name,\n    //             bytesToHex(blake2b(textToBytes(content))),\n    //         ])\n    //     );\n    // }\n\n    /**\n     * transforms an object of strings, hashing its values\n     */\n    hashObjectEntries(obj: Record<string, string>): Record<string, string> {\n        return Object.fromEntries(\n            Object.entries(obj).map(([name, content]) => [\n                name,\n                bytesToHex(blake2b(textToBytes(content))),\n            ])\n        );\n    }\n\n    /**\n     * transforms an object of strings to a text representation in RFC822 \"headers\" style\n     */\n    objectToText(obj: Record<string, string | number | boolean>): string {\n        return Object.entries(obj)\n            .map(([name, content]) => `${name}: ${content}`)\n            .join(\"\\n\");\n    }\n\n    /**\n     * Builds an index of the source code hashes for the program elements\n     * (main script, other modules)\n     */\n    sourceHashIndex(): Record<string, string> {\n        return this.hashObjectEntries(\n            Object.fromEntries(\n                this.sources.map((s) => {\n                    const name =\n                        \"string\" === typeof s ? extractName(s) : s.name;\n                    const content = \"string\" === typeof s ? s : s.content;\n                    return [name, content];\n                })\n            )\n        );\n    }\n\n    /**\n     * Gathers the program elements needed for caching\n     */\n    gatherProgramElements(): Record<string, string | Object> {\n        return (this.programElements = {\n            ...this.sourceHashIndex(),\n            params: this.entryPoint.paramsDetails(),\n        });\n    }\n\n    computeInputsHash(options: CompileOptionsForCachedHeliosProgram): string {\n        const index = {\n            ...this.programElements,\n        };\n        const { params, ...otherElements } = index;\n        const elementsText = this.objectToText(otherElements as any);\n        const paramsContent = this.objectToText(params as any);\n        // let optimize: OptimizeOptions = options.optimize ?? {};\n        // if (true == optimize) optimize = {};\n        // const optimizeText =\n        // false == optimize ? \"unoptimized\" : this.objectToText(optimize);\n        const optimizeText = this.textOptimizeOptions(options);\n        const optimizeHash = bytesToHex(blake2b(textToBytes(optimizeText)));\n\n        const paramsHashText = this.objectToText(\n            this.hashObjectEntries({ params: paramsContent })\n        );\n        return bytesToHex(\n            blake2b(\n                textToBytes(\n                    elementsText +\n                        \"\\n\" +\n                        paramsHashText +\n                        \"\\n\" +\n                        optimizeHash +\n                        \"\\n\"\n                )\n            )\n        );\n    }\n\n    optimizeOptions(\n        options: CompileOptionsForCachedHeliosProgram\n    ): OptimizeOptions {\n        let optimize: OptimizeOptions =\n            true == options.optimize\n                ? {}\n                : (options.optimize as OptimizeOptions) ?? {};\n\n        return optimize;\n    }\n\n    textOptimizeOptions(options: CompileOptionsForCachedHeliosProgram): string {\n        let optimize = this.optimizeOptions(options);\n        if (false == optimize) return \"unoptimized\";\n        type justOptions = Exclude<OptimizeOptions, false>;\n        let o: justOptions = optimize as any;\n        return this.objectToText(\n            // sort the keys in optimize.\n            Object.fromEntries(\n                Object.entries(o).sort(([a], [b]) => a.localeCompare(b))\n            ) as justOptions\n        );\n    }\n\n    get preferredProgramName(): string {\n        return this.props.name || this.name;\n    }\n\n    getCacheKey(options: CompileOptionsForCachedHeliosProgram): string {\n        if (this.props.cacheKey) {\n            // for using ScriptHash as the caching key\n            return this.props.cacheKey;\n        }\n        const hashString = this.computeInputsHash(options);\n        const opt = false == options.optimize ? \"-unoptimized\" : \"\";\n\n        return `${this.preferredProgramName}${opt}-${hashString}`;\n    }\n\n    /**\n     * Compiles a Helios program to UPLC, with caching for performance\n     *\n     * ### Caching behavior\n     * This method seeks to quickly return a compiled version of the program, using\n     * a platform-specific cache (and lock) mechanism.\n     * #### Happy path\n     *  - if the program is found in the cache, it is immediately returned\n     * #### First compilation and cache-storage\n     *  - Otherwise, a lock is acquired and the program is compiled\n     *  - Once compiled, the cache entry is created for future use, and its lock is lifted\n     *\n     * #### When there is a compile already pending\n     *\n     * Once a Helios program starts compiling once, calling `compileCached()` on any\n     * instance of the same program with the same settings results in the same cache\n     * key.  This may occur in a different browser tab, service worker, node-js thread/worker,\n     * or a different node process.  In each case, the second `compileCached()` call:\n     *\n     *  - Issues a warning that it is waiting for another process to complete the compilation.\n     *  - waits up to 15 seconds (or the configured `timeout`) for a lock (indicating that\n     *    another instance is compiling the program already)\n     * - when the lock  is released, the compiled program is read from the cache, and returned.\n     *  - includes the unoptimized version of the UPLC program for logging\n     *\n     * #### When everything goes wrong\n     * If the process holding a lock doesn't succeed and doesn't release the lock, the\n     * lock goes stale automatically, and the lock fails (after the `timeout` period).  In\n     * this case, each instance of the program:\n     *\n     *   - makes a last attempt to compile the program\n     *   - If it fails, the local process will report the error normally, and no caching is done\n     *   - If it succeeds, the result is returned.\n     *   - it also tries to cache the result (if it can do so without delay)\n     *\n     *  - todo: measure the time cost of the \"has errors\" path.\n     *\n     * See Helios' {@link Program.compile} for more information about compiling Helios programs.\n     *\n     * import from stellar-contracts/CacheableProgramAPI in a node.js environment\n     * to access this method.  In the web environment, that import returns a different\n     * class with the same interface.\n     */\n    async compileWithCache(\n        optimizeOrOptions: boolean | CompileOptionsForCachedHeliosProgram\n    ): Promise<UplcProgramV2> {\n        // Promise<UplcProgramV2 | UplcProgramV3> {\n        const options: CompileOptionsForCachedHeliosProgram =\n            typeof optimizeOrOptions === \"boolean\"\n                ? { optimize: optimizeOrOptions }\n                : optimizeOrOptions;\n        const optimize = this.optimizeOptions(optimizeOrOptions as any);\n\n        const programElements = (this.programElements =\n            this.gatherProgramElements());\n\n        const start = Date.now();\n        const cacheKey = this.getCacheKey(options);\n        // const cachedProgram = CachedHeliosProgram.memoryCache.get(cacheKey);\n\n        const fromCache = await this.getFromCache(cacheKey);\n        if (fromCache) {\n            // const programCount = fromCache.alt ? 2 : 1;\n            console.log(`\uD83D\uDC22${this.id}: ${cacheKey}: from cache`);\n            const end1 = Date.now();\n            this.compileTime = {\n                fetchedCache: end1 - start,\n            }\n            return fromCache;\n        }\n        // not in cache.  Get the lock; if we get it, then we compile.  If not, we wait\n        // for the lock to be released by another instance.\n        const weMustCompile = await this.acquireImmediateLock(cacheKey);\n        const otherInstanceIsCompiling = !weMustCompile;\n        if (otherInstanceIsCompiling) {\n            console.log(\n                `\uD83D\uDC22${this.id}: waiting for pending compile: ${cacheKey}`\n            );\n            try {\n                const cacheEntry = await this.waitForCaching(cacheKey);\n                const program = programFromCacheEntry(cacheEntry);        \n                this.cacheEntry = deserializeHeliosCacheEntry(cacheEntry);\n                debugger\n                return program\n            } catch (e) {\n                console.log(\n                    `\uD83D\uDC22${this.id}: Failed getting cache-awaited program with cacheKey: ${cacheKey}; will compile in-process`\n                );\n                // if this happens, there should be a lock in the locks map... vvvvv\n            }\n        }\n        // we either are delayed from a failed wait-for-cache (with pending lock)\n        // ... or we got an immediate lock\n        let lock = weMustCompile || this.locks.get(cacheKey);\n        if (!lock) {\n            throw new Error(\n                `we should have a lock one way or other at this point`\n            );\n        }\n\n        try {\n            console.log(\n                `\uD83D\uDC22${this.id}: compiling program with cacheKey: ${cacheKey}`\n            );\n            const start = Date.now();\n            // slow!\n            const uplcProgram = this.compile(options);\n            const end1 = Date.now();\n            const cacheEntry: HeliosProgramCacheEntry = {\n                version: \"PlutusV2\",\n                createdBy: this.id,\n                optimizeOptions: optimize,\n                programElements,\n            };\n\n            if (uplcProgram.alt) {\n                cacheEntry.unoptimized = uplcProgram.alt;\n                cacheEntry.unoptimizedIR = uplcProgram.alt.ir;\n                cacheEntry.unoptimizedSmap = makeUplcSourceMap({\n                    term: uplcProgram.alt.root,\n                }).toJsonSafe();\n\n                cacheEntry.optimized = uplcProgram;\n                cacheEntry.optimizedIR = uplcProgram.ir;\n                cacheEntry.optimizedSmap = makeUplcSourceMap({\n                    term: uplcProgram.root,\n                }).toJsonSafe();\n            } else {\n                const sourceMap = makeUplcSourceMap({ term: uplcProgram.root });\n                if (false == options.optimize) {\n                    cacheEntry.unoptimized = uplcProgram;\n                    cacheEntry.unoptimizedIR = uplcProgram.ir;\n                    cacheEntry.unoptimizedSmap = sourceMap.toJsonSafe();\n                } else {\n                    cacheEntry.optimized = uplcProgram;\n                    cacheEntry.optimizedIR = uplcProgram.ir;\n                    cacheEntry.optimizedSmap = sourceMap.toJsonSafe();\n                }\n            }\n            this.cacheEntry = cacheEntry;\n            this.storeInCache(cacheKey, cacheEntry);\n            const end2 = Date.now();\n            this.compileTime = {\n                compiled: end1 - start,\n                stored: end2 - end1,\n            }\n            return uplcProgram;\n        } catch (e: any) {\n            debugger;\n            console.log(\n                `\uD83D\uDC22${this.id}: compiler cache: throwing compile error: ${e.message} (not caching) (dbpa)`\n            );\n            this.releaseLock(cacheKey);\n            throw e;\n        }\n    }\n    compileTime: {\n        compiled?: number,\n        stored?: number,\n        fetchedCache?: number,\n    } | undefined;\n\n    async waitForCaching(\n        cacheKey: string\n    ): Promise<SerializedHeliosCacheEntry> {\n        // we won't get the lock very quickly, but it should come through as\n        // soon as the other process finishes.\n        return this.acquireLock(cacheKey).then(async (lock) => {\n            if (lock) {\n                const cached = await this.ifCached(cacheKey);\n                if (cached) {\n                    lock?.release();\n                    return cached;\n                }\n                // things aren't great if we get here.  But we got the lock, so we can\n                // use it to store the program in the cache.\n                this.locks.set(cacheKey, lock);\n                console.log(\n                    `\uD83D\uDC22${this.id}: waitForCaching: Lock acquired but no cache entry.  Storing lock in map`\n                );\n                throw new Error(\n                    `Lock acquired but no cache entry for ${cacheKey}; compute locally then release this.locks[key].`\n                );\n            }\n            throw new Error(\n                `Lock for ${cacheKey} not acquired; compute locally (and try to populate the cache if possible)`\n            );\n        });\n    }\n\n    async getFromCache(\n        cacheKey: string\n    ): Promise<undefined | UplcProgramV2 /* | UplcProgramV3 */> {\n        const cacheEntry = await this.ifCached(cacheKey);\n        if (cacheEntry) {\n            this.cacheEntry = deserializeHeliosCacheEntry(cacheEntry)\n            // debugger\n            return programFromCacheEntry(cacheEntry);\n        }\n        return undefined;\n    }\n\n    get subclass(): typeof CachedHeliosProgram {\n        return this.constructor as typeof CachedHeliosProgram;\n    }\n\n    static checkPlatform(): \"web\" | \"nodejs\" {\n        // determine if in-browser or using node.js\n        // thanks to https://gist.github.com/rhysburnie/498bfd98f24b7daf5fd5930c7f3c1b7b\n\n        // alt: consider this approach https://stackoverflow.com/a/31090240\n\n        // thuthy\n        var _nodejs: any =\n            typeof process !== \"undefined\" &&\n            process.versions &&\n            process.versions.node;\n        if (_nodejs) {\n            _nodejs = {\n                version: process.versions.node,\n            };\n        }\n\n        // truthy\n        var _browser: any =\n            !_nodejs &&\n            (typeof window !== \"undefined\" || typeof self !== \"undefined\");\n        if (_browser) {\n            // _browser = {\n            //     window: false,\n            //     self: false,\n            //     $: false,\n            // };\n            if (typeof global === \"undefined\") {\n                if (typeof window !== \"undefined\") {\n                    global = window;\n                    _browser.window = true;\n                } else if (typeof self !== \"undefined\") {\n                    global = self;\n                    _browser.self = true;\n                }\n                // } else if (typeof $ !== \"undefined\") {\n                //     global = $;\n                //     _browser.$ = true;\n                // }\n            }\n        }\n\n        if (_nodejs) {\n            console.log(\"Node.js detected\");\n            return \"nodejs\";\n            // module.export = {\n            //     nodejs: _nodejs,\n            //     browser: _browser,\n            // };\n        }\n        console.log(\"Browser env detected\");\n        return \"web\";\n    }\n\n    /**\n     * for vscode index view\n     * @internal\n     */\n    async __vvv_______instanceToStatic() {}\n\n    async ifCached(\n        cacheKey: string\n    ): Promise<SerializedHeliosCacheEntry | null> {\n        const string = await this.subclass.ifCached(cacheKey);\n        if (string) {\n            try {\n                return JSON.parse(string) as SerializedHeliosCacheEntry;\n            } catch (e: any) {\n                console.log(\n                    `  -- \uD83D\uDC22${this.id}: cleaning up invalid cache entry for ${cacheKey}: ${e.message}`\n                );\n                // (cleanup implied by returning null)\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Acquires a lock for the given cache key, waiting according to the\n     * configured `timeout` for another instance to finish compiling.\n     *\n     * Throws an error if the timeout expires\n     */\n    async acquireLock(cacheKey: string) {\n        return this.subclass.acquireLock(cacheKey, this.props).then((lock) => {\n            this.locks.set(cacheKey, lock);\n            return lock;\n        });\n    }\n\n    /**\n     * Acquires a lock for the given cache key if it can do so immediately.\n     * Stores the lock in the instance's lock map.\n     */\n    async acquireImmediateLock(cacheKey: string) {\n        const lock = await this.subclass.acquireImmediateLock(\n            cacheKey,\n            this.props\n        );\n        if (lock) {\n            this.locks.set(cacheKey, lock);\n        }\n        return lock;\n    }\n\n    /**\n     * Stores a compiled UPLC program in the cache.\n     * Requires the lock to exist.\n     * Releases the lock after storing the program.\n     */\n    async storeInCache(\n        cacheKey: string,\n        value: HeliosProgramCacheEntry\n    ): Promise<void> {\n        if (!this.locks.has(cacheKey)) {\n            throw new Error(\n                `storeInCache: the lock for ${cacheKey} is not present`\n            );\n        }\n\n        return this.subclass\n            .cacheStore(\n                cacheKey,\n                stringifyCacheEntry(value),\n                value\n            )\n            .then(() => {\n                this.releaseLock(cacheKey);\n            });\n    }\n\n    /**\n     * Releases the lock for the given cache key.\n     * Removes the lock from the instance's lock map.\n     * Throws an error if the lock is not found.\n     */\n    releaseLock(cacheKey: string) {\n        const lock = this.locks.get(cacheKey);\n        if (lock) {\n            lock.release();\n            this.locks.delete(cacheKey);\n        } else {\n            throw new Error(`releaseLock: no lock found for ${cacheKey}`);\n        }\n    }\n}\n\nexport function stringifyCacheEntry(entry: HeliosProgramCacheEntry): string {\n    return JSON.stringify(\n        serializeCacheEntry(entry),\n        null,\n        2\n    );\n}\n\nexport function serializeCacheEntry(\n    entry: HeliosProgramCacheEntry): SerializedHeliosCacheEntry \n{\n    const { optimized, unoptimized } = entry;\n    return {\n        ...entry,\n        ...(optimized\n            ? { optimized: bytesToHex(optimized.toCbor()) }\n            : {}),\n        ...(unoptimized\n            ? { unoptimized: bytesToHex(unoptimized.toCbor()) }\n            : {}),\n    } as any;\n}\n\nexport function programFromCacheEntry(\n    fromCache: DeployedProgramBundle | SerializedHeliosCacheEntry\n): UplcProgramV2 {\n    //  | UplcProgramV3 {\n    // the program is a hex-string, accepted by both UplcProgramV2 and UplcProgramV3\n    const {\n        optimized,\n        optimizedIR,\n        unoptimized,\n        unoptimizedIR,\n        version,\n        optimizedSmap,\n        unoptimizedSmap,\n        // optimizeOptions,\n        // createdBy,\n        programElements\n    } = fromCache;\n    if (version !== \"PlutusV2\") throw new Error(`pv3supportpending`);\n    // TargetClass = version == \"PlutusV2\" ? UplcProgramV2 : UplcProgramV3;\n\n    const o = optimized\n        ? decodeUplcProgramV2FromCbor(optimized, {\n              ir: optimizedIR,\n              sourceMap: optimizedSmap,\n          })\n        : undefined;\n    const u = unoptimized\n        ? decodeUplcProgramV2FromCbor(unoptimized, {\n              ir: unoptimizedIR,\n              sourceMap: unoptimizedSmap,\n          })\n        : undefined;\n    if (o) {\n        if (u) {\n            return o.withAlt(u); // | UplcProgramV3;\n        }\n        return o;\n    }\n    if (!u) {\n        throw new Error(\n            `\uD83D\uDC22 No optimized or unoptimized program in cache entry: ${fromCache}`\n        );\n    }\n    return u;\n}\n\nexport function deserializeHeliosCacheEntry(\n    entry: SerializedHeliosCacheEntry\n): HeliosProgramCacheEntry {\n    const {\n        optimized,\n        optimizedIR,\n        unoptimized,\n        unoptimizedIR,\n        version,\n        optimizedSmap,\n        unoptimizedSmap,\n        optimizeOptions,\n        createdBy,\n        programElements\n    } = entry\n\n    return {\n        optimized: optimized ? decodeUplcProgramV2FromCbor(optimized) : undefined,\n        unoptimized: unoptimized ? decodeUplcProgramV2FromCbor(unoptimized) : undefined,\n        optimizedSmap: optimizedSmap || undefined, \n        //XXX it's already json-safe. deserializeUplcSourceMap(optimizedSmap).toJsonSafe() : undefined,\n        unoptimizedSmap: unoptimizedSmap || undefined,\n        //XXX it's already json-safe. deserializeUplcSourceMap(unoptimizedSmap).toJsonSafe(): undefined,\n        optimizeOptions,\n        version,\n        createdBy,\n        programElements,\n        optimizedIR,\n        unoptimizedIR,\n    };\n}\n", "import type { CompileOptions } from \"@helios-lang/compiler\";\nimport type { InlineTxOutputDatum } from \"@helios-lang/ledger\";\nimport type { UplcProgramV2, UplcProgramV3 } from \"@helios-lang/uplc\";\n\n/**\n * @public\n */\nexport type CompileOptionsForCachedHeliosProgram = CompileOptions & {\n    /**\n     * The timeout for waiting for another instance to finish compiling.\n     * Defaults to 30 seconds.\n     */\n    timeout?: number;\n};\n\n/**\n * @public\n */\nexport type anyUplcProgram = UplcProgramV2 //| UplcProgramV3;\n\nexport { \n    encodeUtf8 as textToBytes,\n    decodeUtf8 as bytesToText,\n} from \"@helios-lang/codec-utils\";\n\n/**\n * tuple expressing a token-name and count\n * @public\n **/\nexport type tokenNamesOrValuesEntry = [string | number[], bigint];\n/**\n * Tuple of byte-array, count, needed for Value creation on native tokens.\n * @public\n **/\nexport type valuesEntry = [number[], bigint];\n\n/**\n * @public\n */\nexport type InlineDatum = InlineTxOutputDatum\n\n"],
  "mappings": "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",
  "names": ["lock", "start"]
}
