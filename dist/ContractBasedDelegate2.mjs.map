{"version":3,"file":"ContractBasedDelegate2.mjs","sources":["../src/delegation/UutName.ts","../src/UtxoHelper.ts","../src/ActivityTypes.ts","../src/helios/dataBridge/DataBridge.ts","../src/StellarContract.ts","../src/Requirements.ts","../src/delegation/StellarDelegate.ts","../src/delegation/ContractBasedDelegate.ts"],"sourcesContent":["import { bytesToText } from \"../HeliosPromotedTypes.js\";\n\nexport const maxUutName = 32;\n\n/**\n * a unique utility token having a unique name\n * @remarks\n *\n * This class contains a general 'purpose' name, mapped to a unique\n * `name`, which is generated using a seed-utxo pattern.\n *\n * @public\n **/\nexport class UutName {\n    _uutName: string;\n    purpose: string;\n    constructor(purpose: string, fullUutName: string | number[]) {\n        this.purpose = purpose;\n        if (Array.isArray(fullUutName)) {\n            fullUutName = bytesToText(fullUutName);\n        }\n        if (fullUutName.length > maxUutName) {\n            throw new Error(\n                `uut name '${fullUutName}' exceeds max length of ${maxUutName}`\n            );\n        }\n        this._uutName = fullUutName;\n    }\n    /**\n     * the full uniquified name of this UUT\n     * @remarks\n     *\n     * format: `purpose-‹...uniqifier...›`\n     * @public\n     **/\n    get name() {\n        return this._uutName;\n    }\n    toString() {\n        return this._uutName;\n    }\n}\n","import { equalsBytes, type BytesLike } from \"@helios-lang/codec-utils\";\nimport type { SimpleWallet, Wallet } from \"@helios-lang/tx-utils\";\nimport {\n    type Address,\n    type AssetClass,\n    type Assets,\n    type MintingPolicyHash,\n    type TxInput,\n    type TxOutput,\n    type Value,\n    type NetworkParams,\n    makeTxOutput,\n    makeValue,\n    makeAssetClass,\n    makeAddress,\n    makeDummyAddress,\n    type ScriptHash,\n} from \"@helios-lang/ledger\";\n\nimport { StellarTxnContext } from \"./StellarTxnContext.js\";\n// import type { SimpleWallet_stellar } from \"./testing/StellarNetworkEmulator.js\";\nimport { dumpAny, utxosAsString } from \"./diagnostics.js\";\nimport { UutName } from \"./delegation/UutName.js\";\nimport type { SetupInfo, StellarContract } from \"./StellarContract.js\";\nimport { textToBytes } from \"./HeliosPromotedTypes.js\";\n\nexport type utxoSortInfo = {\n    u: TxInput;\n    sufficient: boolean;\n    free: bigint;\n    minAdaAmount: bigint;\n};\n\nexport type canHaveToken = TxInput | TxOutput | Assets;\nexport type tokenPredicate<tokenBearer extends canHaveToken> = ((\n    something: tokenBearer\n) => tokenBearer | undefined) & { predicateValue: Value };\n\n/**\n * a function that can filter txInputs for coin-selection\n * @remarks\n *\n * short form: \"returns truthy\" if the input is matchy for the context\n * @public\n **/\nexport type utxoPredicate = (\n    | ((u: TxInput) => TxInput | undefined)\n    | ((u: TxInput) => boolean)\n    | ((u: TxInput) => boolean | undefined)\n) & {\n    predicateValue?: Value;\n};\n\nexport type UtxoSearchScope = {\n    /**\n     * provides pre-resolved utxos for the indicated address-or-wallet\n     */\n    utxos?: TxInput[];\n    /**\n     * searches in a specific address (e.g. a smart contract address)\n     */\n    address?: Address;\n    /**\n     * searches in this wallet rather than the address\n     */\n    wallet?: Wallet | SimpleWallet; //| SimpleWallet_stellar;\n    /**\n     * @deprecated - ??? use txBatcher's chainBuilder and includeAddlTxns instead\n     * NOTE: if we're only using this to reference our OWN tcx, then\n     *   either make that automatic, or retract the deprecation.\n     */\n    exceptInTcx?: StellarTxnContext;\n    /**\n     * by default it, only dumps detail if global.utxoDump is set to true\n     * @remarks\n     * - use \"onFail\" to log candidate utxos if the search fails\n     * - use \"always\" to log candidate utxos for a single search,\n     *   regardless of success or failure\n     */\n    dumpDetail?: \"onFail\" | \"always\";\n    // utxos : TxInput[]\n};\n\nexport type UtxoSearchScopeWithUtxos = UtxoSearchScope & {\n    utxos: TxInput[];\n    required?: true;\n};\n\n/**\n * A helper class for managing UTXOs in a Stellar contract\n * @remarks\n * Using the provided setup details, this helper provides methods for finding,\n * filtering and selecting UTXOs for inclusion in transactions, and for creating\n * related values and predicate-functions for matching UTXOs.\n * @public\n */\nexport class UtxoHelper {\n    strella?: StellarContract<any>;\n    setup: SetupInfo;\n\n    constructor(setup: SetupInfo, strella?: StellarContract<any>) {\n        this.setup = setup;\n        // console.log(\"UtxoHelper created with setup: \", setup);\n        if (!setup.uxtoDisplayCache) {\n            setup.uxtoDisplayCache = new Map();\n        }\n        this.strella = strella;\n    }\n\n    get networkParams(): NetworkParams {\n        return this.setup.networkParams;\n    }\n\n    get wallet() {\n        return this.setup.actorContext.wallet!;\n    }\n\n    get network() {\n        return this.setup.chainBuilder || this.setup.network;\n    }\n\n    /**\n     * Filters out utxos having non-ada tokens\n     * @internal\n     */\n    hasOnlyAda(value: Value, tcx: StellarTxnContext | undefined, u: TxInput) {\n        const toSortInfo = this.mkUtxoSortInfo(value.lovelace);\n\n        const found = [u]\n            .map(toSortInfo)\n            .filter(this.utxoIsSufficient)\n            .filter(this.utxoIsPureADA)\n            .map(this.sortInfoBackToUtxo)\n            .at(0);\n\n        return found;\n    }\n\n    /**\n     * Sorts utxos by size, with pure-ADA utxos preferred over others.\n     * @internal\n     */\n    utxoSortSmallerAndPureADA(\n        { free: free1, minAdaAmount: r1 }: utxoSortInfo,\n        { free: free2, minAdaAmount: r2 }: utxoSortInfo\n    ) {\n        {\n            //! primary: treats pure-ada utxos as always better\n            if (!r1 && r2) {\n                return -1;\n            }\n            if (r1 && !r2) {\n                return 1; //\n            }\n        }\n        //! secondary: smaller utxos are more preferred than larger ones\n        if (free2 > free1) return -1;\n        if (free2 < free1) return 1;\n        return 0;\n    }\n\n    /**\n     * Filters out utxos that are not sufficient to cover the minimum ADA amount established in\n     * the utxo sort info in {@link UtxoHelper.mkUtxoSortInfo | mkUtxoSortInfo(min, max?)}.  Use in a filter() call.\n     * @internal\n     */\n    utxoIsSufficient({ sufficient }: utxoSortInfo) {\n        return !!sufficient;\n    }\n\n    /**\n     * Filters out utxos that have non-ADA tokens, given a utxo sort info object.  Use in a filter() call.\n     * @internal\n     */\n    utxoIsPureADA({ u }: utxoSortInfo) {\n        return u.value.assets.isZero() ? u : undefined;\n    }\n\n    /**\n     * transforms utxo sort info back to just the utxo.\n     * @internal\n     */\n    sortInfoBackToUtxo({ u }: utxoSortInfo) {\n        return u;\n    }\n\n    /**\n     * Creates a function that creates sort-info details for a utxo, given a minimum ADA amount\n     * and an optional maximum ADA amount.\n     * @internal\n     **/\n    mkUtxoSortInfo(min: bigint, max?: bigint) {\n        return (u: TxInput): utxoSortInfo => {\n            const minAdaAmount = u.value.assets.isZero()\n                ? BigInt(0)\n                : (() => {\n                      const dummy = makeTxOutput(\n                          u.output.address,\n                          makeValue(0, u.output.value.assets)\n                      );\n                      dummy.correctLovelace(this.networkParams);\n                      return dummy.value.lovelace;\n                  })();\n            const free = u.value.lovelace - minAdaAmount;\n            const sufficient = free > min && (max ? free < max : true);\n            const t = { u, sufficient, free, minAdaAmount };\n            // console.log(t, utxoAsString(u))\n            return t;\n        };\n    }\n    /**\n     * accumulates the count of utxos, but only if the utxo is ADA-only.  Use in a reduce() call.\n     **/\n    reduceUtxosCountAdaOnly(c: number, { minAdaAmount }: utxoSortInfo): number {\n        return c + (minAdaAmount ? 0 : 1);\n    }\n\n    hasToken<tokenBearer extends canHaveToken>(\n        something: tokenBearer,\n        value: Value,\n        tokenName?: string,\n        quantity?: bigint\n    ): tokenBearer | undefined {\n        if (something.kind == \"TxOutput\")\n            return (\n                (this.outputHasToken(\n                    something as TxOutput,\n                    value,\n                    tokenName,\n                    quantity\n                ) &&\n                    something) ||\n                undefined\n            );\n\n        if (something.kind == \"TxInput\")\n            return (\n                (this.utxoHasToken(\n                    something as TxInput,\n                    value,\n                    tokenName,\n                    quantity\n                ) &&\n                    something) ||\n                undefined\n            );\n\n        if (something.kind == \"Assets\")\n            return (\n                (this.assetsHasToken(\n                    something as Assets,\n                    value,\n                    tokenName,\n                    quantity\n                ) &&\n                    something) ||\n                undefined\n            );\n\n        throw new Error(\"unexpected\");\n        // //!!! todo: more explicit match for TxInput, which seems to be a type but not an 'instanceof'-testable thing.\n        // return (\n        //     (this.inputHasToken(something, value, tokenName, quantity) &&\n        //         something) ||\n        //     undefined\n        // );\n    }\n\n    utxoHasToken(\n        u: TxInput,\n        value: Value,\n        tokenName?: string,\n        quantity?: bigint\n    ) {\n        return this.outputHasToken(u.output, value, tokenName, quantity) && u;\n    }\n\n    inputHasToken(\n        i: TxInput,\n        value: Value,\n        tokenName?: string,\n        quantity?: bigint\n    ) {\n        return this.outputHasToken(i.output, value, tokenName, quantity) && i;\n    }\n\n    assetsHasToken(\n        a: Assets,\n        vOrMph: Value | MintingPolicyHash,\n        tokenName?: string,\n        quantity?: bigint\n    ) {\n        const v =\n            vOrMph.kind == \"MintingPolicyHash\"\n                ? this.mkAssetValue(vOrMph, tokenName!, quantity!)\n                : vOrMph;\n\n        return a.isGreaterOrEqual(v.assets);\n    }\n\n    outputHasToken(\n        o: TxOutput,\n        vOrMph: Value | MintingPolicyHash,\n        tokenName?: string,\n        quantity?: bigint\n    ) {\n        const isValue = vOrMph.kind == \"Value\";\n        if (!isValue) {\n            if (!tokenName || !quantity) {\n                throw new Error(\n                    `missing required tokenName/quantity (or use a Value in arg2`\n                );\n            }\n        }\n\n        const v = isValue ? vOrMph : makeValue(vOrMph, tokenName!, quantity!);\n\n        return o.value.isGreaterOrEqual(v);\n    }\n\n    /**\n     * @deprecated - use helios `makeValue()` instead\n     */\n    mkAssetValue(\n        mph: MintingPolicyHash,\n        tokenName: BytesLike,\n        count: bigint = 1n\n    ) {\n        // const TL  = [ tokenName, count ] as [ ByteArrayLike, bigint ];\n        // const oneAssetLike = [ mph, [\n        //     TL\n        //  ] ] as [ MintingPolicyHash, [ ByteArrayLike, bigint ][] ];\n        //  const v1 = new Value(undefined, [\n        //     oneAssetLike\n        // ]);\n        // const v2 = new Value(undefined, [\n        //     [ mph, [ TL ] ]\n        // ]);\n        const v = makeValue(\n            mph,\n            tokenName,\n            count\n            // ...other mph / token-map pairs\n        );\n        return v;\n    }\n\n    findSmallestUnusedUtxo(\n        lovelace: bigint,\n        utxos: TxInput[],\n        tcx?: StellarTxnContext\n    ): TxInput | undefined {\n        const value = makeValue(lovelace);\n        const toSortInfo = this.mkUtxoSortInfo(value.lovelace);\n\n        const found = utxos\n            .map(toSortInfo)\n            .filter(this.utxoIsPureADA)\n            .filter(this.utxoIsSufficient)\n            .filter((uInfo: utxoSortInfo) => {\n                if (!tcx) return true;\n                return !!tcx?.utxoNotReserved(uInfo.u);\n            })\n            .sort(this.utxoSortSmallerAndPureADA)\n            .map(this.sortInfoBackToUtxo);\n        console.log(\"smallest utxos: \", utxosAsString(found));\n        const chosen = found.at(0);\n\n        return chosen;\n    }\n\n    /**\n     * creates a filtering function, currently for TxInput-filtering only.\n     * with the optional tcx argument, utxo's already reserved\n     *  ... in that transaction context will be skipped.\n     * @public\n     */\n    mkValuePredicate(\n        lovelace: bigint,\n        tcx?: StellarTxnContext\n    ): tokenPredicate<TxInput> {\n        const value = makeValue(lovelace);\n        const predicate = _adaPredicate.bind(this, tcx) as tokenPredicate<any>;\n        predicate.predicateValue = value;\n        return predicate;\n\n        function _adaPredicate(\n            this: UtxoHelper,\n            tcx: StellarTxnContext | undefined,\n            utxo: TxInput\n        ): TxInput | undefined {\n            return this.hasOnlyAda(value, tcx, utxo);\n        }\n    }\n\n    mkRefScriptPredicate(\n        expectedScriptHash: number[]\n    ) : utxoPredicate {\n        return (txin: TxInput) => {\n            const refScript = txin.output.refScript;\n            if (!refScript) return false;\n\n            const foundHash = refScript.hash();\n            return equalsBytes(foundHash, expectedScriptHash);\n        };\n    }\n\n    /**\n     * Creates an asset class for the given token name, for the indicated minting policy\n     */\n    acAuthorityToken(\n        tokenName: string | number[],\n        mph?: MintingPolicyHash\n    ): AssetClass {\n        let ourMph = mph;\n        if (!ourMph) {\n            if (!this.strella) {\n                throw new Error(\n                    `no contract available for resolving minting policy hash; provide to acAuthorityToken or use a UtxoHelper having a strella prop`\n                );\n            }\n            ourMph = this.strella.mintingPolicyHash;\n        }\n        if (!ourMph) {\n            throw new Error(`no minting policy hash available`);\n        }\n        return makeAssetClass(ourMph, tokenName);\n    }\n\n    /**\n     * Creates a Value object representing a token with a minimum lovelace amount\n     * making it valid for output in a utxo.\n     * @public\n     */\n    mkMinTv(\n        mph: MintingPolicyHash,\n        tokenName: string | UutName | number[],\n        count: bigint = 1n\n    ) {\n        const tnBytes = Array.isArray(tokenName)\n            ? tokenName\n            : textToBytes(tokenName.toString());\n\n        return this.mkMinAssetValue(mph, tnBytes, count);\n    }\n\n    mkMinAssetValue(\n        mph: MintingPolicyHash,\n        tokenName: BytesLike,\n        count: bigint = 1n\n    ) {\n        const v = makeValue(mph, tokenName, count);\n        // uses a dummy address so it can be used even during bootstrap\n        const dummyAddr = makeDummyAddress(false);\n        const txo = makeTxOutput(dummyAddr, v);\n        txo.correctLovelace(this.networkParams);\n        return txo.value;\n    }\n\n    tokenAsValue(\n        tokenName: string | number[] | UutName,\n        count: bigint = 1n\n    ): Value {\n        throw new Error(`only implemented by Capo`);\n    }\n\n    /**\n     * Creates a token predicate suitable for mustFindActorUtxo or mustFindMyUtxo\n     * @remarks\n     * This variant takes just a token-name / quantity, working only on Capo instances,\n     * and seeks a token created by the Capo's minting policy.\n     *\n     * Choose from one of the other variants to make a more specific token predicate.\n     * @public\n     */\n    mkTokenPredicate(\n        tokenName: UutName | number[] | string,\n        quantity?: bigint\n    ): tokenPredicate<any>;\n    /**\n     * Creates a token predicate suitable for mustFindActorUtxo or mustFindMyUtxo\n     * @remarks\n     * This variant uses a Value for filtering - each matched item must have the ENTIRE value.\n     * @public\n     */\n    mkTokenPredicate(val: Value): tokenPredicate<any>;\n    /**\n     * Creates a token predicate suitable for mustFindActorUtxo or mustFindMyUtxo\n     * @remarks\n     * This variant uses an explicit combination of policy/token-name/quantity\n     * @public\n     */\n    mkTokenPredicate(\n        mph: MintingPolicyHash,\n        tokenName: string,\n        quantity?: bigint\n    ): tokenPredicate<any>;\n    /**\n     * Creates a token predicate suitable for mustFindActorUtxo or mustFindMyUtxo\n     * @remarks\n     * This variant uses an AssetClass(policy/token-name) and quantity\n     * @public\n     */\n    mkTokenPredicate(\n        mphAndTokenName: AssetClass,\n        quantity?: bigint\n    ): tokenPredicate<any>;\n    mkTokenPredicate(\n        specifier:\n            | Value\n            | MintingPolicyHash\n            | AssetClass\n            | UutName\n            | number[]\n            | string,\n        quantOrTokenName?: string | bigint,\n        quantity?: bigint\n    ): tokenPredicate<any> {\n        let v: Value;\n        let mph: MintingPolicyHash;\n        let tokenName: string;\n        //!!! todo: support (AssetClass, quantity) input form\n        if (!specifier)\n            throw new Error(\n                `missing required Value or MintingPolicyHash or UutName (or uut-name as byte-array) in arg1`\n            );\n        const predicate = _tokenPredicate.bind(this) as tokenPredicate<any>;\n\n        //@ts-expect-error\n        const isValue = specifier.kind == \"Value\";\n\n        const isTokenNameOnly =\n            \"string\" === typeof specifier ||\n            (Array.isArray(specifier) && \"number\" === typeof specifier[0]);\n        const isUut = specifier instanceof UutName;\n        if (isValue) {\n            const v = specifier as Value;\n            // v = predicate.value = specifier;\n            const t = _tokenPredicate.bind(this, v) as tokenPredicate<any>;\n            t.predicateValue = v;\n            return t;\n        } else if (isUut || isTokenNameOnly) {\n            const tn = specifier as UutName | number[] | string;\n            const quant = quantOrTokenName ? BigInt(quantOrTokenName) : 1n;\n            //@ts-expect-error\n            const mph = this.strella.mph;\n            if (!mph) {\n                throw new Error(\n                    `this helper doesn't have a capo contract to resolve minting policy hash; specify the mph explicitly`\n                );\n            }\n            const tnBytes = isUut\n                ? textToBytes(tn.toString())\n                : Array.isArray(tn)\n                ? tn\n                : textToBytes(tn as string);\n            const tv = makeValue(\n                mph,\n                tnBytes,\n                quant // quantity if any\n            );\n            const t = _tokenPredicate.bind(this, tv) as tokenPredicate<any>;\n            t.predicateValue = tv;\n            return t;\n            //@ts-expect-error\n        } else if (specifier.kind == \"MintingPolicyHash\") {\n            mph = specifier as MintingPolicyHash;\n            if (\"string\" !== typeof quantOrTokenName)\n                throw new Error(\n                    `with minting policy hash, token-name must be a string (or ByteArray support is TODO)`\n                );\n            tokenName = quantOrTokenName;\n            quantity = quantity || 1n;\n\n            // v = predicate.value = this.mkTokenValue(tokenName, quantity, mph);\n            // return predicate;\n            const tv = this.mkAssetValue(mph, tokenName, quantity);\n\n            const t = _tokenPredicate.bind(this, tv) as tokenPredicate<any>;\n            t.predicateValue = tv;\n            return t;\n            //@ts-expect-error\n        } else if (specifier.kind == \"AssetClass\") {\n            const s = specifier as AssetClass;\n            mph = s.mph;\n            if (!quantOrTokenName) quantOrTokenName = 1n;\n            if (\"bigint\" !== typeof quantOrTokenName)\n                throw new Error(\n                    `with AssetClass, the second arg must be a bigint like 3n, or omitted`\n                );\n            quantity = quantOrTokenName;\n\n            // v = predicate.value = new Value(0n, [[specifier, quantity]]);\n            // return predicate;\n            const tv = makeValue(0n, [[mph, [[s.tokenName, quantity]]]]);\n            const t = _tokenPredicate.bind(this, tv) as tokenPredicate<any>;\n            t.predicateValue = tv;\n            return t;\n        } else {\n            throw new Error(\n                `wrong token specifier (need Value, MPH+tokenName, or AssetClass`\n            );\n        }\n\n        function _tokenPredicate<tokenBearer extends canHaveToken>(\n            this: UtxoHelper,\n            v: Value,\n            something: tokenBearer\n        ): tokenBearer | undefined {\n            return this.hasToken(something, v);\n        }\n    }\n\n    /**\n     * adds the values of the given TxInputs\n     */\n    totalValue(utxos: TxInput[]): Value {\n        return utxos.reduce((v: Value, u: TxInput) => {\n            return v.add(u.value);\n        }, makeValue(0n));\n    }\n\n    /**\n     * Creates a Value object representing a token with the given name and quantity\n     * @deprecated - Use `helios' makeValue()` instead.\n     * @remarks\n     * This method doesn't include any lovelace in the Value object.\n     * use mkMinAssetValue() to include the minimum lovelace for storing that token in its own utxo\n     * @param tokenName - the name of the token\n     * @param quantity - the quantity of the token\n     * @param mph - the minting policy hash of the token\n     * @public\n     **/\n    mkTokenValue(\n        tokenName: string | number[],\n        quantity: bigint,\n        mph: MintingPolicyHash\n    ): Value {\n        return makeValue(mph, tokenName, quantity);\n    }\n\n    /**\n     * Creates a Value having enough lovelace to store the indicated token\n     * @deprecated - Use {@link UtxoHelper.mkMinAssetValue | mkMinAssetValue(mph, tokenName, quantity)} instead.\n     * @remarks\n     * This is equivalent to mkTokenValue() with an extra min-utxo calculation\n     * @public\n     **/\n    mkMinTokenValue(\n        tokenName: string | number[],\n        quantity: bigint,\n        mph: MintingPolicyHash\n    ) {\n        return this.mkMinAssetValue(mph, tokenName, quantity);\n    }\n\n    /**\n     * Locates a utxo in the current actor's wallet that matches the provided token predicate\n     * @remarks\n     * With the mode=\"multiple\" option, it returns an array of matches if any are found, or undefined if none are found.\n     * @public\n     */\n    async findActorUtxo<T extends \"single\" | \"multiple\" = \"single\">(\n        name: string,\n        predicate: (u: TxInput) => TxInput | undefined,\n        options: UtxoSearchScope = {},\n        mode: T = \"single\" as T\n    ) {\n        const wallet = options.wallet ?? this.wallet;\n\n        // doesn't go through the wallet's interface - uses the network client instead,\n        // so that txChainBuilder can take into account the UTxO's already being spent in the tx-chain.\n        const addrs = (await wallet?.usedAddresses) ?? [];\n        const utxos: TxInput[] = [];\n        for (const addr of addrs.flat(1)) {\n            if (!addr) continue;\n            const addrUtxos = await this.network.getUtxos(addr);\n            utxos.push(...addrUtxos);\n        }\n\n        return this.hasUtxo(name, predicate, {\n            ...options,\n            wallet,\n            utxos,\n        }, mode);\n    }\n\n    /**\n     * Try finding a utxo matching a predicate\n     * @remarks\n     * Filters the provided list of utxos to find the first one that matches the predicate.\n     *\n     * Skips any utxos that are already being spent in the provided transaction context.\n     * Skips any utxos that are marked as collateral in the wallet.\n     *\n     * With the mode=\"multiple\" option, it returns an array of matches if any are found, or undefined if none are found.\n     * @public\n     **/\n    async hasUtxo<T extends \"single\" | \"multiple\" = \"single\">(\n        semanticName: string,\n        predicate: utxoPredicate,\n        {\n            // address,\n            wallet,\n            exceptInTcx,\n            utxos,\n            required,\n            dumpDetail,\n        }: UtxoSearchScopeWithUtxos,\n        mode: T = \"single\" as T\n    ): Promise<T extends \"single\" ? TxInput | undefined : TxInput[] | undefined> {\n        const collateral = ((wallet\n            ? \"handle\" in wallet\n                ? await (wallet as any).handle.collateral\n                : \"collateral\" in wallet\n                ? wallet.collateral\n                : undefined\n            : undefined) ?? [])[0];\n        // const filterUtxos = [\n        //     ...collateral,\n        //     ...(exceptInTcx?.reservedUtxos() || []),\n        // ];\n        const notCollateral = utxos.filter((u) => !collateral?.isEqual(u));\n\n        const filtered = exceptInTcx\n            ? notCollateral.filter(\n                  exceptInTcx.utxoNotReserved.bind(exceptInTcx)\n              )\n            : notCollateral;\n\n        const foundMultiple = filtered.filter(predicate)\n        const foundOne = foundMultiple[0];\n        \n        const joiner = \"\\n   🔎  \";\n        const detail = // true ||\n            dumpDetail == \"always\" ||\n            globalThis.utxoDump ||\n            (!foundOne && dumpDetail == \"onFail\")\n                ? \"\\n  from set: \" + joiner + utxosAsString(filtered, joiner)\n                : `(${filtered.length} candidates; show with globalThis.utxoDump or \\`dumpDetail\\` option)`;\n        console.log(\n            `  🔎 finding '${semanticName}' utxo${\n                exceptInTcx ? \" (not already being spent in txn)\" : \"\"\n                // } from set:\\n    🔎 ${detail}`\n            } ${detail}`\n            // ...(exceptInTcx && filterUtxos?.length\n            //     ? [\n            //           \"\\n  ... after filtering out:\\n \",\n            //           utxosAsString(exceptInTcx.reservedUtxos(), \"\\n  \"),\n            //       ]\n            //     : [])\n        );\n\n\n        if (foundOne) {\n            const multiInfo = mode == \"multiple\" ? ` ${foundMultiple.length} matches; first: ` : \"\";\n            console.log(\n                \"   🎈found\" + multiInfo +\n                    utxosAsString(\n                        [foundOne],\n                        undefined,\n                        this.setup.uxtoDisplayCache\n                    )\n            );\n        } else {\n            if (exceptInTcx) {\n                const alreadyInTcx = exceptInTcx.inputs.find(predicate);\n                if (alreadyInTcx) {\n                    console.log(\n                        `\\n  um... value ${dumpAny(\n                            predicate.predicateValue\n                        )} not found. \\n` +\n                            `     ${dumpAny(alreadyInTcx)}\\n` +\n                            `  FYI, it seems this ^^ current txn input already has the target value. \\n` +\n                            \"    NOTE: You may want to adjust your dAPI to create an explicit fail-if-already-present semantic\\n\" +\n                            \"    ... or, alternatively, to allow this token to authenticate multiple transaction elements\\n\" +\n                            \"    ... by using explicitly idempotent 'addOrReuse' semantics, with details stored in tcx.state\\n\\n  ... go with care, and ask the community for help if you're unsure\\n  )\" +\n                            (required\n                                ? \"\\nBTW, here is that txn as of this time: \" +\n                                  (await alreadyInTcx.dump()) +\n                                  \"\\n\\n 👁️   👁️ 👁️ ^^^^^^^ More details about the utxo search failure above ^^^^^^^ 👁️ 👁️   👁️\"\n                                : \"\")\n                    );            \n                    return undefined as any;\n                }\n            }\n        }\n        if (mode == \"multiple\") {\n            if (!foundMultiple.length) {\n                return undefined as any;\n            }\n            return foundMultiple as any;\n        }\n\n        return foundOne as any;\n    }\n\n    async mustFindActorUtxo(\n        name: string, options: {\n            predicate: (u: TxInput) => TxInput | undefined,\n            exceptInTcx?: StellarTxnContext<any>,\n            extraErrorHint?: string\n        }\n    ): Promise<TxInput> {\n        const wallet = this.wallet;\n\n        return this.mustFindUtxo(\n            name,\n            {\n                ...options,\n                wallet,\n            },\n        );\n    }\n\n    async mustFindUtxo(\n        semanticName: string, options: UtxoSearchScope & {\n            predicate: utxoPredicate,\n            extraErrorHint?: string\n        }\n    ): Promise<TxInput> {\n        // workaround for a failure in api-extractor to make this a separate assignment??\n        const { predicate, extraErrorHint =\"\", wallet, address, exceptInTcx } = options;\n        // const { address, exceptInTcx } = searchScope;\n\n        const addrs = (await wallet?.usedAddresses) ?? [address];\n        const utxos: TxInput[] = [];\n        for (const addr of addrs.flat(1)) {\n            if (!addr) continue;\n            const addrUtxos = await this.network.getUtxos(addr);\n            utxos.push(...addrUtxos);\n        }\n\n        const found = await this.hasUtxo(semanticName, predicate, {\n            address,\n            wallet,\n            exceptInTcx,\n            utxos,\n            required: true,\n        });\n        if (!found) {\n            const walletAddr = wallet\n                ? //@ts-ignore - sorry typescript, address sometimes is present on a SimpleWallet in test environment\n                  wallet.address || (await wallet.usedAddresses)\n                : undefined;\n            if (!globalThis.utxoDump) {\n                console.log(\n                    // warning emoji: \"⚠️\"\n                    \" ⚠️ find failed in candidate utxos (debugging breakpoint available)\\n\",\n                    semanticName, dumpAny(utxos)\n                );\n            }\n            debugger;\n            // Debuggering?  YOU ARE AWESOME!\n            // need to see more? dig in here:\n            const addrString = address?.toString();\n            const utxos2 = address\n                ? await this.network.getUtxos(address)\n                : await wallet!.utxos;\n            console.log(\n                addrString,\n                wallet,\n                addrs.map((a) => a?.toString())\n            );\n            for (const u of utxos2) {\n                predicate(u);\n            }\n            throw new Error(\n                this.utxoSearchError(\n                    semanticName,\n                    options,\n                    extraErrorHint,\n                    walletAddr\n                )\n            );\n        }\n\n        return found;\n    }\n\n    utxoSearchError(\n        semanticName: string,\n        searchScope: UtxoSearchScope,\n        extraErrorHint?: string,\n        walletAddresses?: Address | Address[]\n    ): string {\n        const where = searchScope.address\n            ? `\\n -- searched in address ${searchScope.address.toString()}`\n            : ``;\n        const wAddrs: Address[] = Array.isArray(walletAddresses)\n            ? walletAddresses\n            : walletAddresses\n            ? [walletAddresses]\n            : [];\n        let more = wAddrs.length\n            ? wAddrs.map((x) => dumpAny(x) + ` = ${x.toString()}`).join(\"\\n\")\n            : \"\";\n        if (wAddrs.length > 1) {\n            more = \"\\n  ... wallet addrs:\\n\";\n        } else {\n            more = wAddrs.length ? `\\n  ... in wallet addr: ${more}` : \"\";\n        }\n        if (extraErrorHint) more += \"\\n\";\n\n        return `${\n            this.constructor.name\n        }: '${semanticName}' utxo not found ${more}  ... ${\n            extraErrorHint || \"sorry, no extra clues available\"\n        }${where}\\n  ... see more details in log`;\n    }\n\n    toUtxoId(u: TxInput) {\n        return `${u.id.txId.toHex()}@${u.id.index}`;\n    }\n}\n","import type { UplcData } from \"@helios-lang/uplc\";\nimport { StellarTxnContext, type hasSeedUtxo } from \"./StellarTxnContext.js\";\nimport type { IFISNEVER, TypeError } from \"./helios/typeUtils.js\";\nimport { makeTxOutputId, type TxId, type TxOutputId, type TxOutputIdLike } from \"@helios-lang/ledger\";\n\n/**\n * @public\n */\nexport type hasSeed = SeedAttrs | hasSeedUtxo | TxOutputIdLike;\n\n/**\n * a type for redeemer/activity-factory functions declared with \\@Activity.redeemer\n *\n * @public\n */\nexport type isActivity = {\n    // redeemer: UplcDataValue | UplcData | T;\n    redeemer: UplcData;\n    details?: string;\n};\n\n/**\n * @public\n */\nexport type SeedAttrs = {\n    txId: TxId;\n    idx: bigint;\n};\n\n/**\n * @public\n */\nexport type seedActivityFunc<\n    ARGS extends [...any] | never,\n    RV extends isActivity | UplcData | TypeError<any>\n> = IFISNEVER<ARGS,\n    (seed: hasSeed) => RV,\n    (seed: hasSeed, ...args: ARGS) => RV\n>\n\ntype seedFunc<\n    F extends ((seed: hasSeed, arg: any) => any ) | ( (seed: hasSeed) => any ),\n    ARG extends (\n        F extends (seed: hasSeed) => any ? never :\n        F extends (seed: hasSeed, arg: infer iArg) => any ? iArg : never\n    ) = \n        F extends (seed: hasSeed) => any ? never :\n        F extends (seed: hasSeed, arg: infer iArg) => any ? iArg : never,\n    RV extends ReturnType<F> = ReturnType<F>\n> = IFISNEVER<ARG, \n    seedActivityFunc<never, RV>,\n    seedActivityFunc<[ARG], RV>\n>\n\n\ntype NeedsSingleArgError =\n    TypeError<\"expected at most one arg for seeded activity func\">;\n\n/**\n * @internal\n */\nexport type SeedActivityArg<\n    SA extends seedFunc<any, any>\n    // ARG extends SA extends seedActivityFunc<[infer ARG, ... infer badArgs], any> ?\n    // [any] extends badArgs ?\n    //     TypeError<\"expected at most one arg for seeded activity func\"> :\n    // ARG : never =\n> = SA extends seedFunc<SA, infer ARG, infer RV> ? ARG : never;\n    // ? [...any] extends badArgs\n    //     ? NeedsSingleArgError\n    //     // : IFISNEVER<ARG, never, ARG>\n    //     : [any] extends [ARG] ? ARG : never\n    // : never;\n// > = ARG;\n\nfunction noArgsFunc(seed: hasSeed) : isActivity{\n    return { redeemer: \"no-args\" as any };\n}\ntype NOARGS_func = typeof noArgsFunc;\ntype noArgsArg = SeedActivityArg<typeof noArgsFunc>\nconst tt : IFISNEVER<SeedActivityArg<typeof noArgsFunc>, true, false> = true;\n\n/**\n * @public\n */\nexport class SeedActivity<\n    FactoryFunc extends seedActivityFunc<any, any>,\n> {\n    arg: SeedActivityArg<FactoryFunc>;\n    constructor(\n        private host: { getSeed(x: hasSeed): TxOutputId },\n        private factoryFunc : FactoryFunc,\n        arg: SeedActivityArg<FactoryFunc>\n    ) {\n        // console.log(\"+ seed activity\" + new Error(\"\").stack);\n        this.arg = arg;\n    }\n\n    mkRedeemer(seedFrom: hasSeed) {\n        // const seed = this.host.getSeed(thing);\n        return this.factoryFunc.call(this.host, seedFrom, this.arg);\n    }\n}\n/**\n * @internal\n */\n//prettier-ignore\nexport type funcWithImpliedSeed<\n    // FACTORY_FUNC extends (...args: [ hasSeed, ... ARGS ]) => any,\n    // ARGS extends [ ... any] =\n    //         FACTORY_FUNC extends (...args: [ hasSeed, ... infer iArgs ]) => any ?\n    //         [ any ] extends iArgs ? never : iArgs : never\n    // > = [ any ] extends ARGS ?\n    // (...args: ARGS) => unknown & SeedActivity<FACTORY_FUNC, ARGS>\n    FACTORY_FUNC extends seedActivityFunc<any, any>,\n    // ARG extends SeedActivityArg<FACTORY_FUNC> = \n    //     SeedActivityArg<FACTORY_FUNC> //extends SeedActivityArg<any, iArg> ? iArg : never,\n\n    // seedActivityFunc<[infer iArg, ... infer oArgs], any> ?\n    // [ any ] extends oArgs ? seedActivityFunc<\n    //     any, TypeError<\"expected at most one arg for seeded activity func\"\n    //     > :\n    // [ any ] extends iArg ? iArg : never : never\n> = IFISNEVER<\n    SeedActivityArg<FACTORY_FUNC>,\n    () => SeedActivity<FACTORY_FUNC>,\n    SeedActivityArg<FACTORY_FUNC> extends NeedsSingleArgError\n        ? never\n        : (fields: SeedActivityArg<FACTORY_FUNC>) => SeedActivity<FACTORY_FUNC>\n>;\n\nconst x: [any] extends [] ? true : false = false;\n\n/**\n * @internal\n */\n//prettier-ignore\nexport function impliedSeedActivityMaker<\n    FACTORY_FUNC extends seedActivityFunc<any, any>,\n    IMPLIED_SEED_FUNC extends funcWithImpliedSeed<FACTORY_FUNC> = \n        funcWithImpliedSeed<FACTORY_FUNC>,\n    ARG extends SeedActivityArg<FACTORY_FUNC> = \n        SeedActivityArg<FACTORY_FUNC>\n    // IMPLIED_SEED_FUNC extends funcWithImpliedSeed<infer iFunc, any> ? iFunc : never,\n    // ISV  extends\n    //     funcWithImpliedSeed<any, infer iArgs> ? iArgs : never\n>(\n    host: { getSeed(x: hasSeed): TxOutputId },\n    factoryFunc: FACTORY_FUNC,\n// ): WithImpliedSeedVariant<FACTORY_FUNC, ARGS> {\n): IMPLIED_SEED_FUNC {\n    const makesActivityWithImplicitSeedAndArgs = ( (arg: ARG) => {\n        const seedActivity = new SeedActivity<FACTORY_FUNC>(host, factoryFunc, arg);\n        return seedActivity;\n    }) as IMPLIED_SEED_FUNC\n    return makesActivityWithImplicitSeedAndArgs\n}\n\n/**\n * extracts a tx output id from a \"has-seed\" type of object, for use in\n * on-chain uniqueness assurances\n * @public\n */\nexport function getSeed(arg: hasSeed | TxOutputId ): TxOutputId {\n    //@ts-expect-error on this type probe\n    if (arg.kind == \"TxOutputId\") return arg;\n\n    if (arg instanceof StellarTxnContext) {\n        const { txId, idx } = arg.getSeedUtxoDetails();\n        return makeTxOutputId(txId, idx);\n    }\n    //@ts-expect-error on this type probe\n    if (arg.idx && arg.txId) {\n        const attr: SeedAttrs = arg as SeedAttrs;\n        return makeTxOutputId(attr.txId, attr.idx);\n    }\n    const txoIdLike = arg as Exclude<typeof arg, SeedAttrs>;\n    return makeTxOutputId(txoIdLike);\n}\n","import type { TypeSchema } from \"@helios-lang/type-utils\";\nimport { type Cast, makeCast } from \"@helios-lang/contract-utils\";\nimport { type TxOutputId } from \"@helios-lang/ledger\";\nimport type { UplcData } from \"@helios-lang/uplc\";\n\nimport type { readsUplcData } from \"../HeliosMetaTypes.js\";\nimport type { EnumBridge } from \"./EnumBridge.js\";\nimport type { readsUplcTo } from \"./BridgeTypes.js\";\nimport { getSeed, type hasSeed, type SeedAttrs } from \"../../ActivityTypes.js\";\n\n// const rawDataMakerProxy = new Proxy(\n//     {},\n//     {\n//         // cases to cover:\n//         // 1. type is an enum, accessor is a tagOnly field\n//         //     -> instantiate the right constrData through the cast(   { variantName:{} )\n//         // 2. type is an enum, accessor is a singletonField\n//         //   2a. nested field is an enum\n//         //      -> returns a proxy for the nested enum type,\n//         //           ... with seed semantics and NO {redeemer: } wrapper\n//         //   2b. nested field not an enum\n//         //     -> returns a function that takes the field value and calls cast ( { variantName: { fieldName: value } } )\n//         // 3. type is an enum, accessor has fields\n//         //    -> returns a function that takes the fields and calls cast ( { variantName: { ...fields } } )\n//         // 4. type is not an enum.\n//         //   -> the apply() trap is called with the arg(s) for filling that data type\n\n//         // if it is an activity, wrap it in a {redeemer: } object\n//         // ... to satisfy the isActivity type\n\n//         get(_, typeName : string | Symbol, THIS : DataBridge) {\n//             // throw new Error(`dataMaker ${DMP.constructor.name}: GET: ${typeName}`)\n//             const {__typeDetails: typeDetails, __schema: schema, __cast: cast} = THIS;\n//             // const {dataType} = typeDetails;\n//             if (\"string\" !== typeof typeName) {\n//                 // if the symbol is a node-inspector symbol, show the type-details\n//                 if (typeName == Symbol.for(\"nodejs.util.inspect.custom\")) {\n//                     debugger\n//                     return undefined // {DataBridgeProxy:{typeDetails}}\n//                 }\n//                 if (typeName == Symbol.for(\"toString\")) {\n//                     return () => `dataMaker ${THIS.constructor.name} for ${THIS.name}`;\n//                 }\n\n//                 // add any special handling for symbols above.\n//                 throw new Error(`dataMaker ${THIS.constructor.name}: GET(${typeName}) -> null`)\n//                 return null\n//             }\n\n//             switch (schema.kind) {\n//                 case \"enum\":\n//                     const enumSchema = schema\n//                     const variant = enumSchema.variantTypes.find(variant => variant.name === typeName);\n//                     // variants[typeName as keyof typeof enumSchema.variants];\n//                     if (variant) {\n//                         if (variant.fieldTypes.length == 0) {\n//                             return cast.toUplcData({[typeName]: {}});\n//                         }\n//                         if (variant.fieldTypes.length === 1) {\n//                             // todo\n//                         }\n//                         // if (variant.accessor === \"singletonField\") {\n//                         //     const nestedType = variant.nestedType;\n//                         //     if (nestedType.kind === \"enum\") {\n//                         //         return new Proxy({}, {\n//                         //             get(_, nestedTypeName: string | Symbol) {\n//                         //                 const nestedVariant = nestedType.variants[nestedTypeName as keyof typeof nestedType.variants];\n//                         //                 if (!nestedVariant) throw new Error(`dataMaker ${THIS.constructor.name}: GET: ${nestedTypeName} not found in ${nestedType.kind}`);\n//                         //                 return (...args: any[]) => cast.toUplcData({[typeName]: { [nestedTypeName]: args[0] }});\n//                         //             }\n//                         //         });\n//                         //     } else {\n//                         //         return (value: any) => cast.toUplcData({[typeName]: { [variant.name]: value }});\n//                         //     }\n//                         // }\n//                         // if (variant.accessor === \"fields\") {\n//                         //     return (...args: any[]) => cast.toUplcData({[typeName]: { ...args }});\n//                         // }\n//                     }\n//                     throw new Error(`dataMaker ${THIS.constructor.name}: GET: ${typeName} not found in ${schema.kind}`);\n//             }\n//             if (THIS.isStruct) {\n//             }\n\n//         },\n//         apply(_,\n//             THIS : DataBridge,\n//             args : any\n//         ) {\n//             debugger\n//             if (args?.length > 1) throw new Error(`dataMaker APPLY: got ${args.length} args, expected 1`)\n//             // throw new Error(`dataMaker ${DMP.constructor.name} APPLY`)\n\n//             // the only case for an apply trap is when the type is not an enum or struct, but is a single value\n//             if (THIS.isEnum) {\n//                 throw new Error(`dataMaker ${THIS.constructor.name} APPLY invalid on enum ${THIS.__typeName}`)\n//             }\n//             if (THIS.isStruct) {\n//                 throw new Error(`dataMaker ${THIS.constructor.name} APPLY invalid on struct ${THIS.__typeName}`)\n//             }\n//             return THIS.toUplc(args[0])\n//         }\n//     }\n// )\n\n/**\n * @internal\n */\nconst rawDataBridgeProxy = new Proxy(\n    {},\n    {\n        apply(_, THIS: DataBridge, [x]: any[]) {\n            // typescript protects against this code-path being allowed by types, but\n            // this serves javascript-based callers and other run-time scenarios where the type-checking\n            // may not be enforced (SWC and vitest, notably)\n            if (!THIS.isCallable)\n                throw new Error(\n                    `dataBridge ${THIS.constructor.name} is not callable`\n                );\n\n            //x@ts-expect-error drilling through the 'protected' attribute - TS can't know about\n            //x  the relationship between this object and the DataBridge class\n            return THIS.ᱺᱺcast.toUplcData(x);\n        },\n    }\n);\n\n/**\n * @internal\n */\nfunction dataBridgeProxyBase() {}\ndataBridgeProxyBase.prototype = rawDataBridgeProxy;\n\n/**\n * @internal\n */\nexport type DataBridgeOptions = {\n    isMainnet: boolean;\n    isActivity?: boolean;\n    isNested?: boolean;\n};\n\n/**\n * @internal\n */\nexport type callWith<ARGS, T extends DataBridge> = T &\n    ((x: ARGS) => ReturnType<T[\"ᱺᱺcast\"][\"toUplcData\"]>);\n\n/**\n * @internal\n */\nexport class DataBridge extends (dataBridgeProxyBase as typeof Object) {\n    protected ᱺᱺschema: TypeSchema;\n    protected isMainnet: boolean;\n    protected isActivity: boolean;\n    protected isNested: boolean;\n    // relaxed protected so that GenericDelegateBridge and specific bridges don't have to\n    //   use an inheritance relationship.  Can add that kind of inheritance and make this protected again.\n    ᱺᱺcast: Cast<any, any>;\n    isCallable = false;\n\n    mkData: this[\"ᱺᱺcast\"][\"toUplcData\"] = (x: any) =>\n        this.ᱺᱺcast.toUplcData(x);\n    readData: this[\"ᱺᱺcast\"][\"fromUplcData\"] = (x: any) =>\n        this.ᱺᱺcast.fromUplcData(x);\n\n    constructor(options: DataBridgeOptions) {\n        super();\n        // these start undefined, but are always forced into existence immediately\n        // via getTypeSchema().  Any exceptions means this protocol wasn't followed\n        // correctly.\n        // uses U+1c7a - sorts to the end\n        this.ᱺᱺschema = undefined as any;\n        this.ᱺᱺcast = undefined as any;\n\n        const { isMainnet, isActivity, isNested } = options;\n        this.isMainnet = isMainnet;\n        this.isActivity = isActivity || false;\n        this.isNested = isNested || false;\n    }\n\n    //\n    // declare activity: DataBridge | ((...args:any) => UplcData)\n\n    // declare  datum: DataBridge | ((...args:any) => UplcData)\n    // // get datum() {\n    // //     throw new Error(`each dataBridge makes its own datum`)\n    // // }\n\n    getSeed(arg: hasSeed | TxOutputId): TxOutputId {\n        return getSeed(arg);\n    }\n\n    protected redirectTo?: (value: any) => void;\n    protected mkDataVia(redirectionCallback: (value: any) => void) {\n        if (!this.isNested) {\n            throw new Error(\n                `dataMaker ${this.constructor.name}: redirectTo is only valid for nested enums`\n            );\n        }\n        this.redirectTo = redirectionCallback;\n    }\n\n    protected get isEnum() {\n        return \"enum\" === this.ᱺᱺschema!.kind;\n    }\n    protected getTypeSchema() {\n        if (!this.ᱺᱺschema) {\n            this.ᱺᱺschema = \"placeholder\" as any; // this.__typeDetails.dataType.toSchema()\n            this.ᱺᱺcast = makeCast(this.ᱺᱺschema, {\n                isMainnet: this.isMainnet,\n                unwrapSingleFieldEnumVariants: true,\n            });\n        }\n        return this.ᱺᱺschema;\n    }\n    // usesRedeemerWrapper : boolean = false\n\n    // toUplc(x: any) {\n    //     return this.ᱺᱺcast.toUplcData(x)\n    // }\n\n    // get __typeName() : string {\n    //     return \"someTypeName\" // this.__typeDetails.dataType.name\n\n    //     // //@ts-expect-error not all schemas have names\n    //     // const {name=\"\"} = this.ᱺᱺschema!\n    //     // if (!name) {\n    //     //     throw new Error(`can't get typeName for unnamed type: ${this.__schema!.kind}`)\n    //     // }\n    //     // return name\n    // }\n}\n\n/**\n * @public\n */\nexport class ContractDataBridge {\n    static isAbstract: true | false = true as const;\n    isAbstract: true | false = true as const;\n    isMainnet: boolean;\n    declare types: Record<string, DataBridge | ((x: any) => UplcData)>;\n    declare reader: DataBridgeReaderClass | undefined;\n    declare datum: DataBridge | undefined;\n    declare activity: DataBridge;\n    declare readDatum: readsUplcData<any> | undefined;\n\n    constructor(isMainnet: boolean) {\n        if (true !== isMainnet && false !== isMainnet)\n            throw new Error(`isMainnet signal must be provided (boolean)`);\n        this.isMainnet = isMainnet;\n    }\n    readData(x: any) {\n        if (!this.datum) throw new Error(`no datum on this dataBridge`);\n\n        return this.datum.readData(x);\n    }\n}\n\n/**\n * @public\n */\nexport class ContractDataBridgeWithEnumDatum extends ContractDataBridge {\n    static isAbstract: true | false = true as const;\n    isAbstract: true | false = true as const;\n    declare datum: EnumBridge;\n    declare readDatum: readsUplcData<unknown>;\n\n    // constructor(isMainnet : boolean) {\n    //     super(isMainnet);\n    // }\n}\n\n/**\n * @public\n */\nexport class ContractDataBridgeWithOtherDatum extends ContractDataBridge {\n    static isAbstract: true | false = true as const;\n    isAbstract: true | false = true as const;\n    // declare datum: (any) => UplcData;\n    // constructor() {\n    //     super();\n    // }\n    declare readDatum: readsUplcData<unknown>;\n}\n// type DataBridgeReader = DataBridgeReaderClass & {\n//     [key: string]: (x : UplcData) => any\n// }\n\n/**\n * @public\n */\nexport class DataBridgeReaderClass {\n    declare datum: readsUplcTo<unknown> | undefined;\n}\n","import {\n    makeAddress,\n    makeTxOutput,\n    makeValidatorHash,\n    type Address,\n    type MintingPolicyHash,\n    type NetworkParams,\n    type TxInput,\n    type ValidatorHash,\n    type Value,\n    makeMintingPolicyHash,\n    makeInlineTxOutputDatum,\n    type TxOutputId,\n} from \"@helios-lang/ledger\";\n\nimport type {\n    CardanoClient,\n    Emulator,\n    TxChainBuilder,\n    Wallet,\n} from \"@helios-lang/tx-utils\";\nimport type { UplcProgramV3, UplcData } from \"@helios-lang/uplc\";\nimport type { DataType, Program, EnumMemberType } from \"@helios-lang/compiler\";\n\nimport {\n    StellarTxnContext,\n    type TxDescription,\n    type hasSeedUtxo,\n} from \"./StellarTxnContext.js\";\nimport { betterJsonSerializer } from \"./diagnostics.js\";\nimport type {\n    anyUplcProgram,\n    InlineDatum,\n    valuesEntry,\n} from \"./HeliosPromotedTypes.js\";\nimport type { Capo } from \"./Capo.js\";\nimport { UtxoHelper, type utxoPredicate } from \"./UtxoHelper.js\";\n// import { CachedHeliosProgram } from \"./helios/CachedHeliosProgram.js\";\n// import { uplcDataSerializer } from \"./delegation/jsonSerializers.js\";\nimport { HeliosScriptBundle } from \"./helios/scriptBundling/HeliosScriptBundle.js\";\nimport { type HeliosBundleClass } from \"./helios/HeliosMetaTypes.js\";\nimport {\n    DataBridge,\n    ContractDataBridge,\n    DataBridgeReaderClass,\n    ContractDataBridgeWithOtherDatum,\n    ContractDataBridgeWithEnumDatum,\n} from \"./helios/dataBridge/DataBridge.js\";\nimport type { possiblyAbstractContractBridgeType } from \"./helios/dataBridge/BridgeTypes.js\";\nimport type { findReadDatumType } from \"./helios/dataBridge/BridgeTypes.js\";\nimport type { mustFindConcreteContractBridgeType } from \"./helios/dataBridge/BridgeTypes.js\";\nimport type { AbstractNew } from \"./helios/typeUtils.js\";\nimport { getSeed, type hasSeed, type SeedAttrs } from \"./ActivityTypes.js\";\nimport { makeCast } from \"@helios-lang/contract-utils\";\nimport type {\n    DeployedProgramBundle,\n    SerializedHeliosCacheEntry,\n} from \"./helios/CachedHeliosProgram.js\";\nimport type { DeployedScriptDetails } from \"./configuration/DeployedScriptConfigs.js\";\nimport type { TxBatcher } from \"./networkClients/TxBatcher.js\";\nimport { bytesToHex } from \"@helios-lang/codec-utils\";\n\ntype NetworkName = \"testnet\" | \"mainnet\";\nlet configuredNetwork: NetworkName | undefined = undefined;\n\n/**\n * @public\n */\nexport function isUplcData(x: any): x is UplcData {\n    return \"kind\" in x && \"toCbor\" in x;\n}\n\n/**\n * @public\n */\ntype WalletsAndAddresses = {\n    wallets: Wallet[];\n    addresses?: Address[];\n};\n/**\n * Type for the Class that constructs to a given type\n * @remarks\n *\n * Type of the matching literal class\n *\n * note: Typescript should make this pattern easier\n *\n * @typeParam S - the type of objects of this class\n * @typeParam CT - inferred type of the constructor args for the class\n * @public\n **/\nexport type stellarSubclass<S extends StellarContract<any>> = (new (\n    setup: SetupInfo\n) => S) & {\n    // & StellarContract<CT>\n    defaultParams: Partial<ConfigFor<S>>;\n    createWith(args: StellarSetupDetails<ConfigFor<S>>): Promise<S>;\n    parseConfig(rawJsonConfig: any): any;\n};\n\n/**\n * Properties for Datum structures for on-chain scripts\n * @public\n **/\nexport type anyDatumProps = Record<string, any>;\n/**\n * Configuration details for StellarContract classes\n * @public\n **/\nexport interface configBaseWithRev {\n    rev: bigint;\n}\n\n/**\n * @public\n */\nexport type UplcRecord<CT extends configBaseWithRev> = {\n    [key in keyof CT]: UplcData;\n};\n\n/**\n * Decorators for on-chain activity (redeemer) factory functions\n * @public\n **/\nexport const Activity = {\n    /**\n     * Decorates a partial-transaction function that spends a contract-locked UTxO using a specific activity (\"redeemer\")\n     * @remarks\n     *\n     * activity-linked transaction-partial functions must follow the txn\\{...\\}\n     * and active-verb (\"ing\") naming conventions.  `txnRetiringDelegation`,\n     * `txnModifyingVote` and `txnWithdrawingStake` would be examples\n     * of function names following this guidance.\n     *\n     * @public\n     **/\n    partialTxn(proto, thingName, descriptor) {\n        needsActiveVerb(thingName);\n        return partialTxn(proto, thingName, descriptor);\n    },\n\n    /**\n     * Decorates a factory-function for creating tagged redeemer data for a specific on-chain activity\n     * @remarks\n     *\n     * The factory function should follow an active-verb convention by including \"ing\" in\n     * the name of the factory function\n     *\n     * Its leading prefix should also match one of 'activity', 'burn', or 'mint'.  These\n     * conventions don't affect the way the activity is verified on-chain, but they\n     * provide guard-rails for naming consistency.\n     * @public\n     **/\n    redeemer(\n        proto,\n        thingName,\n        descriptor\n        // todo: improve this type, so the decorated function is type-checked for returning an isActivity object\n        // : {value: (...args: any[])  => isActivity<any>}\n    ) {\n        const isActivity = thingName.match(/^activity[A-Z]/);\n        const isBurn = thingName.match(/^burn[A-Z]/);\n        const isMint = thingName.match(/^mint[A-Z]/);\n\n        if (!isActivity && !isBurn) {\n            throw new Error(\n                `@Activity.redeemer: ${thingName}: name should start with '(activity|burn|mint)[A-Z]...'`\n            );\n        }\n        needsActiveVerb(thingName, /* show workaround offer */ true);\n        return Activity.redeemerData(proto, thingName, descriptor);\n    },\n    redeemerData(proto, thingName, descriptor) {\n        //!!! todo: registry and cross-checking for missing redeeming methods\n\n        //!!! todo: develop more patterns of \"redeemer uses an input of a certain mph/value\"\n        return descriptor;\n    },\n};\n\nfunction needsActiveVerb(thingName: string, okWorkaround?: boolean) {\n    if (!thingName.match(/ing/)) {\n        const orWorkaround =\n            okWorkaround &&\n            \"(or work around with @Activity.redeemerData instead)\";\n        throw new Error(\n            `Activity: ${thingName}: name should have 'ing' in it ${orWorkaround}`\n        );\n    }\n    if (thingName.match(/^ing/)) {\n        throw new Error(\n            `Activity: ${thingName}: name shouldn't start with 'ing'`\n        );\n    }\n}\n\n/**\n * Decorates datum-building functions\n * @remarks\n *\n * function names must follow the mkDatum... convention.\n *\n * The function should accept a single argument with input type\n * that feels Typescripty, and that can be fit to the on-chain type of\n * the underlying Datum variant of the given name.\n *\n * @public\n **/\nexport function datum(proto, thingName, descriptor) {\n    // console.log(\"+datum\", proto.constructor.name, thingName || \"none\", descriptor.value.name )\n    if (!thingName.match(/^mkDatum/)) {\n        throw new Error(\n            `@datum factory: ${thingName}: name should start with 'mkDatum...'`\n        );\n    }\n    return descriptor;\n}\n\n/**\n * Decorates functions that can construct a new transaction context for a specific use-case\n * @remarks\n *\n * function names must follow the mkTxn... convention.\n * @public\n **/\nexport function txn(proto, thingName, descriptor) {\n    // console.log(\"+datum\", proto.constructor.name, thingName || \"none\", descriptor.value.name )\n    if (!thingName.match(/^mkTxn/)) {\n        throw new Error(\n            `@txn factory: ${thingName}: name should start with 'mkTxn...'`\n        );\n    }\n    return descriptor;\n}\n\n/**\n * decorates functions that increment a transaction by adding needed details for a use-case\n * @remarks\n *\n * Function names must follow the txn\\{...\\} naming convention. Typical partial-transaction names\n * may describe the semantics of how the function augments the transaction.\n * `txnAddSignatures` or `txnReceivePayment` could be example names following\n * this guidance\n *\n * Partial transactions should have a \\<TCX extends StellarTxnContext\\<...\\>\\> type parameter,\n * matched to its first function argument, and should return a type extending that same TCX,\n * possibly with additional StellarTxnContext\\<...\\> type info.\n *\n * The TCX constraint can specify key requirements for an existing transaction context when\n * that's relevant.\n *\n * @public\n **/\nexport function partialTxn(proto, thingName, descriptor) {\n    // console.log(\"+datum\", proto.constructor.name, thingName || \"none\", descriptor.value.name )\n    if (!thingName.match(/^txn[A-Z]/)) {\n        let help = \"\";\n        if (thingName.match(/^mkTxn/)) {\n            help = `\\n  ... or, for transaction initiation with mkTxn, you might try @txn instead. `;\n        }\n        throw new Error(\n            `@partialTxn factory: ${thingName}: should start with 'txn[A-Z]...'${help}`\n        );\n    }\n    return descriptor;\n}\n\n/**\n * @public\n */\nexport async function findInputsInWallets(\n    v: Value,\n    searchIn: WalletsAndAddresses,\n    network: CardanoClient\n): Promise<TxInput<any>> {\n    const { wallets, addresses } = searchIn;\n\n    const lovelaceOnly = v.assets.isZero();\n    console.warn(\"finding inputs\", {\n        lovelaceOnly,\n    });\n\n    for (const w of wallets) {\n        const [a] = await w.usedAddresses;\n        console.log(\"finding funds in wallet\", a.toString().substring(0, 18));\n        const utxos = await w.utxos;\n        for (const u of utxos) {\n            if (lovelaceOnly) {\n                if (u.value.assets.isZero() && u.value.lovelace >= v.lovelace) {\n                    return u as any;\n                }\n                console.log(\"  - too small; skipping \", u.value.dump());\n            } else {\n                if (u.value.isGreaterOrEqual(v)) {\n                    return u as any;\n                }\n            }\n        }\n    }\n    if (lovelaceOnly) {\n        throw new Error(\n            `no ADA is present except those on token bundles.  TODO: findFreeLovelaceWithTokens`\n        );\n        // const spareChange = this.findFreeLovelaceWithTokens(v, w)\n    }\n    //!!! todo: allow getting free ada from a contract address?\n\n    if (addresses) {\n        for (const a of addresses) {\n            const utxos = await network.getUtxos(a);\n            for (const u of utxos) {\n                if (u.value.isGreaterOrEqual(v)) {\n                    return u as any;\n                }\n            }\n        }\n    }\n\n    throw new Error(\n        `None of these wallets${\n            (addresses && \" or addresses\") || \"\"\n        } have the needed tokens`\n    );\n}\n\nexport type HeliosOptimizeOptions = Exclude<Pick<Exclude<\n    Parameters<Program[\"compile\"]>[0], undefined | boolean\n>, \"optimize\"\n>[\"optimize\"], undefined | boolean>\n\nexport type UtxoDisplayCache = Map<TxOutputId, string>;\n/**\n * standard setup for any Stellar Contract class\n * @public\n **/\nexport type SetupInfo = {\n    /** access to ledger: utxos, txn-posting; can sometimes be a TxChainBuilder overlay on the real network */\n    network: CardanoClient | Emulator;\n    /** the actual network client; never a TxChainBuilder */\n    chainBuilder?: TxChainBuilder;\n    /** the params for this network */\n    networkParams: NetworkParams;\n    /** collects a batch of transactions, connected with a TxChainBuilder in context */\n    txBatcher: TxBatcher;\n    /** false for any testnet.  todo: how to express L2? */\n    isMainnet: boolean;\n    /** wallet-wrapping envelope, allows wallet-changing without reinitializing anything using that envelope */\n    actorContext: ActorContext;\n    /** testing environment? */\n    isTest?: boolean;\n    /** helper for finding utxos and related utility functions */\n    uh?: UtxoHelper;\n    /** global setting for script-compile optimization, only used when a compilation is triggered, can be overridden per script-bundle  */\n    optimize?: boolean | HeliosOptimizeOptions;\n    /** presentation-cache indicates utxos whose details have already been emitted to the console */\n    uxtoDisplayCache?: UtxoDisplayCache;\n};\n\n/**\n * @public\n * Extracts the config type for a Stellar Contract class\n **/\nexport type ConfigFor<SC extends StellarContract<any>> = configBaseWithRev &\n    SC extends StellarContract<infer inferredConfig>\n    ? inferredConfig\n    : never;\n\n/**\n * Initializes a stellar contract class\n * @remarks\n *\n * Includes network and other standard setup details, and any configuration needed\n * for the specific class.\n * @public\n **/\nexport type StellarSetupDetails<CT extends configBaseWithRev> = {\n    setup: SetupInfo;\n    config?: CT;\n    partialConfig?: Partial<CT>;\n    programBundle?: DeployedProgramBundle;\n    previousOnchainScript?: {\n        validatorHash: number[];\n        uplcProgram: anyUplcProgram;\n    };\n};\n\nexport type SetupOrMainnetSignalForBundle = Partial<\n    Omit<SetupInfo, \"isMainnet\">\n> &\n    Required<Pick<SetupInfo, \"isMainnet\">> & { isPlaceholder?: any };\n\nexport type StellarBundleSetupDetails<CT extends configBaseWithRev> = {\n    setup: SetupOrMainnetSignalForBundle;\n    previousOnchainScript?: {\n        validatorHash: number[];\n        uplcProgram: anyUplcProgram;\n    };\n    params?: CT;\n    /**\n     * used only for Capo bundles, to initialize them based on\n     * their `.hlDeploy.<network>.json` config file\n     */\n    deployedDetails?: DeployedScriptDetails<CT>;\n    // partialConfig?: Partial<UplcRecord<CT>>;\n    variant?: string;\n};\n\ntype scriptPurpose =\n    | \"testing\"\n    | \"minting\"\n    | \"spending\"\n    | \"staking\"\n    | \"module\"\n    | \"endpoint\"\n    | \"non-script\";\n\ntype ComputedScriptProperties = Partial<{\n    vh: ValidatorHash;\n    addr: Address;\n    mph: MintingPolicyHash;\n    program: Program;\n    identity: string;\n}>;\n\n/**\n * @public\n */\nexport type ActorContext<WTP extends Wallet = Wallet> = {\n    wallet?: WTP;\n};\n/**\n * @public\n */\nexport type NetworkContext<NWT extends CardanoClient = CardanoClient> = {\n    network: NWT;\n};\n\n/**\n * Basic wrapper and off-chain facade for interacting with a single Plutus contract script\n * @remarks\n *\n * This class is normally used only for individual components of a higher-level {@link Capo | Capo or Leader contract},\n * which act as delegates within its application context.  Nonetheless, it is the base class for every Capo as well as\n * simpler contract scripts.\n *\n * The StellarContract class serves as an off-chain facade for transaction-building and interfacing to any on-chain\n * contract script.  Each StellarContract subclass must define a `contractSource()`, which is currently a Helios-language\n * script, compiled in any Javascript environment to an on-chain executable UPLC or \"plutus core\" form.  This enables\n * a static dApp to be self-sovereign, without need for any server (\"application back-end\") environment.\n *\n * @typeParam ConfigType - schema for the configuration needed for creating or reproducing a\n * specific instance of the contract script on-chain.\n *\n * @public\n **/\nexport class StellarContract<\n    // SUB extends StellarContract<any, ParamsType>,\n    ConfigType extends configBaseWithRev\n> {\n    //! it has scriptProgram: a parameterized instance of the contract\n    //  ... with specific `parameters` assigned.\n    // bundle?: HeliosScriptBundle;\n    configIn?: ConfigType;\n    partialConfig?: Partial<ConfigType>;\n    // contractParams?: UplcRecord<ConfigType>;\n    setup: SetupInfo;\n    get network(): CardanoClient | Emulator | TxChainBuilder {\n        return this.setup.chainBuilder || this.setup.network;\n    }\n\n    networkParams: NetworkParams;\n    actorContext: ActorContext<any>;\n    // isTest?: boolean\n    static get defaultParams() {\n        return {};\n    }\n    static parseConfig(rawJsonConfig: any) {\n        throw new Error(\n            `Stellar contract subclasses should define their own static parseConfig where needed to enable connection from a specific dApp to a specific Stellar Contract.`\n        );\n    }\n\n    /** each StellarContracts subclass needs to provide a scriptBundle class.\n     * @remarks\n     * Your script bundle MUST be defined in a separate file using a convention of\n     * `‹scriptName›.hlb.ts`, and exported as a default class.  It should inherit\n     * from HeliosScriptBundle or one of its subclasses.  Stellar Contracts processes\n     * this file, analyzes the on-chain types defined in your Helios sources, and generates\n     * Typescript types and a data-bridging class for your script.\n     *\n     * Once the data-bridge class is generated, you should import it into your contract\n     * module and assign it to your `dataBridgeClass` attribute.\n     */\n    scriptBundle(): HeliosScriptBundle {\n        debugger; // eslint-disable-line no-debugger - keep for downstream troubleshooting\n        throw new Error(\n            `${this.constructor.name}: missing required implementation of scriptBundle()\\n` +\n                `...each Stellar Contract must provide a scriptBundle() method. \\n` +\n                `It should return an instance of a class defined in a *.hlb.ts file.  At minimum:\\n\\n` +\n                `    export default class MyScriptBundle extends HeliosScriptBundle { ... }\\n` +\n                ` or export default CapoDelegateBundle.usingCapoBundleClass(SomeCapoBundleClass) { ... }\\n\\n` +\n                `We'll generate TS types and other utilities for connecting to the data-types in your Helios sources.\\n` +\n                `Your scriptBundle() method can return \\`MyScriptBundle.create();\\``\n        );\n    }\n\n    /**\n     * the dataBridgeClass attribute MUST be defined for any bundle having a datum type\n     *  - this is the bridge class for converting from off-chain data types to on-chain data\n     *  - it provides convenient, type-safe interfaces for doing that\n     *\n     * @remarks\n     * Minters don't have datum, so they don't need to define this attribute.  However,\n     * note that ***mint delegates*** do in fact have datum types. If you are defining\n     * a custom delegate of that kind, you will need to define this attribute.\n     */\n    dataBridgeClass: AbstractNew<ContractDataBridge> | undefined = undefined;\n\n    /**\n     * The `onchain` object provides access to all bridging capabilities for this contract script.\n     * @remarks\n     * Its nested attributes include:\n     *  - `types` - a collection of all the on-chain types defined in the script, with data-creation helpers for each\n     *  - `activity` - a creation helper for the activities/redeemers defined in the script\n     *\n     * Scripts that use datum types (not including minters) will also have:\n     *  - `datum` - a data-creation helper for the datum type of the script\n     *  - `readDatum` - a data-reading helper for the datum type of the script\n     *\n     * ### Low-level type access\n     * For low-level access (it's likely you don't need to use this) for on-chain types, the `reader` attribute (aka `offchain`) exists: .\n     *  - `reader` - a collection of data-reading helpers for the on-chain types, given UPLC data known to be of that type\n     * @public\n     */\n    get onchain(): possiblyAbstractContractBridgeType<this> {\n        return this.getOnchainBridge();\n    }\n\n    /**\n     * The `offchain` object provides access to readers for the on-chain types of this contract script.\n     * @remarks\n     * Its nested attributes include all the on-chain types defined in the script, with data-reading helpers for each.\n     * This is useful for reading on-chain data in off-chain code.\n     *\n     * ### Warning: low-level typed-data access!\n     *\n     * Note that these readers will work properly with UPLC data known to be of the correct type.  If you\n     * encounter errors related to these results, it's likely you are using the wrong reader for the data you\n     * have in hand.\n     *\n     * For the typical use-case of reading the datum type from a UTxO held in the contract, this is not a problem,\n     * and note that the `readDatum` helper provides a shortcut for this most-common use-case.\n     *\n     * If you're not sure what you're doing, it's likely that this is not the right tool for your job.\n     * @public\n     */\n    get offchain(): possiblyAbstractContractBridgeType<this>[\"reader\"] {\n        // ensures the dataBridge is initialized by accessing the 'onchain' getter\n        // accesses its data-reader.\n        return this.getOnchainBridge().reader;\n    }\n\n    get reader(): possiblyAbstractContractBridgeType<this>[\"reader\"] {\n        // ensures the dataBridge is initialized by accessing the 'onchain' getter\n        // accesses its data-reader.\n        return this.getOnchainBridge().reader;\n    }\n\n    get activity(): any {\n        const bridge = this.onchain;\n        return bridge.activity as any;\n    }\n\n    /**\n     * Converts UPLC from an on-chain datum object to a typed off-chain datum object.\n     *\n     * Given a **utxo with a datum of the contract's datum type**, this method will convert the UPLC datum\n     * to a typed off-chain datum object.\n     *\n     * ### Standard WARNING\n     *\n     * If the datum's structure is not of the expected type, this method MAY throw an error, or it might\n     * return data that can cause problems somewhere else in your code.  That won't happen if you're\n     * following the guidance above.\n     */\n    get newReadDatum(): findReadDatumType<this> {\n        const bridge = this.getOnchainBridge();\n        //x@ts-expect-error probing for presence\n        const { readDatum } = bridge;\n        if (!readDatum) {\n            throw new Error(\n                `${\n                    (this as any).constructor.name\n                }: this contract script doesn't use datum`\n            );\n        }\n\n        return readDatum;\n    }\n\n    _bundle: HeliosScriptBundle | undefined;\n    getBundle(): HeliosScriptBundle {\n        if (!this._bundle) {\n            this._bundle = this.scriptBundle();\n            if (\n                this._bundle.preCompiled &&\n                !this._bundle.preCompiled.singleton\n            ) {\n            }\n            if (!this._bundle._didInit) {\n                console.warn(\n                    `NOTE: the scriptBundle() method in ${this.constructor.name} isn't\\n` +\n                        `initialized properly; it should use \\`${this._bundle.constructor.name}.create({...})\\`\\n` +\n                        `... instead of \\`new ${this._bundle.constructor.name}({...})\\` `\n                );\n            }\n            // this._bundle.checkDevReload()\n        }\n\n        return this._bundle;\n    }\n\n    /**\n     * Provides access to the script's activities with type-safe structures needed by the validator script.\n     *\n     * @remarks - the **redeemer** data (needed by the contract script) is defined as one or\n     * more activity-types (e.g. in a struct, or an enum as indicated in the type of the last argument to\n     * the validator function).\n     *   - See below for more about ***setup & type-generation*** if your editor doesn't  provide auto-complete for\n     *    the activities.\n     *\n     * ### A terminology note: Activities and Redeemers\n     *\n     * Although the conventional terminology of \"redeemer\" is universally well-known\n     * in the Cardano developer community, we find that defining one or more **activities**,\n     * with their associated ***redeemer data***, provides an effective semantic model offering\n     * better clarity and intution.\n     *\n     * Each type of contract activity corresponds to an enum variant in the contract script.\n     * For each of those variants, its redeemer data contextualizes the behavior of the requested\n     * transaction.  A non-enum redeemer-type implies that there is only one type of activity.\n     *\n     * Any data not present in the transaction inputs or outputs, but needed for\n     * specificity of the requested activity, can only be provided through these activity details.\n     * If that material is like a \"claim ticket\", it would match the \"redeemer\" type of labeling.\n     *\n     * Activity data can include any kinds of details needed by the validator: settings for what it\n     * is doing, options for how it is being done, or what remaining information the validator may\n     * need, to verify the task is being completed according to protocol.  Transactions containing\n     * a variety of inputs and output, each potential candidates for an activity, can use the activity\n     * details to resolve ambiguity so the validator easily acts on the correct items.\n     *\n     * ### Setup and Type generation\n     * #### Step 1: create your script **`.hlb.ts`**\n     * With a defined script bundle, `import YourScriptNameBundle from \"./YourBundleName.hlb.js\"`\n     * to your StellarContracts class module, and define a `scriptBundle() { return new YourScriptNameBundle() }` or\n     * similar method in that class.\n     *\n     * This results in a generated **`.typeInfo.ts`** and **`.bridge.ts`** with complete\n     * typescript bindings for your on-chain script (trouble? check Plugin setup below).\n     *\n     * #### Step 2: Import the generated bridge class\n     * Using the generated .bridge file:\n     * > `import YourScriptNameDataBridge from \"./YourBundleName.bridge.js\"`\n     *\n     * ... and set the `dataBridgeClass` property in your class:\n     *\n     * >    `dataBridgeClass = YourScriptNameDataBridge`\n     *\n     * ### Plugin Setup\n     *\n     * The activity types should be available through type-safe auto-complete in your editor.  If not,\n     * you may need to install and configure the Stellar Contracts rollup plugins for importing .hl\n     * files and generating .d.ts for your .hlb.ts files.  See the Stellar Contracts development\n     * guide for additional details.\n     *\n     */\n    // get activity(): findActivityType<this> {\n    //     const bridge = this.onchain;\n    //     // each specific bridge has to have an activity type, but this code can't\n    //     // introspect that type.  It could be a getter OR a method, and Typescript can only\n    //     // be told it is one, or the other, concretely.\n    //     // findActivityType() does probe for the specific type for specific contracts,\n    //     // at the **interface** level, but this code has no visibility of that.\n\n    //     //x@ts-expect-error accessing it in this way\n    //     const { activity } = bridge\n\n    //     return activity as any\n    // }\n\n    // /**\n    //  * Redirect for intuitive developers having a 'redeemer' habit\n    //  *\n    //  * @deprecated - We recommend using `activity` instead of `redeemer`\n    //  */\n    // get redeemer(): findActivityType<this> {\n    //     return this.activity;\n    // }\n\n    /**\n     * Provides access to the script's defined on-chain types, using a fluent\n     * API for type-safe generation of data conforming to on-chain data formats & types.\n     * @remarks\n     *\n     */\n    _dataBridge?: ContractDataBridge;\n    // get mkDatum() : findDatumType<this> {\n    //     //x@ts-expect-error probing for presence\n    //     if (!this.onchain?.datum) throw new Error(`${this.constructor.name}: no datum is used on this type of script`);\n\n    //     //@ts-expect-error probing for presence\n    //     return this.onchain.datum;\n    // }\n\n    getOnchainBridge(): possiblyAbstractContractBridgeType<this> {\n        if (\"undefined\" == typeof this._dataBridge) {\n            const { dataBridgeClass } = this;\n            if (!dataBridgeClass) {\n                if (this.usesContractScript) {\n                    throw new Error(\n                        `${\n                            this._bundle?.moduleName || this.constructor.name\n                        }: each contract script needs a dataBridgeClass = dataBridge‹YourScriptName›\\n` +\n                            `  ... this dataBridge class is generated by heliosRollupBundler \\n` +\n                            `  ... and imported (\\`import dataBridge‹something› from \"./‹yourScriptName›.bridge.js\"\\`)\\n` +\n                            `      This critical class converts between off-chain and on-chain typed data\\n\\n` +\n                            `Note: if you haven't customized the mint AND spend delegates for your Capo, \\n` +\n                            `  ... you might want to define both of those roles using a single \\n` +\n                            `  ... subclass of the BasicMintDelegate. That fixes the most common \\n` +\n                            `  ... first-time setup problems of this kind.`\n                    );\n                } else {\n                    console.log(\n                        `${this.constructor.name} dataBridgeClass = NONE`\n                    );\n                    this._dataBridge = undefined;\n                    //@ts-expect-error setting to degenerate type\n                    return null;\n                }\n            }\n\n            const datumType = this.getBundle().locateDatumType();\n            const isMainnet = this.setup.isMainnet;\n            let newBridge: any;\n            try {\n                newBridge = new (dataBridgeClass as any)(\n                    isMainnet ?? false\n                ) as any;\n            } catch (e) {\n                console.error(e);\n                debugger;\n            }\n            if (datumType) {\n                // verifies that the dataBridge ALSO has a datum-type\n                console.log(\n                    `${this.constructor.name} dataBridgeClass = `,\n                    dataBridgeClass.name\n                );\n                if (!newBridge.datum) {\n                    console.warn(\n                        `${this.constructor.name}: dataBridgeClass must define a datum accessor.  This is likely a code-generation problem.`\n                    );\n                }\n            }\n            // verifies that every dataBridge has an activity-type\n            if (!newBridge.activity) {\n                console.warn(\n                    `${this.constructor.name}: dataBridgeClass must define an activity accessor.  This is likely a code-generation problem.`\n                );\n            }\n            if (\"undefined\" == typeof isMainnet) {\n                return newBridge;\n            }\n\n            return (this._dataBridge = newBridge);\n        }\n\n        if (!this._dataBridge) {\n            throw new Error(\n                `${this.constructor.name}: this contract script doesn't have a dataBridgeClass defined`\n            );\n        }\n        //@ts-expect-error - the type we show externally is fine, given the above logic.\n        // It's not worth hoop-jumping to make TS perfectly happy with how the sausage is made.\n        return this._dataBridge;\n    }\n\n    ADA(n: bigint | number): bigint {\n        const bn =\n            \"number\" == typeof n\n                ? BigInt(Math.round(1_000_000 * n))\n                : ((BigInt(1_000_000) * n) as bigint);\n        return bn;\n    }\n\n    get isConfigured(): boolean {\n        return !!this.configIn;\n    }\n\n    get isConnected() {\n        return this.isConfigured && !!this.wallet;\n    }\n\n    /**\n     * returns the wallet connection used by the current actor\n     * @remarks\n     *\n     * Throws an error if the strella contract facade has not been initialized with a wallet in settings.actorContext\n     * @public\n     **/\n    get wallet() {\n        if (!this.actorContext.wallet) throw new Error(this.missingActorError);\n        return this.actorContext.wallet;\n    }\n\n    get missingActorError(): string {\n        return `Wallet not connected to Stellar Contract '${this.constructor.name}'`;\n    }\n\n    /**\n     * Transforms input configuration to contract script params\n     * @remarks\n     * May filter out any keys from the ConfigType that are not in the contract\n     * script's params.  Should add any keys that may be needed by the script and\n     * not included in the ConfigType (as delegate scripts do with `delegateName`).\n     */\n    getContractScriptParams(\n        config: ConfigType\n    ): Partial<ConfigType> & Required<Pick<ConfigType, \"rev\">> {\n        return config;\n    }\n\n    delegateReqdAddress(): false | Address {\n        return this.address;\n    }\n    delegateAddrHint(): Address[] | undefined {\n        return undefined;\n    }\n\n    walletNetworkCheck?: Promise<NetworkName> | NetworkName;\n    /**\n     * Factory function for a configured instance of the contract\n     * @remarks\n     *\n     * Due to boring details of initialization order, this factory function is needed\n     * for creating a new instance of the contract.\n     * @param args - setup and configuration details\n     * @public\n     **/\n    static async createWith<\n        thisType extends StellarContract<configType>,\n        configType extends configBaseWithRev = thisType extends StellarContract<\n            infer iCT\n        >\n            ? iCT\n            : never\n    >(\n        this: stellarSubclass<any>,\n        args: StellarSetupDetails<configType>\n    ): Promise<StellarContract<configType> & InstanceType<typeof this>> {\n        const Class = this;\n        const {\n            setup,\n            config,\n            partialConfig,\n            previousOnchainScript: program,\n        } = args;\n        const c: StellarContract<configType> = new Class(setup);\n\n        // now all internal property assignments have been triggered,\n        //  (e.g. class-level currentRev = .... declarations)\n        // so we can do initialization activities post-construction\n        return c.init(args);\n    }\n    /**\n     * obsolete public constructor.  Use the createWith() factory function instead.\n     *\n     * @public\n     **/\n    constructor(setup: SetupInfo) {\n        this.setup = setup;\n        this._utxoHelper = new UtxoHelper(this.setup, this);\n        setup.uh = this._utxoHelper;\n\n        // console.log(new Error(`\\n  in ${this.constructor.name}`).stack!.split(\"\\n\").slice(1).join(\"\\n\"));\n\n        const { networkParams, isTest, isMainnet, actorContext } = setup;\n        this.actorContext = actorContext;\n        // helios.config.set({ IS_TESTNET: !isMainnet }); use for TxBuilderConfig from this.setup.isMainnet\n        this.networkParams = networkParams;\n        // this.isTest = isTest\n    }\n\n    get canPartialConfig() {\n        return false;\n    }\n    /**\n     * performs async initialization, enabling an async factory pattern\n     * @remarks\n     * This method is called by the createWith() factory function, and should not be called directly.\n     *\n     *\n     */\n    async init(args: StellarSetupDetails<ConfigType>) {\n        const { isMainnet, actorContext } = this.setup;\n        const chosenNetwork = isMainnet ? \"mainnet\" : \"testnet\";\n\n        if (\"undefined\" !== typeof configuredNetwork) {\n            if (configuredNetwork != chosenNetwork) {\n                console.warn(\n                    `Possible CONFLICT:  previously configured as ${configuredNetwork}, while this setup indicates ${chosenNetwork}` +\n                        `\\n   ... are you or the user switching between networks?`\n                );\n            }\n        }\n        configuredNetwork = chosenNetwork;\n        if (actorContext.wallet) {\n            const walletIsMainnet = await actorContext.wallet.isMainnet();\n            const foundNetwork = walletIsMainnet ? \"mainnet\" :\"a testnet (preprod/preview)\";\n            const chosenNetworkLabel = isMainnet ? \"mainnet\" : \"a testnet (preprod/preview)\";\n            if (walletIsMainnet !== isMainnet) {\n                const message = `The wallet is connected to ${foundNetwork}, doesn't match this app's target network  ${chosenNetworkLabel}`;\n                if (chosenNetwork == \"mainnet\") {\n                    console.log(`${message}\\n   ... have you provided env.TESTNET to the build to target a testnet?`)\n                }\n                throw new Error( message );\n            }\n            // redundant\n            this.actorContext = actorContext;\n        }\n\n        // the config comes from...\n        //  - a Stellar SaaSaaS configuration handle\n        //      - has a SaaS application id\n        //      - maps domain name to a specific SaaS instance for that SaaS app\n        //      - resolves to a Capo Configuration structure\n        //  - a Capo Configuration structure created in Stellar SaaS, with...\n        //      - Capo minter's seed-txn/mph/rev\n        //          - seed txn == a utxo in Stellar SaaS contract\n        //          - in this case, there is also args.programBundle, provided by\n        //            the Capo's init(), via its connectMintingScript().\n        //      - Capo's mph/rev & script hash\n        //      - each delegate's {rev, delegateName, isMint/Spend/DataPolicy} details\n        //          - a script hash for the delegate's script, can be cross-checked with the on-chain version\n        //          - possibly an \"upgrade from ... \" {rev} for strong signals of need to update\n        //      - materialized in code bundle and/or dApp's localStorage/indexedDB\n        //          - with CBOR scripts ready to use\n        //  - (temporary) a similar configuration structure included with the dApp, where supported\n        //  - (temporary) a null configuration for testnet deployment\n        //      - the dApp will generate a config structure to be deployed\n        //      - ... using a seed txn selected from the creator's wallet (for a Capo Minter in testnet)\n        //  - low-level bootstrap details for emulator & automated-testing\n        //      - using a seed txn from emulated environment's wallet\n        //      - the minter MPH (for a Capo)\n        //      - derived details for delegates\n\n        const {\n            config,\n            partialConfig,\n            programBundle,\n            previousOnchainScript,\n            previousOnchainScript: { validatorHash, uplcProgram } = {},\n        } = args;\n        this.partialConfig = partialConfig;\n        this.configIn = config;\n\n        if (uplcProgram) {\n            // with a rawProgram, the contract script is used directly\n            // to make a HeliosScriptBundle with that rawProgram\n            // as an override.\n            this._bundle = this.scriptBundle().withSetupDetails({\n                setup: this.setup,\n                previousOnchainScript: previousOnchainScript,\n                // params: this.getContractScriptParams(config),\n                // deployedDetails: {\n                //     config,\n                // },\n            });\n        } else if (config || partialConfig) {\n            //@ts-expect-error on probe for possible but not\n            //   required variant config\n            const variant = (config || partialConfig).variant;\n\n            // const params = this.getContractScriptParams(config);\n            if (this.usesContractScript) {\n                const genericBundle = this.scriptBundle();\n                if (!config) {\n                    debugger\n                    console.warn(`${this.constructor.name}: no config provided`)\n                }\n                const params =\n                    genericBundle.scriptParamsSource != \"bundle\"\n                        ? config ? { params: this.getContractScriptParams(config) }\n                        : {} : {};\n                const deployedDetails = {\n                    config,\n                    programBundle,\n                    // scriptHash,\n                };\n                if (!programBundle) {\n                    console.log(\n                        `  -- 🐞🐞🐞 🐞 ${this.constructor.name}: no programBundle; will use JIT compilation`\n                    );\n                }\n                this._bundle = genericBundle.withSetupDetails({\n                    ...params,\n                    setup: this.setup,\n                    deployedDetails,\n                    variant,\n                });\n                // await this.prepareBundleWithScriptParams(params);\n                \n            } else if (partialConfig) {\n                // if (this.canPartialConfig) {\n                throw new Error(\n                    `${this.constructor.name}: any use case for partial-config?`\n                );\n                this.partialConfig = partialConfig;\n                // this._bundle = this.scriptBundle();\n            }\n            if (this.usesContractScript) {\n                const bundle = this.getBundle();\n                if (!bundle) {\n                    throw new Error(\n                        `${this.constructor.name}: missing required this.bundle for contract class`\n                    );\n                } else if (!bundle.isHeliosScriptBundle()) {\n                    throw new Error(\n                        `${this.constructor.name}: this.bundle must be a HeliosScriptBundle; got ${bundle.constructor.name}`\n                    );\n                }\n                if (bundle.setup && bundle.configuredParams) {\n                    try {\n                        // eager compile for early feedback on errors\n                        this._compiledScript = await bundle.compiledScript(\n                            true\n                        );\n                    } catch (e: any) {\n                        console.warn(\n                            \"while setting compiledScript: \",\n                            e.message\n                        );\n                    }\n                } else if (bundle.setup && bundle.params) {\n                    debugger;\n                    throw new Error(`what is this situation here? (dbpa)`);\n                }\n                console.log(this.program.name, \"bundle loaded\");\n            }\n        } else {\n            const bundle = this.getBundle();\n            if (bundle.isPrecompiled) {\n                console.log(\n                    `${bundle.displayName}: will use precompiled script on-demand`\n                );\n                // this.compiledScript = await bundle.compiledScript();\n            } else if (bundle.scriptParamsSource == \"config\") {\n                console.log(\n                    `${this.constructor.name}: not preconfigured; will use JIT compilation`\n                );\n            } else if (bundle.scriptParamsSource == \"bundle\") {\n                throw new Error(\n                    `missing required on-chain script params in bundle`\n                );\n            }\n            this.partialConfig = partialConfig;\n        }\n\n        return this;\n    }\n\n    _compiledScript!: anyUplcProgram; // initialized in compileWithScriptParams()\n    get compiledScript(): anyUplcProgram {\n        if (!this._compiledScript) {\n            throw new Error(\n                `${this.constructor.name}: compiledScript not yet initialized; call asyncCompiledScript() first`\n            );\n        }\n        return this._compiledScript;\n    }\n\n    async asyncCompiledScript() {\n        const s = await this.getBundle().compiledScript(true);\n        this._compiledScript = s;\n        return s;\n    }\n    usesContractScript: boolean = true;\n\n    get datumType(): DataType {\n        return this.onChainDatumType;\n    }\n\n    /**\n     * @internal\n     **/\n    get purpose(): scriptPurpose {\n        const purpose = this.program.purpose as scriptPurpose;\n        if (!purpose) return \"non-script\";\n        return purpose;\n    }\n\n    get validatorHash() {\n        const { vh } = this._cache;\n        if (vh) return vh;\n        // console.log(this.constructor.name, \"cached vh\", vh?.hex || \"none\");\n\n        // debugger\n        const nvh = this.compiledScript.hash();\n        // console.log(\"nvh\", nvh.hex);\n        // if (vh) {\n        //     if (!vh.eq(nvh)) {\n        //         console.warn(`validatorHash mismatch: ${vh.hex} != ${nvh.hex}`);\n        //         debugger\n        //     }\n        // }\n        return (this._cache.vh = makeValidatorHash(nvh));\n    }\n\n    //  todo: stakingAddress?: Address or credential or whatever;\n\n    get address(): Address {\n        const prevVh = this._bundle?.previousOnchainScript?.validatorHash\n        if (prevVh) {\n            return makeAddress(this.setup.isMainnet, makeValidatorHash(prevVh))\n        }\n        const { addr } = this._cache;\n        if (addr) return addr;\n        if (!this.validatorHash) {\n            throw new Error(\n                \"This contract isn't yet configured with a validatorHash\"\n            );\n        }\n        console.log(this.constructor.name, \"caching addr\");\n        console.log(\n            \"TODO TODO TODO - ensure each contract can indicate the right stake part of its address\"\n        );\n        console.log(\"and that the onchain part also supports it\");\n        const isMainnet = this.setup.isMainnet;\n        if (\"undefined\" == typeof isMainnet) {\n            throw new Error(\n                `${this.constructor.name}: isMainnet must be defined in the setup`\n            );\n        }\n        const nAddr = makeAddress(isMainnet, this.validatorHash);\n        // this.validatorHash);\n        // console.log(\"nAddr\", nAddr.toBech32());\n        // if (this._address) {\n        //     if (!this._address.eq(nAddr)) {\n        //         console.warn(`address mismatch: ${this._address.toBech32()} != ${nAddr.toBech32()}`);\n        //         debugger\n        //     }\n        // }\n        return (this._cache.addr = nAddr);\n    }\n\n    get mintingPolicyHash() {\n        if (\"minting\" != this.purpose) return undefined;\n        const { mph } = this._cache;\n        if (mph) return mph;\n        // console.log(this.constructor.name, \"_mph\", this._mph?.hex || \"none\");\n        const nMph = makeMintingPolicyHash(this.compiledScript.hash());\n        // console.log(\"nMph\", nMph.hex);\n        // if (this._mph) {\n        //     if (!this._mph.eq(nMph)) {\n        //         console.warn(\n        //             `mintingPolicyHash mismatch: ${this._mph.hex} != ${nMph.hex}`\n        //         );\n        //         debugger\n        //     }\n        // }\n        return (this._cache.mph = nMph);\n    }\n\n    get identity() {\n        const { identity } = this._cache;\n        if (identity) return identity;\n        console.log(this.constructor.name, \"identity\", identity || \"none\");\n\n        let result: string;\n        if (\"minting\" == this.purpose) {\n            const b32 = this.mintingPolicyHash!.toString();\n            //!!! todo: verify bech32 checksum isn't messed up by this:\n            result = b32.replace(/^asset/, \"mph\");\n        } else {\n            result = this.address.toString();\n        }\n        // if (this._identity) {\n        //     if (this._identity != result) {\n        //         console.warn(\n        //             `identity mismatch: ${this._identity} != ${result}`\n        //         );\n        //         debugger\n        //     }\n        // }\n        // console.log(\"nIdentity\", result);\n        return (this._cache.identity = result);\n    }\n\n    //! searches the network for utxos stored in the contract,\n    //  returning those whose datum hash is the same as the input datum\n    async outputsSentToDatum(datum: InlineDatum): Promise<any> /*unused*/ {\n        const myUtxos = await this.network.getUtxos(this.address);\n        throw new Error(`unused`);\n        // const dump = utxosAsString(myUtxos)\n        // console.log({dump})\n        return myUtxos.filter((u) => {\n            return u.output.datum?.hash.isEqual(datum.hash);\n        });\n    }\n\n    /**\n     * Returns the indicated Value to the contract script\n     * @public\n     * @param tcx - transaction context\n     * @param value - a value already having minUtxo calculated\n     * @param datum - inline datum\n     **/\n    //! adds the indicated Value to the transaction;\n    //  ... EXPECTS  the value to already have minUtxo calculated on it.\n    @partialTxn // non-activity partial\n    txnKeepValue(tcx: StellarTxnContext, value: Value, datum: InlineDatum) {\n        tcx.addOutput(makeTxOutput(this.address, value, datum));\n\n        return tcx;\n    }\n\n    /**\n     * Returns all the types exposed by the contract script\n     * @remarks\n     *\n     * Passed directly from Helios; property names match contract's defined type names\n     *\n     * @public\n     **/\n    get onChainTypes(): Program[\"userTypes\"][string] {\n        // compiledScript.userTypes()\n        // const types = { ...this.scriptProgram!.types };\n\n        const scriptNamespace = this.program.name;\n        return this.program.userTypes[scriptNamespace];\n    }\n\n    /**\n     * identifies the enum used for the script Datum\n     * @remarks\n     *\n     * Override this if your contract script uses a type name other than Datum.\n     * @public\n     **/\n    get scriptDatumName() {\n        return \"Datum\";\n    }\n\n    /**\n     * The on-chain type for datum\n     * @remarks\n     *\n     * This getter provides a class, representing the on-chain enum used for attaching\n     * data (or data hashes) to contract utxos the returned type (and its enum variants)\n     * are suitable for off-chain txn-creation override `get scriptDatumName()` if\n     * needed to match your contract script.\n     * @public\n     **/\n    get onChainDatumType(): DataType {\n        return this.getBundle()!.locateDatumType()!;\n    }\n\n    /**\n     * identifies the enum used for activities (redeemers) in the Helios script\n     * @remarks\n     *\n     * Override this if your contract script uses a type name other than Activity.\n     * @public\n     **/\n\n    get scriptActivitiesName() {\n        return \"Activity\";\n    }\n\n    getSeed(arg: hasSeed) {\n        return getSeed(arg);\n    }\n\n    /**\n     * returns the on-chain type for activities (\"redeemers\")\n     * @remarks\n     *\n     * Use mustGetActivityName() instead, to get the type for a specific activity.\n     *\n     * returns the on-chain enum used for spending contract utxos or for different use-cases of minting (in a minting script).\n     * the returned type (and its enum variants) are suitable for off-chain txn-creation\n     * override `get onChainActivitiesName()` if needed to match your contract script.\n     * @public\n     **/\n    get onChainActivitiesType(): DataType {\n        const { scriptActivitiesName: onChainActivitiesName } = this;\n        if (!this._bundle) throw new Error(`no scriptProgram`);\n        const scriptNamespace = this.program.name;\n        const {\n            [scriptNamespace]: { [onChainActivitiesName]: ActivitiesType },\n        } = this.program.userTypes;\n\n        return ActivitiesType;\n    }\n\n    /**\n     * @deprecated - see {@link StellarContract.activityVariantToUplc|this.activityVariantToUplc(variant, data)} instead\n     * Retrieves an on-chain type for a specific named activity (\"redeemer\")\n     * @remarks\n     *\n     * Cross-checks the requested name against the available activities in the script.\n     * Throws a helpful error if the requested activity name isn't present.'\n     *\n     * @param activityName - the name of the requested activity\n     * @public\n     **/\n    mustGetActivity(activityName: string): EnumMemberType | null {\n        const ocat = this.onChainActivitiesType;\n        return this.mustGetEnumVariant(ocat, activityName);\n    }\n\n    /**\n     * asserts the presence of the indicated activity name in the on-chain script\n     * @remarks\n     * The activity name is expected to be found in the script's redeemer enum\n     */\n    mustHaveActivity(activityName: string): EnumMemberType | null {\n        const ocat = this.onChainActivitiesType;\n        if (!(activityName in ocat.typeMembers)) {\n            throw new Error(\n                `${this.constructor.name}: missing required on-chain activity: ${activityName}`\n            );\n        }\n        return this.mustGetEnumVariant(ocat, activityName);\n    }\n\n    activityRedeemer(activityName: string, data?: any) {\n        const activities = this.onChainActivitiesType;\n\n        return {\n            redeemer: this.typeToUplc(activities, {\n                [activityName]: data,\n            }),\n        };\n    }\n\n    activityVariantToUplc(activityName: string, data: any) {\n        const activities = this.onChainActivitiesType;\n\n        return this.typeToUplc(activities, {\n            [activityName]: data,\n        });\n    }\n\n    mustGetEnumVariant(\n        enumType: DataType,\n        variantName: string\n    ): EnumMemberType | null {\n        const { [variantName]: variantType } = enumType.typeMembers;\n\n        if (!variantType) {\n            // const { scriptActivitiesName: onChainActivitiesName } = this;\n            const variantNames: string[] = [];\n            //inspect the properties in `this`, using property descriptors.\n            for (const [name, _] of Object.entries(enumType.typeMembers)) {\n                //Some of them will point to Class definitions.\n                // check if any of those classes inherit from UplcData.\n                debugger;\n                if (isUplcData(enumType[name].prototype)) {\n                    console.warn(\n                        \"\\n\".repeat(8) +\n                            \"------------------------ check enum variant name\",\n                        name\n                    );\n                    debugger;\n                    // if so, add the name to activityNames.\n                    variantNames.push(name);\n                } else {\n                    debugger;\n                    throw new Error(\n                        \"variant names only available via HeliosData : (\"\n                    );\n                }\n            }\n            debugger;\n            //!!! TODO\n            // enumType.name.site.syntaxError(\"yuck\")\n            ///or similar (search: getFilePos())\n            throw new Error(\n                `$${this.constructor.name}: activity/enum-variant name mismatch in ${enumType.name}: variant '${variantName}' unknown\\n` +\n                    ` ... variants in this enum: ${variantNames.join(\", \")}`\n            );\n        }\n        return variantType.asEnumMemberType;\n    }\n\n    inlineDatum(datumName: string, data: any) {\n        return makeInlineTxOutputDatum(\n            this.typeToUplc(this.onChainDatumType, {\n                [datumName]: data,\n            })\n        );\n    }\n\n    /**\n     * provides a temporary indicator of mainnet-ness, while not\n     * requiring the question to be permanently resolved.\n     * @remarks\n     * Allows other methods to proceed prior to the final determination of mainnet status.\n     *\n     * Any code using this path should avoid caching a negative result.  If you need to\n     * determine the actual network being used, getBundle().isMainnet, if present, provides\n     * the definitive answer.  If that attribute is not yet present, then the mainnet status\n     * has not yet been materialized.\n     * @public\n     */\n    isDefinitelyMainnet() {\n        return this.getBundle().isDefinitelyMainnet();\n    }\n\n    paramsToUplc(params: Record<string, any>): UplcRecord<ConfigType> {\n        return this.getBundle().paramsToUplc(params);\n    }\n\n    typeToUplc(type: DataType, data: any, path: string = \"\"): UplcData {\n        return this.getBundle().typeToUplc(type, data, path);\n    }\n\n    get program() {\n        return this.getBundle()!.program;\n    }\n\n    _utxoHelper: UtxoHelper;\n    /**\n     * Provides access to a UtxoHelper instance\n     */\n    get utxoHelper() {\n        return this._utxoHelper;\n    }\n    /**\n     * Provides access to a UtxoHelper instance\n     * @remarks - same as utxoHelper, but with a shorter name\n     */\n    get uh() {\n        return this._utxoHelper;\n    }\n\n    /**\n     * @deprecated - use `tcx.submit()` instead.\n     */\n    async submit(\n        tcx: StellarTxnContext,\n        {\n            signers = [],\n            addlTxInfo = {\n                description: tcx.txnName ? \": \" + tcx.txnName : \"\",\n            },\n        }: {\n            signers?: Address[];\n            addlTxInfo?: Pick<TxDescription<any, any>, \"description\">;\n        } = {}\n    ) {\n        console.warn(\"deprecated: use tcx.submit() instead\");\n        return tcx.buildAndQueue({ signers, addlTxInfo });\n    }\n\n    //!!! todo: implement more and/or test me:\n    // async findFreeLovelaceWithTokens(v: Value, w: Wallet) {\n    // it.todo(\"helps find spare lovelace in tokens\");\n    // it.todo(\"will help harvest spare lovelace in the future if minUtxo is changed\");\n    //     const utxos = await w.utxos;\n    //     const lovelaceOnly = v.assets.isZero();\n    //     //! it finds free lovelace in token bundles, if it can't find free lovelace otherwise\n    //     if (lovelaceOnly) {\n    //         let maxFree: TxInput, minToken: TxInput;\n    //         let minPolicyCount = Infinity;\n\n    //         for (const u of utxos) {\n    //             const policies = u.value.assets.mintingPolicies.length;\n    //             if (policies < minPolicyCount) {\n    //                 minPolicyCount = policies;\n    //                 minToken = u;\n    //             }\n\n    //             const free =\n    //                 u.value.lovelace -\n    //                 u.origOutput.calcMinLovelace(this.networkParams);\n    //             //@ts-ignore\n    //             if (!maxFree) {\n    //                 maxFree = u;\n    //             } else if (free > maxFree!.value.lovelace) {\n    //                 maxFree = u;\n    //             }\n    //         }\n    //     }\n    // }\n\n    _cache: ComputedScriptProperties = {};\n    optimize: boolean = true;\n\n    async prepareBundleWithScriptParams(\n        params: Partial<ConfigType> & Required<Pick<ConfigType, \"rev\">>\n    ) {\n        if (this._compiledScript) {\n            console.warn(\n                \"compileWithScriptParams() called after script compilation already done\"\n            );\n            debugger;\n        }\n        if (!this.usesContractScript) {\n            throw new Error(`avoid this call to begin with?`);\n            return;\n        }\n        if (!params) {\n            throw new Error(`contractParams not set`);\n        }\n\n        let bundle = this.getBundle();\n        // if (bundle.isPrecompiled) {\n        //     debugger;\n        //     console.warn(\n        //         `deployed script shouldn't need to compile (debugging breakpoint available)`\n        //     );\n        // }\n        if (!this.setup) {\n            console.warn(\n                `compileWithScriptParams() called before setup is available`\n            );\n            debugger;\n        }\n\n        if (\n            !bundle.setup ||\n            bundle.setup.isPlaceholder ||\n            !bundle.configuredUplcParams\n        ) {\n            // serves capo's bootstrap in mkTxnMintCharterToken()\n            // also allows delegates to call <bundleClass>.create() without args,\n            // ... and still get the right setup details.\n            bundle = this._bundle = bundle.withSetupDetails({\n                params,\n                setup: this.setup,\n            });\n        }\n        // this._compiledScript = await bundle.compiledScript(true);\n\n        // console.log(\n        //     `       ✅ ${this.constructor.name} ready with scriptHash=`,\n        //     bytesToHex(this.compiledScript.hash())\n        // );\n        this._cache = {};\n    }\n\n    /**\n     * Locates a UTxO locked in a validator contract address\n     * @remarks\n     *\n     * Throws an error if no matching UTxO can be found\n     * @param semanticName - descriptive name; used in diagnostic messages and any errors thrown\n     * @param predicate - filter function; returns its utxo if it matches expectations\n     * @param exceptInTcx - any utxos already in the transaction context are disregarded and not passed to the predicate function\n     * @param extraErrorHint - user- or developer-facing guidance for guiding them to deal with the miss\n     * @public\n     **/\n    //! finds a utxo (\n    async mustFindMyUtxo(\n        semanticName: string,\n        options: {\n            predicate: utxoPredicate;\n            exceptInTcx?: StellarTxnContext;\n            extraErrorHint?: string;\n            utxos?: TxInput[];\n        }\n    ): Promise<TxInput> {\n        const { predicate, exceptInTcx, extraErrorHint, utxos } = options;\n        const { address } = this;\n\n        return this.utxoHelper.mustFindUtxo(semanticName, {\n            predicate,\n            address,\n            exceptInTcx,\n            extraErrorHint,\n            utxos,\n        });\n    }\n\n    /**\n     * Reuses an existing transaction context, or creates a new one with the given name and the current actor context\n     */\n    mkTcx<TCX extends StellarTxnContext>(\n        tcx: StellarTxnContext | undefined,\n        name?: string\n    ): TCX;\n    /**\n     * Creates a new transaction context with the current actor context\n     */\n    mkTcx(name?: string): StellarTxnContext;\n    mkTcx(tcxOrName?: StellarTxnContext | string, name?: string) {\n        const tcx =\n            tcxOrName instanceof StellarTxnContext\n                ? tcxOrName\n                : new StellarTxnContext(this.setup).withName(name || \"\");\n\n        const effectiveName =\n            tcxOrName instanceof StellarTxnContext ? name : tcxOrName;\n\n        if (effectiveName && !tcx.txnName) return tcx.withName(effectiveName);\n        return tcx;\n    }\n\n    /**\n     * Finds a free seed-utxo from the user wallet, and adds it to the transaction\n     * @remarks\n     *\n     * Accepts a transaction context that may already have a seed.  Returns a typed\n     * tcx with hasSeedUtxo type.\n     *\n     * The seedUtxo will be consumed in the transaction, so it can never be used\n     * again; its value will be returned to the user wallet.\n     *\n     * The seedUtxo is needed for UUT minting, and the transaction is typed with\n     * the presence of that seed (found in tcx.state.seedUtxo).\n     *\n     * If a seedUtxo is already present in the transaction context, no additional seedUtxo\n     * will be added.\n     *\n     * If a seedUtxo is provided as an argument, that utxo must already be present\n     * in the transaction inputs; the state will be updated to reference it.\n     *\n     * @public\n     *\n     **/\n    async tcxWithSeedUtxo<TCX extends StellarTxnContext>(\n        tcx: TCX = new StellarTxnContext(this.setup) as TCX,\n        seedUtxo?: TxInput\n    ): Promise<TCX & hasSeedUtxo> {\n        if (\n            //prettier-ignore\n            //@ts-expect-error on this type probe\n            tcx.state && tcx.state.seedUtxo\n        ) {\n            return tcx as TCX & hasSeedUtxo;\n        }\n        if (seedUtxo) {\n            let tcx2 = tcx as TCX & hasSeedUtxo;\n            if (!tcx.inputs.find((utxo) => utxo.isEqual(seedUtxo))) {\n                tcx2 = tcx2.addInput(seedUtxo);\n                // throw new Error(`seedUtxo not found in transaction inputs`);\n            }\n            tcx2.state.seedUtxo = seedUtxo;\n            return tcx2;\n        } else {\n            return this.findUutSeedUtxo([], tcx).then((newSeedUtxo) => {\n                const tcx2 = tcx.addInput(newSeedUtxo) as TCX & hasSeedUtxo;\n                tcx2.state.seedUtxo = newSeedUtxo;\n                return tcx2;\n            });\n        }\n    }\n    async findUutSeedUtxo(uutPurposes: string[], tcx: StellarTxnContext<any>) {\n        const uh = this.utxoHelper;\n        //!!! big enough to serve minUtxo for each of the new UUT(s)\n        const uutSeed = uh.mkValuePredicate(BigInt(13_000_000), tcx);\n        return uh.mustFindActorUtxo(`seed-for-uut ${uutPurposes.join(\"+\")}`, {\n            predicate: uutSeed,\n            exceptInTcx: tcx,\n            extraErrorHint:\n                \"You might need to create some granular utxos in your wallet by sending yourself a series of small transactions (e.g. 15 then 16 and then 17 ADA) as separate utxos/txns\",\n        });\n    }\n}\n","/**\n * Documents one specific requirement\n * @remarks\n *\n * Describes the purpose, details, and implementation mechanism for a single requirement for a unit of software.\n *\n * Also references any other requirements in the host ReqtsMap structure, whose behavior this requirement\n * depends on.  The details of those other dependencies, are delegated entirely to the other requirement, facilitating\n * narrowly-focused capture of for key expectations within each individual semantic expectation of a software unit's\n * behavior.\n * \n * if there are inherited requirements, dependencies on them can be expressed in the `requiresInherited` field.\n *\n * @typeParam reqts - constrains `requires` entries to the list of requirements in the host ReqtsMap structure\n * @public\n **/\nexport type RequirementEntry<reqtName extends string, reqts extends string, inheritedNames extends string | never> = {\n    purpose: string;\n    details: string[];\n    mech: string[];\n    impl?: string; // todo: constrained to method names of the object meeting the requirements\n\n    // excludes the requirement from being referenced as its own dependendcy\n    // excludes inherited reqt names from being referenced as dependencies (use requiresInherited instead)\n    // allows inherited names to reference other inherited names\n    requires?: reqtName extends inheritedNames ? inheritedNames[] : Exclude<reqts, reqtName | inheritedNames>[];\n\n    requiresInherited? : inheritedNames[];\n};\n\nconst TODO = Symbol(\"needs to be implemented\");\n/**\n * tags requirement that aren't yet implemented\n * @public\n **/\nexport type TODO_TYPE = typeof TODO;\n\n/**\n * Describes the requirements for a unit of software\n * @remarks\n *\n * A requirements map is a list of described requirements, in which each requirement\n * has a synopsis, a description of its purpose, descriptive detail, and technical requirements\n * for the mechanism used for implementation.  The mech strings should be usable as unit-test titles.\n *\n * use the hasReqts() helper method to declare a type-safe set of requirements following this data structure.\n *\n * Each requirement also has space for nested 'requires', without the need for deeply nested data structures;\n * these reference other requirements in the same hasReqts() data structure. As a result, high-level and detail-\n * level requirements and 'impl' details can have progressive levels of detail.\n *\n * @typeParam reqts - the list of known requirement names.  Implicitly detected by the hasReqts() helper.\n * @public\n **/\nexport type ReqtsMap<validReqts extends string, inheritedNames extends string | never = never> = {\n    [reqtDescription in validReqts]: TODO_TYPE | RequirementEntry<reqtDescription, validReqts, inheritedNames>;\n};\n\n/**\n * Factory for type-safe requirements details for a unit of software\n * @remarks\n * return `hasReqts({... requirements})` from a requirements() or other method in a class, to express\n * requirements using a standardized form that supports arbitrary amounts of detailed requirements\n * with references to unit-test labels that can verify the impl details.\n *\n * You don't need to provide the type params or TS type annotations.  `requirements() { return hasReqts({...yourReqts}) }` will work fine.\n *\n * See the {@link ReqtsMap} and {@link RequirementEntry} types for more details about expressing requirements.\n *\n * NOTE: Type parameters are inferred from the provided data structure\n * @param reqtsMap - the ReqtsMap structure for the software unit\n * @public\n */\nexport function hasReqts<\n    R extends ReqtsMap<validReqts, inheritedNames>,\n    const validReqts extends string = string & keyof R,\n    const inheritedNames extends string | never = never\n>(reqtsMap: R): ReqtsMap<validReqts, inheritedNames> {\n    return reqtsMap;\n}\n/** @public */\nhasReqts.TODO = TODO;\n\n/**\n * Factory for type-safe requirements combining inherited requirements with subclass-specific requirements\n * @remarks\n *\n * Use this method to combine the requirements of a subclass with the requirements of its superclass.  This\n * allows the subclass, in its requires: [ ... ] section, to reference capabilities of the base class that the subclass depends on.\n *\n * See the {@link ReqtsMap} and {@link RequirementEntry} types for more details about expressing requirements.\n *\n * @param inherits - the requirements of the base class\n * @param reqtsMap - the requirements of the subclass\n * @public\n **/\nexport function mergesInheritedReqts<\n    IR extends ReqtsMap<inheritedReqts>,\n    R extends ReqtsMap<myReqts, inheritedReqts>,\n    const inheritedReqts extends string = string & keyof IR,\n    const myReqts extends string = keyof R extends keyof IR ? never : string & keyof R,\n    // const parentReqts extends string = keyof { [parentReqt in inheritedReqts as `Parent: ${parentReqt}`] : any}\n>(inherits: IR, reqtsMap: R): ReqtsMap<myReqts | inheritedReqts , inheritedReqts \n        // never /*parentReqts */\n    > & IR {\n\n        //@ts-expect-error - uff, sorry folks.\n    return { ...inherits, ...reqtsMap } \n}\n","import type { TxInput, ValidatorHash } from \"@helios-lang/ledger\";\nimport type { Value } from \"@helios-lang/ledger\";\n\nimport { StellarContract, type configBaseWithRev } from \"../StellarContract.js\";\nimport { StellarTxnContext } from \"../StellarTxnContext.js\";\nimport type { capoDelegateConfig } from \"./RolesAndDelegates.js\";\nimport type {\n    ContractDataBridgeWithEnumDatum,\n    ContractDataBridgeWithOtherDatum,\n} from \"../helios/dataBridge/DataBridge.js\";\nimport type { AbstractNew } from \"../helios/typeUtils.js\";\n\nimport type { isActivity } from \"../ActivityTypes.js\";\nimport { hasReqts } from \"../Requirements.js\";\nimport { dumpAny } from \"../diagnostics.js\";\nimport { mkTv } from \"../utils.js\";\n\n/**\n * Base class for modules that can serve as Capo delegates\n * @public\n * @remarks\n *\n * establishes a base protocol for delegates.\n * @typeParam CT - type of any specialized configuration; use capoDelegateConfig by default.\n **/\nexport abstract class StellarDelegate extends StellarContract<capoDelegateConfig> {\n    static currentRev = 1n;\n    static get defaultParams() {\n        return { \n            rev: this.currentRev\n         };\n    }\n    // not required except for Contract-based delegates.  A subclass can represent a delegation\n    // relationship without an on-chain contract, resulting in there being no relevant data-bridge.\n    declare dataBridgeClass:\n        | AbstractNew<ContractDataBridgeWithEnumDatum>\n        | undefined;\n\n    /**\n     * Finds and adds the delegate's authority token to the transaction\n     * @remarks\n     *\n     * calls the delegate-specific DelegateAddsAuthorityToken() method,\n     * with the uut found by DelegateMustFindAuthorityToken().\n     *\n     * returns the token back to the contract using {@link StellarDelegate.txnReceiveAuthorityToken | txnReceiveAuthorityToken() }\n     * @param tcx - transaction context\n     * @public\n     **/\n    async txnGrantAuthority<TCX extends StellarTxnContext>(\n        tcx: TCX,\n        redeemer?: isActivity,\n        skipReturningDelegate?: \"skipDelegateReturn\"\n    ) {\n        const label = `${this.constructor.name} authority`;\n        const uutxo = await this.DelegateMustFindAuthorityToken(tcx, label);\n        const useMinTv = true;\n        const authorityVal = this.tvAuthorityToken(useMinTv);\n        console.log(\n            `   ------- delegate '${label}' grants authority with ${dumpAny(\n                authorityVal,\n                this.networkParams\n            )}`\n        );\n\n        try {\n            const tcx2 = await this.DelegateAddsAuthorityToken(\n                tcx,\n                uutxo,\n                redeemer\n            );\n            if (skipReturningDelegate) return tcx2;\n            return this.txnReceiveAuthorityToken(tcx2, authorityVal, uutxo);\n        } catch (error: any) {\n            if (error.message.match(/input already added/)) {\n                throw new Error(\n                    `Delegate ${label}: already added: ${dumpAny(\n                        authorityVal,\n                        this.networkParams\n                    )}`\n                );\n            }\n            throw error;\n        }\n    }\n\n    /**\n     * Finds the authority token and adds it to the transaction, tagged for retirement\n     * @public\n     * @remarks\n     * Doesn't return the token back to the contract.\n     **/\n    async txnRetireAuthorityToken<TCX extends StellarTxnContext>(tcx: TCX) {\n        const uutxo = await this.DelegateMustFindAuthorityToken(\n            tcx,\n            `${this.constructor.name} authority`\n        );\n        return this.DelegateRetiresAuthorityToken(tcx, uutxo);\n    }\n\n    /**\n     * Standard delegate method for receiving the authority token as a txn output\n     * @remarks\n     *\n     * creates a UTxO / TxOutput, depositing the indicated token-name into the delegated destination.\n     *\n     * Each implemented subclass can use it's own style to match its strategy & mechanism,\n     * and is EXPECTED to use tcx.addOutput() to receive the indicated `tokenValue` into the\n     * contract or other destination address.\n     *\n     * This method is used both for the original deposit and for returning the token during a grant-of-authority.\n     *\n     * Impls should normally preserve the datum from an already-present sourceUtxo, possibly with evolved details.\n     *\n     * @param tcx - transaction-context\n     * @param tokenValue - the Value of the token that needs to be received.  Always includes\n     *   the minUtxo needed for this authority token\n     * @param fromFoundUtxo - always present when the authority token already existed; can be\n     *   used to duplicate or iterate on an existing datum, or to include any additional Value in the new\n     *   UTxO, to match the previous UTxO with minimal extra heuristics\n     * @public\n     **/\n\n    abstract txnReceiveAuthorityToken<TCX extends StellarTxnContext>(\n        tcx: TCX,\n        tokenValue: Value,\n        // delegateAddr: Address,\n        fromFoundUtxo?: TxInput\n    ): Promise<TCX>;\n\n    mkAuthorityTokenPredicate() {\n        return this.uh.mkTokenPredicate(this.tvAuthorityToken());\n    }\n    get authorityTokenName() {\n        return this.configIn!.tn;\n    }\n\n    tvAuthorityToken(useMinTv: boolean = false) {\n        if (!this.configIn)\n            throw new Error(`must be instantiated with a configIn`);\n\n        const {\n            mph,\n            tn,\n            // reqdAddress,  // removed\n        } = this.configIn;\n        if (useMinTv) return this.uh.mkMinTv(mph, tn);\n        return mkTv(mph, tn);\n    }\n\n    get delegateValidatorHash(): ValidatorHash | undefined {\n        return undefined;\n    }\n\n    /**\n     * Finds the delegate authority token, normally in the delegate's contract address\n     * @public\n     * @remarks\n     *\n     * The default implementation finds the UTxO having the authority token\n     * in the delegate's contract address.\n     *\n     * @param tcx - the transaction context\n     * @reqt It MUST resolve and return the UTxO (a TxInput type ready for spending)\n     *  ... or throw an informative error\n     **/\n    abstract DelegateMustFindAuthorityToken(\n        tcx: StellarTxnContext,\n        label: string\n    ): Promise<TxInput>;\n\n    /**\n     * Adds the delegate's authority token to a transaction\n     * @public\n     * @remarks\n     * Given a delegate already configured by a Capo, this method implements\n     * transaction-building logic needed to include the UUT into the `tcx`.\n     * the `utxo` is discovered by {@link StellarDelegate.DelegateMustFindAuthorityToken | DelegateMustFindAuthorityToken() }\n     **/\n    abstract DelegateAddsAuthorityToken<TCX extends StellarTxnContext>(\n        tcx: TCX,\n        uutxo: TxInput,\n        redeemer?: isActivity\n    ): Promise<TCX>;\n\n    /**\n     * Adds any important transaction elemements supporting the authority token being retired, closing the delegate contracts' utxo.\n     * @remarks\n     *\n     * EXPECTS to receive a Utxo having the result of txnMustFindAuthorityToken()\n     *\n     * EXPECTS the `burn` instruction to be separately added to the transaction.\n     *\n     * The default implementation uses the conventional `Retiring` activity\n     * to spend the token.\n     *\n     * @reqt\n     * It MUST add the indicated utxo to the transaction as an input\n     *\n     * @reqt\n     * When backed by a contract:\n     *   * it should use an activity/redeemer allowing the token to be spent\n     *      **and NOT returned**.\n     *   * the contract script SHOULD ensure any other UTXOs it may also hold, related to this delegation,\n     *      do not become inaccessible as a result.\n     *\n     * It MAY enforce additional requirements and/or block the action.\n     *\n     *\n     * @param tcx - transaction context\n     * @param fromFoundUtxo - the utxo having the authority otken\n     * @public\n     **/\n    abstract DelegateRetiresAuthorityToken<TCX extends StellarTxnContext>(\n        tcx: TCX,\n        fromFoundUtxo: TxInput\n    ): Promise<TCX>;\n\n    /**\n     * Captures requirements as data\n     * @remarks\n     *\n     * see reqts structure\n     * @public\n     **/\n    delegateRequirements() {\n        return hasReqts({\n            \"provides an interface for providing arms-length proof of authority to any other contract\":\n                {\n                    purpose:\n                        \"to decouple authority administration from its effects\",\n                    details: [\n                        \"Any contract can create a UUT for use with an authority policy.\",\n                        \"By depositing that UUT to the authority contract, it can delegate completely\",\n                        \"  ... all the implementation details for administration of the authority itself.\",\n                        \"It can then focus on implementing the effects of authority, requiring only \",\n                        \"  ... that the correct UUT has been spent, to indicate that the authority is granted.\",\n                        \"The authority contract can have its own internal details \",\n                        \"A subclass of this authority policy may provide additional administrative dynamics.\",\n                    ],\n                    mech: [],\n                    requires: [\n                        \"implementations SHOULD positively govern spend of the UUT\",\n                        \"implementations MUST provide an essential interface for transaction-building\",\n                    ],\n                },\n\n            \"implementations SHOULD positively govern spend of the UUT\": {\n                purpose: \"for sufficient assurance of desirable safeguards\",\n                details: [\n                    \"A subclass of the GenericAuthority should take care of guarding the UUT's spend\",\n                    \"  ... in whatever way is appropriate for its use-case\",\n                ],\n                mech: [],\n                requires: [],\n            },\n\n            \"implementations MUST provide an essential interface for transaction-building\":\n                {\n                    purpose:\n                        \"enabling a strategy-agnostic interface for making transactions using any supported strategy-variant\",\n                    details: [\n                        \"Subclasses MUST implement the interface methods\",\n                        \"  ... in whatever way is good for its use-case.\",\n                        \"An interface method whose requirement is marked with 'MAY/SHOULD' behavior, \",\n                        \"  ... MUST still implement the method satisfying the interface, \",\n                        \"  ... but MAY throw an UnsupportedAction error, to indicate that\",\n                        \"  ... the strategy variant has no meaningful action to perform \",\n                        \"  ... that would serve the method's purpose\",\n                    ],\n                    mech: [],\n                    requires: [\n                        //!!! todo: cross-check these requirements for completeness\n                        //  ... and for accuracy\n                        \"requires a txnReceiveAuthorityToken(tcx, delegateAddr, fromFoundUtxo?)\",\n                        \"requires a mustFindAuthorityToken(tcx)\",\n                        \"requires a txnGrantAuthority(tcx, delegateAddr, fromFoundUtxo)\",\n                        \"requires txnRetireCred(tcx, fromFoundUtxo)\",\n                    ],\n                },\n\n            \"requires a txnReceiveAuthorityToken(tcx, delegateAddr, fromFoundUtxo?)\":\n                {\n                    purpose:\n                        \"to deposit the authority token (back) to the delegated destination\",\n                    details: [\n                        \"impls MUST implement txnReceiveAuthorityToken\",\n                        \"Each implemented subclass can use it's own style to match its strategy & mechanism\",\n                        \"This is used both for the original deposit and for returning the token during a grant-of-authority\",\n                    ],\n                    mech: [\n                        \"impls MUST create a UTxO depositing the indicated token-name into the delegated destination.\",\n                        \"impls should normally preserve the datum from an already-present sourceUtxo\",\n                    ],\n                    requires: [],\n                },\n\n            \"requires a mustFindAuthorityToken(tcx)\": {\n                purpose: \"to locate the given authority token\",\n                details: [\n                    \"allows different strategies for finding the UTxO having the authority token\",\n                    \"impls MAY use details seen in the txn context to find the indicated token\",\n                ],\n                mech: [\n                    \"impls MUST resolve the indicated token to a specific UTxO or throw an informative error\",\n                ],\n            },\n\n            \"requires a txnGrantAuthority(tcx, delegateAddr, fromFoundUtxo)\": {\n                purpose: \"to use the delegated authority\",\n                details: [\n                    \"Adds the indicated utxo to the transaction with appropriate activity/redeemer\",\n                    \"Contracts needing the authority within a transaction can rely on the presence of this spent authority\",\n                    \"Impls can EXPECT the token will be returned via txnReceiveAuthorityToken\",\n                    \"a contract-backed impl SHOULD enforce the expected return in its on-chain code\",\n                ],\n                mech: [\n                    \"the base AuthorityPolicy MUST call txnReceiveAuthorityToken() with the token's sourceUtxo\",\n                ],\n            },\n\n            \"requires txnRetireCred(tcx, fromFoundUtxo)\": {\n                purpose: \"to allow burning the authority token\",\n                details: [\n                    \"Adds the indicated utxo to the transaction with appropriate activity/redeemer\",\n                    \"  ... allowing the token to be burned by the minting policy.\",\n                    \"Impls SHOULD ensure any other UTXOs it may hold do not become inaccessible as a result\",\n                ],\n                mech: [\n                    \"impls MUST add the token to the txn if it can be retired\",\n                    \"if the token cannot be retired, by appropriate policy, it SHOULD throw an informative error\",\n                ],\n            },\n        });\n    }\n}\n","import { makeTxInput, makeTxOutput } from \"@helios-lang/ledger\";\nimport type {\n    Value,\n    TxOutputId,\n    TxInput,\n    ValidatorHash,\n} from \"@helios-lang/ledger\";\nimport type { Capo } from \"../Capo.js\";\nimport type {\n    DelegateSetupWithoutMintDelegate,\n    MinimalDelegateLink,\n    MintUutActivityArgs,\n    NormalDelegateSetup,\n    hasCharterRef,\n} from \"../CapoTypes.js\";\nimport type {\n    mustFindActivityType,\n    mustFindConcreteContractBridgeType,\n    mustFindDatumType,\n    mustFindReadDatumType,\n} from \"../helios/dataBridge/BridgeTypes.js\";\nimport type {\n    GenericDelegateBridge,\n    GenericDelegateBridgeClass,\n    GenericDelegateDatum,\n} from \"./GenericDelegateBridge.js\";\n\nimport { Activity, datum } from \"../StellarContract.js\";\nimport { StellarDelegate } from \"./StellarDelegate.js\";\nimport type {\n    DelegationDetail,\n    capoDelegateConfig,\n} from \"./RolesAndDelegates.js\";\nimport { StellarTxnContext } from \"../StellarTxnContext.js\";\nimport type { CapoDelegateBundle } from \"../helios/scriptBundling/CapoDelegateBundle.js\";\nimport type { isActivity } from \"../ActivityTypes.js\";\n\nimport { bytesToText, textToBytes } from \"../HeliosPromotedTypes.js\";\nimport type { IFISNEVER } from \"../helios/typeUtils.js\";\n\n/**\n * Base class for delegates controlled by a smart contract, as opposed\n * to a simple delegate backed by an issued token, whose presence\n * grants delegated authority.\n * @public\n */\nexport class ContractBasedDelegate extends StellarDelegate {\n    /**\n     * Each contract-based delegate must define its own dataBridgeClass, but they all\n     * use the same essential template for the outer layer of their activity & datum interface.\n     */\n    declare dataBridgeClass: GenericDelegateBridgeClass;\n    declare _dataBridge: GenericDelegateBridge;\n    static currentRev = 1n;\n\n    /**\n     * Configures the matching parameter name in the on-chain script, indicating\n     * that this delegate serves the Capo by enforcing policy for spending the Capo's utxos.\n     * @remarks\n     * Not used for any mint delegate.  Howeever, a mint delegate class can instead provide a true isMintAndSpendDelegate,\n     *...  if a single script controls both the mintDgt-* and spendDgt-* tokens/delegation roles for your Capo.\n     *\n     * DO NOT enable this attribute for second-level delegates, such as named delegates or delegated-data controllers.\n     * The base on-chain delegate script recognizes this conditional role and enforces that its generic delegated-data activities\n     * are used only in the context the Capo's main spend delegate, re-delegating to the data-controller which\n     * can't use those generic activities, but instead implements its user-facing txns as variants of its SpendingActivities enum.\n     */\n    static isSpendDelegate = false\n\n    get delegateName(): string {\n        throw new Error(\n            `${this.constructor.name}: missing required get delegateName() : string`\n        );\n    }\n\n    get onchain(): mustFindConcreteContractBridgeType<this> {\n        return this.getOnchainBridge() as any;\n    }\n\n    get offchain(): mustFindConcreteContractBridgeType<this>[\"reader\"] {\n        return super.offchain as any;\n    }\n\n    get reader(): mustFindConcreteContractBridgeType<this>[\"reader\"] {\n        return super.offchain as any;\n    }\n\n    get activity(): mustFindActivityType<this> {\n        const bridge = this.onchain;\n        return bridge.activity as any;\n    }\n\n    get mkDatum(): mustFindDatumType<this> {\n        return this.onchain.datum;\n    }\n\n    get newReadDatum(): mustFindReadDatumType<this> {\n        // & ( (d: UplcData) => CapoDatumLike ) {\n        const bridge = this.getOnchainBridge();\n        //x@ts-expect-error probing for presence\n        const { readDatum } = bridge;\n        if (!readDatum) {\n            throw new Error(\n                `${\n                    (this as any).constructor.name\n                }: this contract script doesn't use datum`\n            );\n        }\n\n        return readDatum as any;\n    }\n\n    get capo(): Capo<any, any> {\n        return (this.configIn || this.partialConfig)?.capo as unknown as Capo<any, any>;\n    }\n\n    // mkBundleWithCapo<T extends HeliosScriptBundle>(BundleClass: new (capo: CapoHeliosBundle) => T) : T {\n    //     const { capo } = this.configIn || this.partialConfig || {};\n    //     if (!capo)\n    //         throw new Error(\n    //             `missing capo in config or partial-config for ${this.constructor.name}`\n    //         );\n    //     const capoBundle = capo.getBundle() as CapoHeliosBundle;\n    //     return new BundleClass(capoBundle);\n    // }\n\n    scriptBundle(): CapoDelegateBundle {\n        throw new Error(\n            `${this.constructor.name}: missing required implementation of scriptBundle()\\n` +\n                `\\nEach contract-based delegate must provide a scriptBundle() method.\\n` +\n                `It should return an instance of a class defined in a *.hlb.ts file.  At minimum:\\n\\n` +\n                `    import {YourAppCapo} from \"./YourAppCapo.js\";\\n\\n` +\n                `    import SomeSpecializedDelegate from \"./YourSpecializedDelegate.hl\";\\n\\n` +\n                `    export default class SomeDelegateBundle extends CapoDelegateBundle.using(YourAppCapo) {\\n` +\n                `        specializedDelegateModule = SomeSpecializedDelegate; \\n` +\n                `    }\\n\\n` +\n                `We'll generate an additional .typeInfo.ts, based on the types in your Helios sources,\\n` +\n                `  ... and a .bridge.ts with generated data-conversion code for bridging between off-chain` +\n                `  ... and on-chain data encoding.` +\n                `Your scriptBundle() method can \\`return new SomeDelegateBundle()\\``\n        );\n    }\n\n    get scriptDatumName() {\n        return \"DelegateDatum\";\n    }\n\n    get scriptActivitiesName() {\n        return \"DelegateActivity\";\n    }\n\n    static isMintDelegate = false;\n    static isMintAndSpendDelegate = false;\n    static isDgDataPolicy = false;\n\n    static get defaultParams() {\n        const params = {\n            rev: this.currentRev,\n            isMintDelegate: this.isMintDelegate,\n            isSpendDelegate: this.isMintAndSpendDelegate,\n            isDgDataPolicy: this.isDgDataPolicy,\n        };\n        return params;\n    }\n    static mkDelegateWithArgs(a: capoDelegateConfig) {}\n\n    getContractScriptParams(config: capoDelegateConfig) {\n        const { capoAddr, mph, tn, capo, ...otherConfig } = config;\n\n        return {\n            ...otherConfig,\n            delegateName: this.delegateName,\n        }\n    }\n\n    tcxWithCharterRef<TCX extends StellarTxnContext | hasCharterRef>(tcx: TCX) {\n        return this.capo.tcxWithCharterRef(tcx);\n    }\n\n    /**\n     * Adds a mint-delegate-specific authority token to the txn output\n     * @remarks\n     *\n     * Implements {@link StellarDelegate.txnReceiveAuthorityToken | txnReceiveAuthorityToken() }.\n     *\n     * Uses {@link ContractBasedDelegate.mkDelegationDatum | mkDelegationDatum()} to make the inline Datum for the output.\n     * @see {@link StellarDelegate.txnReceiveAuthorityToken | baseline txnReceiveAuthorityToken()'s doc }\n     * @public\n     **/\n    async txnReceiveAuthorityToken<TCX extends StellarTxnContext>(\n        tcx: TCX,\n        tokenValue: Value,\n        fromFoundUtxo?: TxInput\n    ): Promise<TCX> {\n        const datum = this.mkDelegationDatum(fromFoundUtxo);\n\n        const newOutput = makeTxOutput(this.address, tokenValue, datum);\n        // const separator = `     -----`;\n        // console.log(\n        //     `${separator} delegate script receiving dgTkn\\n${separator} ${dumpAny(\n        //         newOutput\n        //     )}` // ${dumpAny(tokenValue)} at ${dumpAny(addr)} = ${addr.toBech32()}`\n        // );\n        // const ffu = fromFoundUtxo;\n        // const v : Value = ffu?.value || this.mkMinAssetValue(this.configIn!.uut);\n        return tcx.addOutput(newOutput);\n    }\n\n    mkDelegationDatum(txin?: TxInput) {\n        if (txin) return txin.output.datum!;\n        const { capoAddr, mph, tn, ..._otherCfgSettings } = this.configIn!;\n\n        return this.mkDatum.IsDelegation({\n            capoAddr,\n            mph,\n            tn,\n        });\n    }\n\n    /**\n     * redeemer for replacing the authority UUT with a new one\n     * @remarks\n     *\n     * When replacing the delegate, the current UUT will be burned,\n     * and a new one will be minted.  It can be deposited to any next delegate address.\n     *\n     * @param seedTxnDetails - seed details for the new UUT\n     * @public\n     **/\n    @Activity.redeemer\n    activityReplacingMe({\n        seed,\n        purpose,\n    }: Omit<MintUutActivityArgs, \"purposes\"> & { purpose: string }) {\n        throw new Error(`deprecated: explicit activity helper`);\n\n        // return this.mkDelegateLifecycleActivity(\"ReplacingMe\", {\n        //     seed,\n        //     purpose,\n        // });\n    }\n\n    mkDelegateLifecycleActivity(\n        delegateActivityName: \"ReplacingMe\" | \"Retiring\" | \"ValidatingSettings\",\n        args?: Record<string, any>\n    ): isActivity {\n        throw new Error(`deprecated: explicit activity helper`);\n\n        // try {\n        //     return this.activityRedeemer(\"DelegateLifecycleActivities\", {\n        //         activity: { [delegateActivityName]: args },\n        //     });\n        // } catch (e: any) {\n        //     // warning emoji: \"⚠️\"\n        //     e.message =\n        //         \"⚠️ ⚠️ ⚠️ error constructing delegate lifecycle activity.  You might need \" +\n        //         \"to format the args as UplcData if the enum doesn't recognize a valid off-chain type.\\nDelegate lifecycle activity: \" +\n        //         e.message;\n        //     throw e;\n        // }\n    }\n\n    mkCapoLifecycleActivity(\n        capoLifecycleActivityName: \"CreatingDelegate\" | \"ActivatingDelegate\",\n        {\n            seed,\n            purpose,\n            ...otherArgs\n        }: Omit<MintUutActivityArgs, \"purposes\"> & { purpose?: string }\n    ): isActivity {\n        throw new Error(`deprecated: explicit activity helper`);\n\n        // return this.activityRedeemer(\"CapoLifecycleActivities\", {\n        //     activity: {\n        //         [capoLifecycleActivityName]: { seed, purpose, ...otherArgs },\n        //     },\n        // });\n    }\n\n    /**\n     * Creates a reedemer for the indicated spending activity name\n     **/\n    mkSpendingActivity(\n        spendingActivityName: string,\n        args: { id: string | number[] } & Record<string, any>\n    ): isActivity {\n        throw new Error(`deprecated: explicit activity helper`);\n\n        // try {\n        //     let id : number[] = (\"string\" == typeof args.id) ?\n        //         textToBytes(args.id as string) : args.id as number[];\n\n        //         // TODO: require that the on-chain type have first field = 'id', not 'recId' or whatever\n        //     return this.activityRedeemer(\"SpendingActivities\", {\n        //         activity: {\n        //             [spendingActivityName]: { ...args, id },\n        //         },\n        //     });\n        // } catch (e: any) {\n        //     // warning emoji: \"⚠️\"\n        //     e.message =\n        //         \"⚠️ ⚠️ ⚠️ error constructing spending activity: \" + e.message;\n        //     throw e;\n        // }\n    }\n\n    mkSeedlessMintingActivity(\n        mintingActivityName: string,\n        args: Record<string, any>\n    ): isActivity {\n        const { MintingActivity } = this.onChainTypes;\n        const NestedVariant = this.mustGetEnumVariant(\n            MintingActivity,\n            mintingActivityName\n        );\n        throw new Error(`mkSeedlessMintingActivity: deprecated`);\n        // debugger; // ??? vvv\n        // //@ts-ignore !!!!\n        // const nestedVarSt = NestedVariant.prototype._enumVariantStatement;\n        // const firstActivityField =\n        //     nestedVarSt.dataDefinition.fields[0].name.value;\n        // if (\"seed\" === firstActivityField) {\n        //     throw new Error(\n        //         `Minting activity '${mintingActivityName}' requires a seed 🍉. \\n` +\n        //             `   ... therefore, you must use mkSeededMintingActivity() instead.`\n        //     );\n        // }\n        // if (args.seed) {\n        //     throw new Error(\n        //         `mkSeedlessMintingActivity: found unexpected 'seed' field in seedless MintingActivity variant!\\n` +\n        //             `  🍉 ... if this minting activity actually needs a seed, you'd need to adjust its on-chain type definition.` +\n        //             `  ... a seed provides guaranteed uniqueness for minting e.g. a UUT. ` +\n        //             `  ... e.g.minting only fungible tokens doesn't require a seed`\n        //     );\n        // }\n\n        // try {\n        //     return this.activityRedeemer(\"MintingActivities\", {\n        //         activity: { [mintingActivityName]: args },\n        //     });\n        // } catch (e: any) {\n        //     // warning emoji: \"⚠️\"\n        //     e.message =\n        //         \"⚠️ ⚠️ ⚠️ error constructing minting activity.  You might need \" +\n        //         \"to format the args as UplcData if the enum doesn't recognize a valid off-chain type.\\nMinting activity: \" +\n        //         e.message;\n        //     throw e;\n        // }\n    }\n\n    mkSeededMintingActivity(\n        mintingActivityName: string,\n        args: { seed: TxOutputId } & Record<string, any>\n    ): isActivity {\n        const { MintingActivity } = this.onChainTypes;\n        const NestedVariant = this.mustGetEnumVariant(\n            MintingActivity,\n            mintingActivityName\n        );\n        throw new Error(`mkSeededMintingActivity: deprecated`);\n        // if (!NestedVariant) {\n        //     throw new Error(\n        //         `mkSeededMintingActivity: missing MintingActivity variant '${mintingActivityName}'`\n        //     );\n        // }\n        // // const nestedVarSt = NestedVariant.prototype._enumVariantStatement;\n        // const firstActivityField = NestedVariant.fieldNames[0];\n        // // nestedVarSt.dataDefinition.fields[0].name.value;\n        // if (\"seed\" !== firstActivityField) {\n        //     throw new Error(\n        //         `Minting activity '${mintingActivityName}' is not a seeded activity.  \\n` +\n        //             `   ... therefore, you must use mkSeedlessMintingActivity() instead.  🍉`\n        //     );\n        // }\n        // if (!args.seed) {\n        //     throw new Error(\n        //         `mkSeedlessMintingActivity: missing required 'seed' field in MintingActivity variant!\\n` +\n        //             `  🍉 ... if this minting activity doesn't actually need a seed, you'd need to adjust its on-chain type definition.` +\n        //             `  ... a seed provides guaranteed uniqueness for minting e.g. a UUT. ` +\n        //             `  ... e.g., minting only fungible tokens doesn't require a seed`\n        //     );\n        // }\n\n        // try {\n        //     return this.activityRedeemer(\"MintingActivities\", {\n        //         activity: { [mintingActivityName]: args },\n        //     });\n        // } catch (e: any) {\n        //     // warning emoji: \"⚠️\"\n        //     e.message =\n        //         \"⚠️ ⚠️ ⚠️ error constructing minting activity.  You might need \" +\n        //         \"to format the args as UplcData if the enum doesn't recognize a valid off-chain type.\\nMinting activity: \" +\n        //         e.message;\n        //     throw e;\n        // }\n    }\n\n    /**\n     * redeemer for spending the authority UUT for burning it.\n     * @public\n     * @remarks\n     *\n     * The Retiring redeemer indicates that the delegate is being\n     * removed.\n     *\n     **/\n    @Activity.redeemer\n    activityRetiring() {\n        throw new Error(`deprecated: explicit activity helper`);\n\n        // return this.mkDelegateLifecycleActivity(\"Retiring\");\n    }\n\n    @Activity.redeemer\n    activityValidatingSettings() {\n        throw new Error(`deprecated: explicit activity helper`);\n\n        // return this.mkDelegateLifecycleActivity(\"ValidatingSettings\");\n    }\n\n    // @Activity.redeemer\n    activityMultipleDelegateActivities(\n        ...activities: isActivity[]\n    ): isActivity {\n        throw new Error(`deprecated: explicit activity helper`);\n        // return this.activityRedeemer(\"MultipleDelegateActivities\", {\n        //     // todo: allow the cast to take already-uplc'd data\n        //     activities: activities.map((a) => a.redeemer),\n        // });\n    }\n\n    // /**\n    //  * A spend-delegate activity indicating that a delegated-data controller will be governing\n    //  * an update to a specific piece of delegated data.  No further redeemer details are needed here,\n    //  * but the data-delegate's controller-token may have additional details in ITS redeemer,\n    //  * which will be aligned with the one.\n    //  *\n    //  * May be present in the context of a nested MultipleDelegateActivities redeemer, in which\n    //  * case, multiple cases of the above scenario will be present in a single transaction.\n    //  */\n    // @Activity.redeemer\n    // activityUpdatingDelegatedData(\n    //     recId: string | number[]\n    // ): isActivity {\n    //     const recIdBytes = Array.isArray(recId)\n    //         ? recId\n    //         : textToBytes(recId);\n    //     // const Activity = this.mustGetActivity(\"UpdatingDelegatedData\");\n\n    //     // this.activity.DeletingDelegatedData\n\n    //     return {\n    //         // redeemer: new Activity(uutPurpose, recIdBytes),\n    //         redeemer: this.activityVariantToUplc(\"UpdatingDelegatedData\", {\n    //             recId: recIdBytes,\n    //         }),\n    //     };\n    // }\n\n    /**\n     * A mint-delegate activity indicating that a delegated-data controller will be governing\n     * a deletion (burning its UUT) of a specific piece of delegated data.  No further redeemer details are needed here,\n     * but the data-delegate's controller-token may have additional details in ITS redeemer,\n     */\n    @Activity.redeemer\n    activityDeletingDelegatedData(recId: string | number[]): isActivity {\n        throw new Error(`deprecated: explicit activity helper`);\n\n        // const recIdBytes = Array.isArray(recId)\n        //     ? recId\n        //     : textToBytes(recId);\n\n        //     return {\n        //     redeemer: this.activityVariantToUplc(\"DeletingDelegatedData\", {\n        //         recId: recIdBytes,\n        //     }),\n        // };\n    }\n\n    /**\n     * creates the essential datum for a delegate UTxO\n     * @remarks\n     *\n     * Every delegate is expected to have a two-field 'IsDelegation' variant\n     * in the first position of its on-chain Datum type.  This helper method\n     * constructs a suitable UplcData structure, given appropriate inputs.\n     * @param dd - Delegation details\n     * @public\n     **/\n    @datum\n    mkDatumIsDelegation(dd: DelegationDetail) {\n        const { DelegationDetail } = this.onChainTypes;\n        throw new Error(`deprecated: explicit datum helper`);\n\n        // const schema = DelegationDetail.toSchema()\n        // const cast = new Cast(schema, {\n        //     isMainnet: this.setup.isMainnet || false\n        // });\n        return this.inlineDatum(\"IsDelegation\", { dd });\n    }\n\n    /**\n     * returns the ValidatorHash of the delegate script, if relevant\n     * @public\n     * @remarks\n     *\n     * A delegate that doesn't use an on-chain validator should override this method and return undefined.\n     **/\n    get delegateValidatorHash(): ValidatorHash | undefined {\n        if (!this.validatorHash) {\n            throw new Error(\n                `${this.constructor.name}: address doesn't use a validator hash!\\n` +\n                    `  ... if that's by design, you may wish to override 'get delegateValidatorHash()'`\n            );\n        }\n        return this.validatorHash;\n    }\n\n    /**\n     * {@inheritdoc StellarDelegate.DelegateMustFindAuthorityToken}\n     **/\n    async DelegateMustFindAuthorityToken(\n        tcx: StellarTxnContext,\n        label: string\n    ): Promise<TxInput> {\n        return this.mustFindMyUtxo(\n            `${label}: ${bytesToText(this.configIn!.tn)}`, {\n                predicate: this.uh.mkTokenPredicate(this.tvAuthorityToken()),\n                extraErrorHint: \"this delegate strategy might need to override txnMustFindAuthorityToken()\"\n            }\n        );\n    }\n\n    /**\n     * Adds the delegate's authority token to a transaction\n     * @public\n     * @remarks\n     * Given a delegate already configured by a Capo, this method implements\n     * transaction-building logic needed to include the UUT into the `tcx`.\n     * the `utxo` is discovered by {@link StellarDelegate.DelegateMustFindAuthorityToken | DelegateMustFindAuthorityToken() }\n     *\n     * The off-chain code shouldn't need to check the details; it can simply\n     * arrange the details properly and spend the delegate's authority token,\n     * using this method.\n     *\n     * ### Reliance on this delegate\n     *\n     * Other contract scripts can rely on the delegate script to have validated its\n     * on-chain policy and enforced its own \"return to the delegate script\" logic.\n     *\n     * ### Enforcing on-chain policy\n     *\n     * When spending the authority token in this way, the delegate's authority is typically\n     * narrowly scoped, and it's expected that the delegate's on-chain script validates that\n     * those parts of the transaction detail should be authorized, in accordance with the\n     * delegate's core purpose/responsbility - i.e. that the txn does all of what the delegate\n     * expects, and none of what it shouldn't do in that department.\n     *\n     * The on-chain code SHOULD typically enforce:\n     *  * that the token is spent with an application-specific redeemer variant of its\n     *     MintingActivity or SpendingActivitie.\n     *\n     *  * that the authority token is returned to the contract with its datum unchanged\n     *  * that any other tokens it may also hold in the same UTxO do not become\n     *     inaccessible as a result of the transactions - perhaps by requiring them to be\n     *     returned together with the authority token.\n     *\n     * It MAY enforce additional requirements as well.\n     *\n     * @example\n     * A minting delegate should check that all the expected tokens are\n     * minted, AND that no other tokens are minted.\n     *\n     * @example\n     * A role-based authentication/signature-checking delegate can\n     * require an appropriate signature on the txn.\n     *\n     * @param tcx - the transaction context\n     * @param utxo - the utxo having the authority UUT for this delegate\n     * @reqt Adds the uutxo to the transaction inputs with appropriate redeemer.\n     * @reqt Does not output the value; can EXPECT txnReceiveAuthorityToken to be called for that purpose.\n     **/\n    async DelegateAddsAuthorityToken<TCX extends StellarTxnContext>(\n        tcx: TCX,\n        uutxo: TxInput,\n        redeemer: isActivity\n    ): Promise<TCX> {\n        const { capo } = this.configIn!;\n\n        // when there is a delegate upgrade in progress, we must \n        // use the previous script, not the next script, to locate \n        // the authority token.\n\n        const script = this._bundle?.previousCompiledScript() || this.compiledScript\n        const tcx2 = await capo.txnAttachScriptOrRefScript(\n            tcx,\n            script\n        );\n        if (!redeemer.redeemer) debugger\n        return tcx2.addInput(uutxo, redeemer);\n\n        // return this.txnKeepValue(\n        //     tcx,\n        //     uutxo.value,\n        //     uutxo.origOutput.datum as InlineDatum\n        // );\n    }\n\n    /**\n     * {@inheritdoc StellarDelegate.DelegateAddsAuthorityToken}\n     **/\n\n    async DelegateRetiresAuthorityToken<TCX extends StellarTxnContext>(\n        this: ContractBasedDelegate,\n        tcx: StellarTxnContext,\n        fromFoundUtxo: TxInput\n    ): Promise<TCX> {\n        const utxo = fromFoundUtxo;\n\n        return tcx.addInput(\n            makeTxInput(utxo.id, utxo.output),\n            this.activity.DelegateLifecycleActivities.Retiring\n        ) as TCX;\n    }\n}\n\n/**\n * @public\n */\nexport type NamedPolicyCreationOptions<\n    thisType extends Capo<any>,\n    DT extends StellarDelegate\n> = PolicyCreationOptions & {\n    /**\n     * Optional name for the UUT; uses the delegate name if not provided.\n     **/\n    uutName?: string;\n};\n// MinimalDelegateLink<DT> & {\n//     uutOptions: UutCreationAttrs | ForcedUutReplacement\n//     strategyName: string &\n//     keyof thisType[\"delegateRoles\"][\"spendDelegate\"][\"variants\"];\n//     forcedUpdate?: true;\n// };\n\nexport type PolicyCreationOptions = MinimalDelegateLink & {\n    /**\n     * details for creating the delegate\n     */\n    mintSetup: NormalDelegateSetup | DelegateSetupWithoutMintDelegate;\n    // strategyName: string & STRATEGIES;\n    /**\n     * Installs the named delegate without burning the existing UUT for this delegate.\n     * That UUT may become lost and inaccessible, along with any of its minUtxo.\n     **/\n    forcedUpdate?: true;\n};\n"],"names":["bytesToText","tcx","textToBytes","v","mph","datum","__decorateClass"],"mappings":"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"}