{"version":3,"file":"ContractBasedDelegate2.mjs","sources":["../src/Requirements.ts","../src/delegation/StellarDelegate.ts","../src/delegation/ContractBasedDelegate.ts"],"sourcesContent":["import type { IFISNEVER, TypeError } from \"./helios/typeUtils\";\n\nconst notInherited = {\n    inheriting: \"‚Äπempty/base class‚Ä∫\" as const,\n};\ntype nothingInherited = typeof notInherited;\n\n/**\n * Documents one specific requirement\n * @remarks\n *\n * Describes the purpose, details, and implementation mechanism for a single requirement for a unit of software.\n *\n * Also references any other requirements in the host ReqtsMap structure, whose behavior this requirement\n * depends on.  The details of those other dependencies, are delegated entirely to the other requirement, facilitating\n * narrowly-focused capture of for key expectations within each individual semantic expectation of a software unit's\n * behavior.\n *\n * if there are inherited requirements, dependencies on them can be expressed in the `requiresInherited` field.\n *\n * @typeParam reqts - constrains `requires` entries to the list of requirements in the host ReqtsMap structure\n * @public\n **/\nexport type RequirementEntry<\n    reqtName extends string,\n    reqts extends string,\n    inheritedNames extends { inheriting: string } | nothingInherited\n> = {\n    purpose: string;\n    details: string[];\n    mech: string[];\n    impl?: string; // todo: constrained to method names of the object meeting the requirements\n\n    // excludes the requirement from being referenced as its own dependendcy\n    // excludes inherited reqt names from being referenced as dependencies (use requiresInherited instead)\n    // allows inherited names to reference other inherited names\n    requires?: inheritedNames extends nothingInherited\n        ? Exclude<reqts, reqtName>[]\n        : reqtName extends keyof inheritedNames[\"inheriting\"]\n        ? Exclude<inheritedNames[\"inheriting\"], reqtName>[]\n        : (Exclude<reqts, reqtName | inheritedNames[\"inheriting\"]>)[];\n\n    requiresInherited?: inheritedNames[\"inheriting\"][];\n};\n\nconst TODO = Symbol(\"needs to be implemented\");\n/**\n * tags requirement that aren't yet implemented\n * @public\n **/\nexport type TODO_TYPE = typeof TODO;\n\n/**\n * Describes the requirements for a unit of software\n * @remarks\n *\n * A requirements map is a list of described requirements, in which each requirement\n * has a synopsis, a description of its purpose, descriptive detail, and technical requirements\n * for the mechanism used for implementation.  The mech strings should be usable as unit-test titles.\n *\n * use the hasReqts() helper method to declare a type-safe set of requirements following this data structure.\n *\n * Each requirement also has space for nested 'requires', without the need for deeply nested data structures;\n * these reference other requirements in the same hasReqts() data structure. As a result, high-level and detail-\n * level requirements and 'impl' details can have progressive levels of detail.\n *\n * @typeParam reqts - the list of known requirement names.  Implicitly detected by the hasReqts() helper.\n * @public\n **/\nexport type ReqtsMap<\n    validReqts extends string,\n    inheritedNames extends {inheriting: string} | nothingInherited = nothingInherited\n> = {\n    [reqtDescription in validReqts]:\n        | TODO_TYPE\n        | RequirementEntry<reqtDescription, validReqts, inheritedNames>;\n};\n\n/**\n * Factory for type-safe requirements details for a unit of software\n * @remarks\n * return `hasReqts({... requirements})` from a requirements() or other method in a class, to express\n * requirements using a standardized form that supports arbitrary amounts of detailed requirements\n * with references to unit-test labels that can verify the impl details.\n*\n* You don't need to provide the type params or TS type annotations.  `requirements() { return hasReqts({...yourReqts}) }` will work fine.\n * @public\n */\nexport function hasReqts<\n    R extends ReqtsMap<validReqts, inheritedNames>,\n    const validReqts extends string = string & keyof R,\n    const inheritedNames extends {inheriting: string} | nothingInherited = nothingInherited\n>(reqtsMap: R): ReqtsMap<validReqts, inheritedNames> {\n    return reqtsMap;\n}\n/** @public */\nhasReqts.TODO = TODO;\n\n/**\n * Factory for type-safe requirements combining inherited requirements with subclass-specific requirements\n * @remarks\n *\n * Use this method to combine the requirements of a subclass with the requirements of its superclass.  This\n * allows the subclass, in its requires: [ ... ] section, to reference capabilities of the base class that the subclass depends on.\n *\n * See the {@link ReqtsMap} and {@link RequirementEntry} types for more details about expressing requirements.\n *\n * @param inherits - the requirements of the base class\n * @param reqtsMap - the requirements of the subclass\n * @public\n **/\nexport function mergesInheritedReqts<\n    IR extends ReqtsMap<inheritedReqts[\"inheriting\"], any>,\n    R extends ReqtsMap<string & myReqts, inheritedReqts>,\n    const inheritedReqts extends {inheriting: string} = {inheriting: string & keyof IR},\n    const myReqts extends string | TypeError<any> = keyof R extends keyof IR\n        ? TypeError<\"myReqts can't override inherited reqts\">\n        : string & keyof R\n    // const parentReqts extends string = keyof { [parentReqt in inheritedReqts as `Parent: ${parentReqt}`] : any}\n>(\n    inherits: IR,\n    reqtsMap: R\n): ReqtsMap<(string & myReqts) | inheritedReqts[\"inheriting\"], inheritedReqts> & IR {\n    // >(\n    //     inherits: IR,\n    //     reqtsMap: R\n    // ): IR & R {\n    // (string & myReqts) | inheritedReqts,\n    // inheritedReqts\n    // never /*parentReqts */\n    // > {\n    return { ...inherits, ...reqtsMap } as ReqtsMap<\n        (string & myReqts) | inheritedReqts[\"inheriting\"],\n        inheritedReqts\n    > &\n        IR;\n}\n\nfunction typeTester() {\n    const stub = {\n        details: [] as string[],\n        mech: [] as string[],\n    };\n    const pReqts = hasReqts({\n        req1: {\n            purpose: \"test base reqts\",\n            ...stub,\n        },\n        req2: {\n            purpose: \"test internal reqt deps\",\n            ...stub,\n            requires: [\"req1\"],\n        },\n    });\n\n    const mergedReqts = mergesInheritedReqts(pReqts, {\n        mreq1: {\n            purpose: \"outer reqt\",\n            ...stub,\n        },\n        mreq2: {\n            purpose: \"outer dep to outer\",\n            ...stub,\n            requires: [\"mreq1\"],\n        },\n        mreq3: {\n            purpose: \"outer dep to inherited req (bad)\",\n            ...stub,\n            //@ts-expect-error - can't reference inherited reqt here; use requiresInherited instead\n            requires: [\"req1\"],\n            //@ts-expect-error - can't reference local reqt as an inherited req.\n            requiresInherited: [\"mreq2\"]\n        },\n        mreq4: {\n            purpose: \"outer dep to inherited req (good)\",\n            ...stub,\n            requiresInherited: [\"req1\"],\n            // requires: [\"req1\"],\n        },\n    });\n\n    const assignable: typeof pReqts = mergedReqts;\n\n    const mergedAgain = mergesInheritedReqts(mergedReqts, {\n        L2req5: {\n            purpose: \"outer dep to inherited req (good)\",\n            ...stub,\n            requiresInherited: [\"req1\", \"mreq4\"],\n            // requires: [\"req1\"],\n        },\n    });\n\n    return mergedReqts;\n}\n","import type { TxInput, ValidatorHash } from \"@helios-lang/ledger\";\nimport type { Value } from \"@helios-lang/ledger\";\n\nimport { StellarContract, type configBaseWithRev } from \"../StellarContract.js\";\nimport { StellarTxnContext } from \"../StellarTxnContext.js\";\nimport type { capoDelegateConfig } from \"./RolesAndDelegates.js\";\nimport type {\n    ContractDataBridgeWithEnumDatum,\n    ContractDataBridgeWithOtherDatum,\n} from \"../helios/dataBridge/DataBridge.js\";\nimport type { AbstractNew } from \"../helios/typeUtils.js\";\n\nimport type { isActivity } from \"../ActivityTypes.js\";\nimport { hasReqts } from \"../Requirements.js\";\nimport { dumpAny } from \"../diagnostics.js\";\nimport { mkTv } from \"../utils.js\";\nimport type { UplcData } from \"@helios-lang/uplc\";\n\nexport type GrantAuthorityOptions = {\n    skipReturningDelegate?: true;\n    ifExists?: (existingInput: TxInput, existingRedeemer: UplcData) => void;\n};\n\n/**\n * Base class for modules that can serve as Capo delegates\n * @public\n * @remarks\n *\n * establishes a base protocol for delegates.\n * @typeParam CT - type of any specialized configuration; use capoDelegateConfig by default.\n **/\nexport abstract class StellarDelegate extends StellarContract<capoDelegateConfig> {\n    static get defaultParams() {\n        return {\n            rev: 0n,\n        };\n    }\n    // not required except for Contract-based delegates.  A subclass can represent a delegation\n    // relationship without an on-chain contract, resulting in there being no relevant data-bridge.\n    declare dataBridgeClass:\n        | AbstractNew<ContractDataBridgeWithEnumDatum>\n        | undefined;\n\n    existingRedeemerError(\n        label: string,\n        authorityVal: Value,\n        existingRedeemer: UplcData,\n        redeemerActivity?: UplcData\n    ) {\n        console.error(\n            \"This delegate authority is already being used in the transaction...\"\n        );\n        console.error(\n            \"... you may use the {ifExists} option to handle this case, if appropriate\"\n        );\n\n        return new Error(\n            `Delegate ${label}: already added: ${dumpAny(\n                authorityVal,\n                this.networkParams\n            )} with redeemer = ${existingRedeemer} ${\n                redeemerActivity\n                    ? `\\n ... needs redeemer = ${redeemerActivity} (maybe with MultipleDelegateActivities?)`\n                    : \"\"\n            }`\n        );\n    }\n\n    /**\n     * Finds and adds the delegate's authority token to the transaction\n     * @remarks\n     *\n     * calls the delegate-specific DelegateAddsAuthorityToken() method,\n     * with the uut found by DelegateMustFindAuthorityToken().\n     *\n     * Returns the token back to the contract using {@link StellarDelegate.txnReceiveAuthorityToken | txnReceiveAuthorityToken() },\n     * automatically, unless the `skipReturningDelegate` option is provided.\n     *\n     * If the authority token\n     * @param tcx - transaction context\n     * @public\n     **/\n    async txnGrantAuthority<TCX extends StellarTxnContext>(\n        tcx: TCX,\n        redeemer?: isActivity,\n        options: GrantAuthorityOptions = {}\n    ) {\n        const label = `${this.constructor.name} authority`;\n        const useMinTv = true;\n        const authorityVal = this.tvAuthorityToken(useMinTv);\n        const { skipReturningDelegate, ifExists } = options;\n\n        const existing = tcx.hasAuthorityToken(authorityVal);\n        if (existing) {\n            const [existingInput, existingRedeemer] =\n                (\n                    (tcx.txb as any).spendingRedeemers as [TxInput, UplcData][]\n                ).find(([inp, _redeemer]) =>\n                    inp.value.isGreaterOrEqual(authorityVal)\n                ) || ([] as any as [TxInput, UplcData]);\n            if (ifExists) {\n                ifExists(existingInput, existingRedeemer);\n                // unreachable, but prevents a \" | void\" type alternative for the function\n                return tcx;\n            }\n\n            throw this.existingRedeemerError(\n                label,\n                authorityVal,\n                existingRedeemer\n            );\n        }\n\n        const uutxo = await this.DelegateMustFindAuthorityToken(tcx, label);\n        console.log(\n            `   ------- delegate '${label}' grants authority with ${dumpAny(\n                authorityVal,\n                this.networkParams\n            )}`\n        );\n\n        try {\n            const tcx2 = await this.DelegateAddsAuthorityToken(\n                tcx,\n                uutxo,\n                redeemer\n            );\n            if (skipReturningDelegate) return tcx2;\n            return this.txnReceiveAuthorityToken(tcx2, authorityVal, uutxo);\n        } catch (error: any) {\n            if (error.message.match(/input already added/)) {\n                throw new Error(\n                    `Delegate ${label}: already added: ${dumpAny(\n                        authorityVal,\n                        this.networkParams\n                    )}`\n                );\n            }\n            throw error;\n        }\n    }\n\n    /**\n     * Finds the authority token and adds it to the transaction, tagged for retirement\n     * @public\n     * @remarks\n     * Doesn't return the token back to the contract.\n     **/\n    async txnRetireAuthorityToken<TCX extends StellarTxnContext>(tcx: TCX) {\n        const uutxo = await this.DelegateMustFindAuthorityToken(\n            tcx,\n            `${this.constructor.name} authority`\n        );\n        return this.DelegateRetiresAuthorityToken(tcx, uutxo);\n    }\n\n    /**\n     * Standard delegate method for receiving the authority token as a txn output\n     * @remarks\n     *\n     * creates a UTxO / TxOutput, depositing the indicated token-name into the delegated destination.\n     *\n     * Each implemented subclass can use it's own style to match its strategy & mechanism,\n     * and is EXPECTED to use tcx.addOutput() to receive the indicated `tokenValue` into the\n     * contract or other destination address.\n     *\n     * This method is used both for the original deposit and for returning the token during a grant-of-authority.\n     *\n     * Impls should normally preserve the datum from an already-present sourceUtxo, possibly with evolved details.\n     *\n     * @param tcx - transaction-context\n     * @param tokenValue - the Value of the token that needs to be received.  Always includes\n     *   the minUtxo needed for this authority token\n     * @param fromFoundUtxo - always present when the authority token already existed; can be\n     *   used to duplicate or iterate on an existing datum, or to include any additional Value in the new\n     *   UTxO, to match the previous UTxO with minimal extra heuristics\n     * @public\n     **/\n    abstract txnReceiveAuthorityToken<TCX extends StellarTxnContext>(\n        tcx: TCX,\n        tokenValue: Value,\n        // delegateAddr: Address,\n        fromFoundUtxo?: TxInput\n    ): Promise<TCX>;\n\n    mkAuthorityTokenPredicate() {\n        return this.uh.mkTokenPredicate(this.tvAuthorityToken());\n    }\n    get authorityTokenName() {\n        return this.configIn!.tn;\n    }\n\n    tvAuthorityToken(useMinTv: boolean = false) {\n        if (!this.configIn)\n            throw new Error(`must be instantiated with a configIn`);\n\n        const {\n            mph,\n            tn,\n            // reqdAddress,  // removed\n        } = this.configIn;\n        if (useMinTv) return this.uh.mkMinTv(mph, tn);\n        return mkTv(mph, tn);\n    }\n\n    get delegateValidatorHash(): ValidatorHash | undefined {\n        return undefined;\n    }\n\n    /**\n     * Finds the delegate authority token, normally in the delegate's contract address\n     * @public\n     * @remarks\n     *\n     * The default implementation finds the UTxO having the authority token\n     * in the delegate's contract address.\n     *\n     * @param tcx - the transaction context\n     * @reqt It MUST resolve and return the UTxO (a TxInput type ready for spending)\n     *  ... or throw an informative error\n     **/\n    abstract DelegateMustFindAuthorityToken(\n        tcx: StellarTxnContext,\n        label: string\n    ): Promise<TxInput>;\n\n    /**\n     * Adds the delegate's authority token to a transaction\n     * @public\n     * @remarks\n     * Given a delegate already configured by a Capo, this method implements\n     * transaction-building logic needed to include the UUT into the `tcx`.\n     * the `utxo` is discovered by {@link StellarDelegate.DelegateMustFindAuthorityToken | DelegateMustFindAuthorityToken() }\n     **/\n    abstract DelegateAddsAuthorityToken<TCX extends StellarTxnContext>(\n        tcx: TCX,\n        utxo: TxInput,\n        redeemer?: isActivity\n    ): Promise<TCX>;\n\n    /**\n     * Adds any important transaction elemements supporting the authority token being retired, closing the delegate contracts' utxo.\n     * @remarks\n     *\n     * EXPECTS to receive a Utxo having the result of txnMustFindAuthorityToken()\n     *\n     * EXPECTS the `burn` instruction to be separately added to the transaction.\n     *\n     * The default implementation uses the conventional `Retiring` activity\n     * to spend the token.\n     *\n     * @reqt\n     * It MUST add the indicated utxo to the transaction as an input\n     *\n     * @reqt\n     * When backed by a contract:\n     *   * it should use an activity/redeemer allowing the token to be spent\n     *      **and NOT returned**.\n     *   * the contract script SHOULD ensure any other UTXOs it may also hold, related to this delegation,\n     *      do not become inaccessible as a result.\n     *\n     * It MAY enforce additional requirements and/or block the action.\n     *\n     *\n     * @param tcx - transaction context\n     * @param fromFoundUtxo - the utxo having the authority otken\n     * @public\n     **/\n    abstract DelegateRetiresAuthorityToken<TCX extends StellarTxnContext>(\n        tcx: TCX,\n        fromFoundUtxo: TxInput\n    ): Promise<TCX>;\n\n    /**\n     * Captures requirements as data\n     * @remarks\n     *\n     * see reqts structure\n     * @public\n     **/\n    delegateRequirements() {\n        return hasReqts({\n            \"provides an interface for providing arms-length proof of authority to any other contract\":\n                {\n                    purpose:\n                        \"to decouple authority administration from its effects\",\n                    details: [\n                        \"Any contract can create a UUT for use with an authority policy.\",\n                        \"By depositing that UUT to the authority contract, it can delegate completely\",\n                        \"  ... all the implementation details for administration of the authority itself.\",\n                        \"It can then focus on implementing the effects of authority, requiring only \",\n                        \"  ... that the correct UUT has been spent, to indicate that the authority is granted.\",\n                        \"The authority contract can have its own internal details \",\n                        \"A subclass of this authority policy may provide additional administrative dynamics.\",\n                    ],\n                    mech: [],\n                    requires: [\n                        \"implementations SHOULD positively govern spend of the UUT\",\n                        \"implementations MUST provide an essential interface for transaction-building\",\n                    ],\n                },\n\n            \"implementations SHOULD positively govern spend of the UUT\": {\n                purpose: \"for sufficient assurance of desirable safeguards\",\n                details: [\n                    \"A subclass of the GenericAuthority should take care of guarding the UUT's spend\",\n                    \"  ... in whatever way is appropriate for its use-case\",\n                ],\n                mech: [],\n                requires: [],\n            },\n\n            \"implementations MUST provide an essential interface for transaction-building\":\n                {\n                    purpose:\n                        \"enabling a strategy-agnostic interface for making transactions using any supported strategy-variant\",\n                    details: [\n                        \"Subclasses MUST implement the interface methods\",\n                        \"  ... in whatever way is good for its use-case.\",\n                        \"An interface method whose requirement is marked with 'MAY/SHOULD' behavior, \",\n                        \"  ... MUST still implement the method satisfying the interface, \",\n                        \"  ... but MAY throw an UnsupportedAction error, to indicate that\",\n                        \"  ... the strategy variant has no meaningful action to perform \",\n                        \"  ... that would serve the method's purpose\",\n                    ],\n                    mech: [],\n                    requires: [\n                        //!!! todo: cross-check these requirements for completeness\n                        //  ... and for accuracy\n                        \"requires a txnReceiveAuthorityToken(tcx, delegateAddr, fromFoundUtxo?)\",\n                        \"requires a mustFindAuthorityToken(tcx)\",\n                        \"requires a txnGrantAuthority(tcx, delegateAddr, fromFoundUtxo)\",\n                        \"requires txnRetireCred(tcx, fromFoundUtxo)\",\n                    ],\n                },\n\n            \"requires a txnReceiveAuthorityToken(tcx, delegateAddr, fromFoundUtxo?)\":\n                {\n                    purpose:\n                        \"to deposit the authority token (back) to the delegated destination\",\n                    details: [\n                        \"impls MUST implement txnReceiveAuthorityToken\",\n                        \"Each implemented subclass can use it's own style to match its strategy & mechanism\",\n                        \"This is used both for the original deposit and for returning the token during a grant-of-authority\",\n                    ],\n                    mech: [\n                        \"impls MUST create a UTxO depositing the indicated token-name into the delegated destination.\",\n                        \"impls should normally preserve the datum from an already-present sourceUtxo\",\n                    ],\n                    requires: [],\n                },\n\n            \"requires a mustFindAuthorityToken(tcx)\": {\n                purpose: \"to locate the given authority token\",\n                details: [\n                    \"allows different strategies for finding the UTxO having the authority token\",\n                    \"impls MAY use details seen in the txn context to find the indicated token\",\n                ],\n                mech: [\n                    \"impls MUST resolve the indicated token to a specific UTxO or throw an informative error\",\n                ],\n            },\n\n            \"requires a txnGrantAuthority(tcx, delegateAddr, fromFoundUtxo)\": {\n                purpose: \"to use the delegated authority\",\n                details: [\n                    \"Adds the indicated utxo to the transaction with appropriate activity/redeemer\",\n                    \"Contracts needing the authority within a transaction can rely on the presence of this spent authority\",\n                    \"Impls can EXPECT the token will be returned via txnReceiveAuthorityToken\",\n                    \"a contract-backed impl SHOULD enforce the expected return in its on-chain code\",\n                ],\n                mech: [\n                    \"the base AuthorityPolicy MUST call txnReceiveAuthorityToken() with the token's sourceUtxo\",\n                ],\n            },\n\n            \"requires txnRetireCred(tcx, fromFoundUtxo)\": {\n                purpose: \"to allow burning the authority token\",\n                details: [\n                    \"Adds the indicated utxo to the transaction with appropriate activity/redeemer\",\n                    \"  ... allowing the token to be burned by the minting policy.\",\n                    \"Impls SHOULD ensure any other UTXOs it may hold do not become inaccessible as a result\",\n                ],\n                mech: [\n                    \"impls MUST add the token to the txn if it can be retired\",\n                    \"if the token cannot be retired, by appropriate policy, it SHOULD throw an informative error\",\n                ],\n            },\n        });\n    }\n}\n","import { makeTxInput, makeTxOutput } from \"@helios-lang/ledger\";\nimport type {\n    Value,\n    TxOutputId,\n    TxInput,\n    ValidatorHash,\n} from \"@helios-lang/ledger\";\nimport type { Capo } from \"../Capo.js\";\nimport type {\n    DelegateSetupWithoutMintDelegate,\n    MinimalDelegateLink,\n    MintUutActivityArgs,\n    NormalDelegateSetup,\n    hasCharterRef,\n} from \"../CapoTypes.js\";\nimport type {\n    mustFindActivityType,\n    mustFindConcreteContractBridgeType,\n    mustFindDatumType,\n    mustFindReadDatumType,\n} from \"../helios/dataBridge/BridgeTypes.js\";\nimport type {\n    GenericDelegateBridge,\n    GenericDelegateBridgeClass,\n    GenericDelegateDatum,\n} from \"./GenericDelegateBridge.js\";\n\nimport {\n    Activity,\n    datum,\n    type PartialStellarBundleDetails,\n} from \"../StellarContract.js\";\nimport { StellarDelegate } from \"./StellarDelegate.js\";\nimport type {\n    DelegationDetail,\n    capoDelegateConfig,\n} from \"./RolesAndDelegates.js\";\nimport { StellarTxnContext } from \"../StellarTxnContext.js\";\nimport type { CapoDelegateBundle } from \"../helios/scriptBundling/CapoDelegateBundle.js\";\nimport type { isActivity } from \"../ActivityTypes.js\";\n\nimport { bytesToText, textToBytes } from \"../HeliosPromotedTypes.js\";\nimport type { IFISNEVER } from \"../helios/typeUtils.js\";\nimport {\n    placeholderSetupDetails,\n    type HeliosScriptBundle,\n} from \"../helios/index.js\";\n\n/**\n * Base class for delegates controlled by a smart contract, as opposed\n * to a simple delegate backed by an issued token, whose presence\n * grants delegated authority.\n * @public\n */\nexport class ContractBasedDelegate extends StellarDelegate {\n    /**\n     * Each contract-based delegate must define its own dataBridgeClass, but they all\n     * use the same essential template for the outer layer of their activity & datum interface.\n     */\n    declare dataBridgeClass: GenericDelegateBridgeClass;\n    declare _dataBridge: GenericDelegateBridge;\n\n    /**\n     * Configures the matching parameter name in the on-chain script, indicating\n     * that this delegate serves the Capo by enforcing policy for spending the Capo's utxos.\n     * @remarks\n     * Not used for any mint delegate.  Howeever, a mint delegate class can instead provide a true isMintAndSpendDelegate,\n     *...  if a single script controls both the mintDgt-* and spendDgt-* tokens/delegation roles for your Capo.\n     *\n     * DO NOT enable this attribute for second-level delegates, such as named delegates or delegated-data controllers.\n     * The base on-chain delegate script recognizes this conditional role and enforces that its generic delegated-data activities\n     * are used only in the context the Capo's main spend delegate, re-delegating to the data-controller which\n     * can't use those generic activities, but instead implements its user-facing txns as variants of its SpendingActivities enum.\n     */\n    static isSpendDelegate = false;\n\n    get delegateName(): string {\n        throw new Error(\n            `${this.constructor.name}: missing required get delegateName() : string`\n        );\n    }\n\n    _scriptBundle: HeliosScriptBundle | undefined;\n    async mkScriptBundle(\n        setupDetails: PartialStellarBundleDetails<any> = placeholderSetupDetails\n    ) {\n        if (this._scriptBundle) return this._scriptBundle;\n\n        const bundle = await super.mkScriptBundle(setupDetails);\n        if (bundle.isConcrete) return (this._scriptBundle = bundle);\n\n        const bundleClass = await this.scriptBundleClass();\n        const myCapoBundle = await this.capo!.mkScriptBundle();\n        const capoBoundBundle = bundleClass.usingCapoBundleClass(\n            myCapoBundle.constructor as any\n        );\n        return (this._scriptBundle = capoBoundBundle.create({\n            params: this.configIn,\n            ...setupDetails,\n            setup: this.setup,\n        }));\n    }\n\n    get onchain(): mustFindConcreteContractBridgeType<this> {\n        return this.getOnchainBridge() as any;\n    }\n\n    get offchain(): mustFindConcreteContractBridgeType<this>[\"reader\"] {\n        return super.offchain as any;\n    }\n\n    get reader(): mustFindConcreteContractBridgeType<this>[\"reader\"] {\n        return super.offchain as any;\n    }\n\n    get activity(): mustFindActivityType<this> {\n        const bridge = this.onchain;\n        return bridge.activity as any;\n    }\n\n    get mkDatum(): mustFindDatumType<this> {\n        return this.onchain.datum;\n    }\n\n    get newReadDatum(): mustFindReadDatumType<this> {\n        // & ( (d: UplcData) => CapoDatumLike ) {\n        const bridge = this.getOnchainBridge();\n        //x@ts-expect-error probing for presence\n        const { readDatum } = bridge;\n        if (!readDatum) {\n            throw new Error(\n                `${\n                    (this as any).constructor.name\n                }: this contract script doesn't use datum`\n            );\n        }\n\n        return readDatum as any;\n    }\n\n    get capo(): Capo<any, any> {\n        return (this.configIn || this.partialConfig)?.capo as unknown as Capo<\n            any,\n            any\n        >;\n    }\n\n    // mkBundleWithCapo<T extends HeliosScriptBundle>(BundleClass: new (capo: CapoHeliosBundle) => T) : T {\n    //     const { capo } = this.configIn || this.partialConfig || {};\n    //     if (!capo)\n    //         throw new Error(\n    //             `missing capo in config or partial-config for ${this.constructor.name}`\n    //         );\n    //     const capoBundle = capo.getBundle() as CapoHeliosBundle;\n    //     return new BundleClass(capoBundle);\n    // }\n\n    async scriptBundleClass(): Promise<typeof CapoDelegateBundle> {\n        throw new Error(\n            `${this.constructor.name}: missing required implementation of scriptBundle()\\n` +\n                `\\nEach contract-based delegate must provide a scriptBundle() method.\\n` +\n                `It should return an instance of a class defined in a *.hlb.ts file.  At minimum:\\n\\n` +\n                `    import {YourAppCapo} from \"./YourAppCapo.js\";\\n\\n` +\n                `    import SomeSpecializedDelegate from \"./YourSpecializedDelegate.hl\";\\n\\n` +\n                `    export default class SomeDelegateBundle extends CapoDelegateBundle.using(YourAppCapo) {\\n` +\n                `        specializedDelegateModule = SomeSpecializedDelegate; \\n` +\n                `    }\\n\\n` +\n                `We'll generate an additional .typeInfo.d.ts, based on the types in your Helios sources,\\n` +\n                `  ... and a .bridge.ts with generated data-conversion code for bridging between off-chain` +\n                `  ... and on-chain data encoding.` +\n                `Your scriptBundle() method can \\`return new SomeDelegateBundle()\\``\n        );\n    }\n\n    get scriptDatumName() {\n        return \"DelegateDatum\";\n    }\n\n    get scriptActivitiesName() {\n        return \"DelegateActivity\";\n    }\n\n    static isMintDelegate = false;\n    static isMintAndSpendDelegate = false;\n    static isDgDataPolicy = false;\n\n    static get defaultParams() {\n        const params = {\n            rev: 0n,\n            isMintDelegate: this.isMintDelegate,\n            isSpendDelegate: this.isMintAndSpendDelegate,\n            isDgDataPolicy: this.isDgDataPolicy,\n        };\n        return params;\n    }\n    static mkDelegateWithArgs(a: capoDelegateConfig) {}\n\n    getContractScriptParams(config: capoDelegateConfig) {\n        const { capoAddr, mph, tn, capo, ...otherConfig } = config;\n\n        return {\n            ...otherConfig,\n            delegateName: this.delegateName,\n        };\n    }\n\n    tcxWithCharterRef<TCX extends StellarTxnContext | hasCharterRef>(tcx: TCX) {\n        return this.capo.tcxWithCharterRef(tcx);\n    }\n\n    /**\n     * Adds a mint-delegate-specific authority token to the txn output\n     * @remarks\n     *\n     * Implements {@link StellarDelegate.txnReceiveAuthorityToken | txnReceiveAuthorityToken() }.\n     *\n     * Uses {@link ContractBasedDelegate.mkDelegationDatum | mkDelegationDatum()} to make the inline Datum for the output.\n     * @see {@link StellarDelegate.txnReceiveAuthorityToken | baseline txnReceiveAuthorityToken()'s doc }\n     * @public\n     **/\n    async txnReceiveAuthorityToken<TCX extends StellarTxnContext>(\n        tcx: TCX,\n        tokenValue: Value,\n        fromFoundUtxo?: TxInput\n    ): Promise<TCX> {\n        const datum = this.mkDelegationDatum(fromFoundUtxo);\n\n        const newOutput = makeTxOutput(this.address, tokenValue, datum);\n        // const separator = `     -----`;\n        // console.log(\n        //     `${separator} delegate script receiving dgTkn\\n${separator} ${dumpAny(\n        //         newOutput\n        //     )}` // ${dumpAny(tokenValue)} at ${dumpAny(addr)} = ${addr.toBech32()}`\n        // );\n        // const ffu = fromFoundUtxo;\n        // const v : Value = ffu?.value || this.mkMinAssetValue(this.configIn!.uut);\n        return tcx.addOutput(newOutput);\n    }\n\n    mkDelegationDatum(txin?: TxInput) {\n        if (txin) return txin.output.datum!;\n        const { capoAddr, mph, tn, ..._otherCfgSettings } = this.configIn!;\n\n        return this.mkDatum.IsDelegation({\n            capoAddr,\n            mph,\n            tn,\n        });\n    }\n\n    /**\n     * redeemer for replacing the authority UUT with a new one\n     * @remarks\n     *\n     * When replacing the delegate, the current UUT will be burned,\n     * and a new one will be minted.  It can be deposited to any next delegate address.\n     *\n     * @param seedTxnDetails - seed details for the new UUT\n     * @public\n     **/\n    @Activity.redeemer\n    activityReplacingMe({\n        seed,\n        purpose,\n    }: Omit<MintUutActivityArgs, \"purposes\"> & { purpose: string }) {\n        throw new Error(`deprecated: explicit activity helper`);\n\n        // return this.mkDelegateLifecycleActivity(\"ReplacingMe\", {\n        //     seed,\n        //     purpose,\n        // });\n    }\n\n    mkDelegateLifecycleActivity(\n        delegateActivityName: \"ReplacingMe\" | \"Retiring\" | \"ValidatingSettings\",\n        args?: Record<string, any>\n    ): isActivity {\n        throw new Error(`deprecated: explicit activity helper`);\n\n        // try {\n        //     return this.activityRedeemer(\"DelegateLifecycleActivities\", {\n        //         activity: { [delegateActivityName]: args },\n        //     });\n        // } catch (e: any) {\n        //     // warning emoji: \"‚ö†Ô∏è\"\n        //     e.message =\n        //         \"‚ö†Ô∏è ‚ö†Ô∏è ‚ö†Ô∏è error constructing delegate lifecycle activity.  You might need \" +\n        //         \"to format the args as UplcData if the enum doesn't recognize a valid off-chain type.\\nDelegate lifecycle activity: \" +\n        //         e.message;\n        //     throw e;\n        // }\n    }\n\n    mkCapoLifecycleActivity(\n        capoLifecycleActivityName: \"CreatingDelegate\" | \"ActivatingDelegate\",\n        {\n            seed,\n            purpose,\n            ...otherArgs\n        }: Omit<MintUutActivityArgs, \"purposes\"> & { purpose?: string }\n    ): isActivity {\n        throw new Error(`deprecated: explicit activity helper`);\n\n        // return this.activityRedeemer(\"CapoLifecycleActivities\", {\n        //     activity: {\n        //         [capoLifecycleActivityName]: { seed, purpose, ...otherArgs },\n        //     },\n        // });\n    }\n\n    /**\n     * Creates a reedemer for the indicated spending activity name\n     **/\n    mkSpendingActivity(\n        spendingActivityName: string,\n        args: { id: string | number[] } & Record<string, any>\n    ): isActivity {\n        throw new Error(`deprecated: explicit activity helper`);\n\n        // try {\n        //     let id : number[] = (\"string\" == typeof args.id) ?\n        //         textToBytes(args.id as string) : args.id as number[];\n\n        //         // TODO: require that the on-chain type have first field = 'id', not 'recId' or whatever\n        //     return this.activityRedeemer(\"SpendingActivities\", {\n        //         activity: {\n        //             [spendingActivityName]: { ...args, id },\n        //         },\n        //     });\n        // } catch (e: any) {\n        //     // warning emoji: \"‚ö†Ô∏è\"\n        //     e.message =\n        //         \"‚ö†Ô∏è ‚ö†Ô∏è ‚ö†Ô∏è error constructing spending activity: \" + e.message;\n        //     throw e;\n        // }\n    }\n\n    mkSeedlessMintingActivity(\n        mintingActivityName: string,\n        args: Record<string, any>\n    ): isActivity {\n        const { MintingActivity } = this.onChainTypes;\n        const NestedVariant = this.mustGetEnumVariant(\n            MintingActivity,\n            mintingActivityName\n        );\n        throw new Error(`mkSeedlessMintingActivity: deprecated`);\n        // debugger; // ??? vvv\n        // //@ts-ignore !!!!\n        // const nestedVarSt = NestedVariant.prototype._enumVariantStatement;\n        // const firstActivityField =\n        //     nestedVarSt.dataDefinition.fields[0].name.value;\n        // if (\"seed\" === firstActivityField) {\n        //     throw new Error(\n        //         `Minting activity '${mintingActivityName}' requires a seed üçâ. \\n` +\n        //             `   ... therefore, you must use mkSeededMintingActivity() instead.`\n        //     );\n        // }\n        // if (args.seed) {\n        //     throw new Error(\n        //         `mkSeedlessMintingActivity: found unexpected 'seed' field in seedless MintingActivity variant!\\n` +\n        //             `  üçâ ... if this minting activity actually needs a seed, you'd need to adjust its on-chain type definition.` +\n        //             `  ... a seed provides guaranteed uniqueness for minting e.g. a UUT. ` +\n        //             `  ... e.g.minting only fungible tokens doesn't require a seed`\n        //     );\n        // }\n\n        // try {\n        //     return this.activityRedeemer(\"MintingActivities\", {\n        //         activity: { [mintingActivityName]: args },\n        //     });\n        // } catch (e: any) {\n        //     // warning emoji: \"‚ö†Ô∏è\"\n        //     e.message =\n        //         \"‚ö†Ô∏è ‚ö†Ô∏è ‚ö†Ô∏è error constructing minting activity.  You might need \" +\n        //         \"to format the args as UplcData if the enum doesn't recognize a valid off-chain type.\\nMinting activity: \" +\n        //         e.message;\n        //     throw e;\n        // }\n    }\n\n    mkSeededMintingActivity(\n        mintingActivityName: string,\n        args: { seed: TxOutputId } & Record<string, any>\n    ): isActivity {\n        const { MintingActivity } = this.onChainTypes;\n        const NestedVariant = this.mustGetEnumVariant(\n            MintingActivity,\n            mintingActivityName\n        );\n        throw new Error(`mkSeededMintingActivity: deprecated`);\n        // if (!NestedVariant) {\n        //     throw new Error(\n        //         `mkSeededMintingActivity: missing MintingActivity variant '${mintingActivityName}'`\n        //     );\n        // }\n        // // const nestedVarSt = NestedVariant.prototype._enumVariantStatement;\n        // const firstActivityField = NestedVariant.fieldNames[0];\n        // // nestedVarSt.dataDefinition.fields[0].name.value;\n        // if (\"seed\" !== firstActivityField) {\n        //     throw new Error(\n        //         `Minting activity '${mintingActivityName}' is not a seeded activity.  \\n` +\n        //             `   ... therefore, you must use mkSeedlessMintingActivity() instead.  üçâ`\n        //     );\n        // }\n        // if (!args.seed) {\n        //     throw new Error(\n        //         `mkSeedlessMintingActivity: missing required 'seed' field in MintingActivity variant!\\n` +\n        //             `  üçâ ... if this minting activity doesn't actually need a seed, you'd need to adjust its on-chain type definition.` +\n        //             `  ... a seed provides guaranteed uniqueness for minting e.g. a UUT. ` +\n        //             `  ... e.g., minting only fungible tokens doesn't require a seed`\n        //     );\n        // }\n\n        // try {\n        //     return this.activityRedeemer(\"MintingActivities\", {\n        //         activity: { [mintingActivityName]: args },\n        //     });\n        // } catch (e: any) {\n        //     // warning emoji: \"‚ö†Ô∏è\"\n        //     e.message =\n        //         \"‚ö†Ô∏è ‚ö†Ô∏è ‚ö†Ô∏è error constructing minting activity.  You might need \" +\n        //         \"to format the args as UplcData if the enum doesn't recognize a valid off-chain type.\\nMinting activity: \" +\n        //         e.message;\n        //     throw e;\n        // }\n    }\n\n    /**\n     * redeemer for spending the authority UUT for burning it.\n     * @public\n     * @remarks\n     *\n     * The Retiring redeemer indicates that the delegate is being\n     * removed.\n     *\n     **/\n    @Activity.redeemer\n    activityRetiring() {\n        throw new Error(`deprecated: explicit activity helper`);\n\n        // return this.mkDelegateLifecycleActivity(\"Retiring\");\n    }\n\n    @Activity.redeemer\n    activityValidatingSettings() {\n        throw new Error(`deprecated: explicit activity helper`);\n\n        // return this.mkDelegateLifecycleActivity(\"ValidatingSettings\");\n    }\n\n    // @Activity.redeemer\n    activityMultipleDelegateActivities(\n        ...activities: isActivity[]\n    ): isActivity {\n        throw new Error(`deprecated: explicit activity helper`);\n        // return this.activityRedeemer(\"MultipleDelegateActivities\", {\n        //     // todo: allow the cast to take already-uplc'd data\n        //     activities: activities.map((a) => a.redeemer),\n        // });\n    }\n\n    // /**\n    //  * A spend-delegate activity indicating that a delegated-data controller will be governing\n    //  * an update to a specific piece of delegated data.  No further redeemer details are needed here,\n    //  * but the data-delegate's controller-token may have additional details in ITS redeemer,\n    //  * which will be aligned with the one.\n    //  *\n    //  * May be present in the context of a nested MultipleDelegateActivities redeemer, in which\n    //  * case, multiple cases of the above scenario will be present in a single transaction.\n    //  */\n    // @Activity.redeemer\n    // activityUpdatingDelegatedData(\n    //     recId: string | number[]\n    // ): isActivity {\n    //     const recIdBytes = Array.isArray(recId)\n    //         ? recId\n    //         : textToBytes(recId);\n    //     // const Activity = this.mustGetActivity(\"UpdatingDelegatedData\");\n\n    //     // this.activity.DeletingDelegatedData\n\n    //     return {\n    //         // redeemer: new Activity(uutPurpose, recIdBytes),\n    //         redeemer: this.activityVariantToUplc(\"UpdatingDelegatedData\", {\n    //             recId: recIdBytes,\n    //         }),\n    //     };\n    // }\n\n    /**\n     * A mint-delegate activity indicating that a delegated-data controller will be governing\n     * a deletion (burning its UUT) of a specific piece of delegated data.  No further redeemer details are needed here,\n     * but the data-delegate's controller-token may have additional details in ITS redeemer,\n     */\n    @Activity.redeemer\n    activityDeletingDelegatedData(recId: string | number[]): isActivity {\n        throw new Error(`deprecated: explicit activity helper`);\n\n        // const recIdBytes = Array.isArray(recId)\n        //     ? recId\n        //     : textToBytes(recId);\n\n        //     return {\n        //     redeemer: this.activityVariantToUplc(\"DeletingDelegatedData\", {\n        //         recId: recIdBytes,\n        //     }),\n        // };\n    }\n\n    /**\n     * creates the essential datum for a delegate UTxO\n     * @remarks\n     *\n     * Every delegate is expected to have a two-field 'IsDelegation' variant\n     * in the first position of its on-chain Datum type.  This helper method\n     * constructs a suitable UplcData structure, given appropriate inputs.\n     * @param dd - Delegation details\n     * @public\n     **/\n    @datum\n    mkDatumIsDelegation(dd: DelegationDetail) {\n        const { DelegationDetail } = this.onChainTypes;\n        throw new Error(`deprecated: explicit datum helper`);\n\n        // const schema = DelegationDetail.toSchema()\n        // const cast = new Cast(schema, {\n        //     isMainnet: this.setup.isMainnet || false\n        // });\n        return this.inlineDatum(\"IsDelegation\", { dd });\n    }\n\n    /**\n     * returns the ValidatorHash of the delegate script, if relevant\n     * @public\n     * @remarks\n     *\n     * A delegate that doesn't use an on-chain validator should override this method and return undefined.\n     **/\n    get delegateValidatorHash(): ValidatorHash | undefined {\n        if (!this.usesContractScript) {\n            throw new Error(\n                `${this.constructor.name}: address doesn't use a validator hash!\\n` +\n                    `  ... if that's by design, you may wish to override 'get delegateValidatorHash()'`\n            );\n        }\n        return this.validatorHash;\n    }\n\n    /**\n     * @see {@link StellarDelegate.DelegateMustFindAuthorityToken|DelegateMustFindAuthorityToken()}\n     **/\n    async DelegateMustFindAuthorityToken(\n        tcx: StellarTxnContext,\n        label: string\n    ): Promise<TxInput> {\n        return this.mustFindMyUtxo(\n            `${label}: ${bytesToText(this.configIn!.tn)}`,\n            {\n                predicate: this.uh.mkTokenPredicate(this.tvAuthorityToken()),\n                extraErrorHint:\n                    \"this delegate strategy might need to override txnMustFindAuthorityToken()\",\n            }\n        );\n    }\n\n    /**\n     * Adds the delegate's authority token to a transaction\n     * @public\n     * @remarks\n     * Given a delegate already configured by a Capo, this method implements\n     * transaction-building logic needed to include the UUT into the `tcx`.\n     * the `utxo` is discovered by {@link StellarDelegate.DelegateMustFindAuthorityToken | DelegateMustFindAuthorityToken() }\n     *\n     * The off-chain code shouldn't need to check the details; it can simply\n     * arrange the details properly and spend the delegate's authority token,\n     * using this method.\n     *\n     * ### Reliance on this delegate\n     *\n     * Other contract scripts can rely on the delegate script to have validated its\n     * on-chain policy and enforced its own \"return to the delegate script\" logic.\n     *\n     * ### Enforcing on-chain policy\n     *\n     * When spending the authority token in this way, the delegate's authority is typically\n     * narrowly scoped, and it's expected that the delegate's on-chain script validates that\n     * those parts of the transaction detail should be authorized, in accordance with the\n     * delegate's core purpose/responsbility - i.e. that the txn does all of what the delegate\n     * expects, and none of what it shouldn't do in that department.\n     *\n     * The on-chain code SHOULD typically enforce:\n     *  * that the token is spent with an application-specific redeemer variant of its\n     *     MintingActivity or SpendingActivitie.\n     *\n     *  * that the authority token is returned to the contract with its datum unchanged\n     *  * that any other tokens it may also hold in the same UTxO do not become\n     *     inaccessible as a result of the transactions - perhaps by requiring them to be\n     *     returned together with the authority token.\n     *\n     * It MAY enforce additional requirements as well.\n     *\n     * @example\n     * A minting delegate should check that all the expected tokens are\n     * minted, AND that no other tokens are minted.\n     *\n     * @example\n     * A role-based authentication/signature-checking delegate can\n     * require an appropriate signature on the txn.\n     *\n     * @param tcx - the transaction context\n     * @param utxo - the utxo having the authority UUT for this delegate\n     * @reqt Adds the uutxo to the transaction inputs with appropriate redeemer.\n     * @reqt Does not output the value; can EXPECT txnReceiveAuthorityToken to be called for that purpose.\n     **/\n    async DelegateAddsAuthorityToken<TCX extends StellarTxnContext>(\n        tcx: TCX,\n        utxo: TxInput,\n        redeemer: isActivity\n    ): Promise<TCX> {\n        const { capo } = this.configIn!;\n\n        // when there is a delegate upgrade in progress, we must\n        // use the previous script, not the next script, to locate\n        // the authority token.\n\n        const script =\n            this._bundle?.previousCompiledScript() ||\n            (await this.asyncCompiledScript());\n        const tcx2 = await capo.txnAttachScriptOrRefScript(tcx, script);\n        if (!redeemer.redeemer) debugger;\n        return tcx2.addInput(utxo, redeemer);\n\n        // return this.txnKeepValue(\n        //     tcx,\n        //     uutxo.value,\n        //     uutxo.origOutput.datum as InlineDatum\n        // );\n    }\n\n    /**\n     * {@inheritdoc StellarDelegate.DelegateAddsAuthorityToken}\n     **/\n\n    async DelegateRetiresAuthorityToken<TCX extends StellarTxnContext>(\n        this: ContractBasedDelegate,\n        tcx: StellarTxnContext,\n        fromFoundUtxo: TxInput\n    ): Promise<TCX> {\n        const utxo = fromFoundUtxo;\n\n        return tcx.addInput(\n            makeTxInput(utxo.id, utxo.output),\n            this.activity.DelegateLifecycleActivities.Retiring\n        ) as TCX;\n    }\n}\n\n/**\n * @public\n */\nexport type NamedPolicyCreationOptions<\n    thisType extends Capo<any>,\n    DT extends StellarDelegate\n> = PolicyCreationOptions & {\n    /**\n     * Optional name for the UUT; uses the delegate name if not provided.\n     **/\n    uutName?: string;\n};\n// MinimalDelegateLink<DT> & {\n//     uutOptions: UutCreationAttrs | ForcedUutReplacement\n//     strategyName: string &\n//     keyof thisType[\"delegateRoles\"][\"spendDelegate\"][\"variants\"];\n//     forcedUpdate?: true;\n// };\n\nexport type PolicyCreationOptions = MinimalDelegateLink & {\n    /**\n     * details for creating the delegate\n     */\n    mintSetup: NormalDelegateSetup | DelegateSetupWithoutMintDelegate;\n    // strategyName: string & STRATEGIES;\n    /**\n     * Installs the named delegate without burning the existing UUT for this delegate.\n     * That UUT may become lost and inaccessible, along with any of its minUtxo.\n     **/\n    forcedUpdate?: true;\n};\n"],"names":["datum","bytesToText"],"mappings":"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"}