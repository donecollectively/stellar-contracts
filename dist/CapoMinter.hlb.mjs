import { C as CapoHeliosBundle } from './CapoHeliosBundle2.mjs';
import { makeSource } from '@helios-lang/compiler-utils';
import { HeliosScriptBundle } from './HeliosBundle.mjs';
import './CapoDelegateHeliosBundle.mjs';
import './DefaultCapo.mjs';
import '@helios-lang/ledger';
import '@helios-lang/uplc';
import '@donecollectively/stellar-contracts/HeliosProgramWithCacheAPI';
import '@helios-lang/compiler';
import '@helios-lang/codec-utils';
import '@helios-lang/crypto';
import '@helios-lang/contract-utils';
import './environment.mjs';

const CapoMinter_hl = makeSource(
  "minting CapoMinter\n\nimport {\n    tx, \n    get_current_input,\n    get_current_validator_hash,\n    get_current_minting_policy_hash,\n    get_cont_outputs\n} from ScriptContext\n\nimport { \n    hasSeedUtxo, \n    mkUutTnFactory,\n    requiresMintDelegateApproval,\n    validateUutMinting, \n    MinterActivity\n} from CapoMintHelpers\n\nimport {\n    CapoDatum,\n    CapoActivity,\n    getRefCharterUtxo,\n    mkCapoCtx\n} from CapoHelpers\n\nimport {\n    DgTknDisposition as DgTkn,\n    RelativeDelegateLink\n} from CapoDelegateHelpers\n\nimport {\n    mustFindInputRedeemer,\n    TRACE,\n    REQT,\n    logGroupUnit,\n    logGroupEnd,\n    logGroupStart,\n    logGroup,\n    REQTgroup,\n    TODO,\n    mkTv,\n    outputAndDatum,\n    tvCharter\n} from StellarHeliosHelpers\n\n// seed parameters provide uniqueness for the script validator hash:\nconst seedTxn : TxId = TxId::new(#1234)\nconst seedIndex : Int = 42\nconst rev : Int = 1\n\nfunc hasContractSeedUtxo(tx: Tx) -> Bool {\n    hasSeedUtxo(\n        reqt: \"the minter's unique seed-utxo MUST be spent\",\n        tx: tx, \n        seedUtxo: TxOutputId::new(seedTxn, seedIndex)\n    )\n}\n\nfunc main(r : MinterActivity) -> Bool {\n    mph: MintingPolicyHash = get_current_minting_policy_hash();\n    value_minted: Value = tx.minted;\n    assert(true || (/* never evaluated */ rev.serialize() == rev.serialize()), \"no\");\n    assert(true || (/* never evaluated */ seedTxn.serialize() == seedTxn.serialize()), \"no\");\n    print(\" ðŸš¥â“ Capo minter\");\n    print(\"  -- minter policy id: \" + get_current_minting_policy_hash().show());\n\n    ok : Bool = r.switch {\n        charter: mintingCharter => REQTgroup[Bool](reqt: \"Creates the capo charter\", \n        collapsed: false, callback: () -> Bool {\n            charterVal : Value = mkTv(mph: mph, tn: \"charter\");\n\n            // these must be sorted BY LENGTH FIRST, then lexicographically\n            //   (actually byte-wise, but ~same diff)\n            // settingsTnBase: String = \"set\";\n            authTnBase : String = \"capoGov\";\n            mintDgtTnBase : String = \"mintDgt\";\n            spendDgtTnBase: String = \"spendDgt\";\n            purposes = []String{\n                // settingsTnBase,\n                authTnBase, \n                mintDgtTnBase, \n                spendDgtTnBase\n            };\n            // settingsDgtTnBase: String = \"settingsDgt\"\n            // if (charter.withSettings) purposes = purposes + []String{ settingsDgtTnBase, \"settings\" }\n\n            minterSeed: TxOutputId = TxOutputId::new(seedTxn, seedIndex);\n            mkUutName: (String) -> String = mkUutTnFactory(\n                minterSeed  \n            );\n            REQT(reqt: \"the charter token MUST be minted\", \n                assertion: value_minted >= charterVal, \n                onError: \"charter token not minted\",\n                showSuccess: true\n            );\n            hasSeed: Bool = hasContractSeedUtxo(tx)\n            print (\"  -- mints the uuts for the Capo using the same seed\");\n            mintsUuts: Bool = validateUutMinting(\n                mph: mph,\n                seed: minterSeed,\n                purposes: purposes, \n                mkTokenName: mkUutName,\n                bootstrapCharter: charterVal\n            );\n            // charterOutput = REQTgroup(\n            charterOutput = REQTgroup[TxOutput](\n                reqt: \"the charter MUST be saved at the new Capo address\",\n                collapsed: false,\n                callback: () -> TxOutput {\n                    tx.outputs.find( (output: TxOutput) -> Bool {\n                        output.address == charter.owner &&\n                        output.value.contains(charterVal)\n                    })\n                }\n            )\n            // ^^ fails if there's no charter output to the right address\n\n            // print(\"defaultMinter @C\");\n            rawCharterData : Data = charterOutput.datum.inline;\n            charterData = CapoDatum::CharterData::from_data(rawCharterData);\n            CharterData{\n                spendDgt, \n                spendInvariants,\n                namedDelegates,\n                mintDgt, \n                mintInvariants, \n                authDgt,\n                manifest,\n                pendingDelegates\n            } = charterData;\n            // settings are not essential to a Capo.\n            // ... some Capos could use settings, and it would be\n            // ... up to its mint/spend delegate to enforce their presence.\n            // Also, their verification by other delegates, in case of updating\n            // the settings.  This gives settings a slightly special role,\n            // but much less than the special status they had when Settings\n            // were a separate datum type.\n\n            logGroupUnit(\n                group: \"validating charter data\", collapsed: true, \n                callback: () -> () {\n                    TODO(\"support initializing with some of these pre-defined:\");\n                    print(\"  -- empty mint invariants for now\");\n                    assert(mintInvariants.length == 0, \"TEMP: no mint invariants allowed at charter creation\");\n                    print(\"  -- empty spend invariants for now\");\n                    assert(spendInvariants.length == 0, \"TEMP: no spend invariants allowed at charter creation\");\n                    print(\"  -- empty manifest for now\");\n                    assert(manifest.length == 0, \"TEMP: no manifest entries allowed at charter creation\");\n                    print(\"  -- empty pending-delegate-actions for now\");\n                    assert(pendingDelegates.length == 0, \"TEMP: no pending-delegate-actions allowed at charter creation\");\n\n                    // named delegates are probably obsolete.\n                    assert(namedDelegates.length == 0, \"no named delegates allowed at charter creation\");\n                }\n            )\n\n            true \n            && hasSeed\n            && mintsUuts\n            && REQTgroup[Bool](reqt: \"the new charter MUST have mintDgt, spendDgt, and authDgt tokens, each at their respective destinations\",\n            collapsed: false, callback: () -> Bool {\n                true\n                    && authDgt.hasValidOutput(mph, true, DgTkn::Created) \n                    && mintDgt.hasValidOutput(mph, true, DgTkn::Created)\n                    && spendDgt.hasValidOutput(mph, true, DgTkn::Created)\n                    // check mark:\n                .trace(\"âœ… delegate tokens sent to their separate destinations\")\n    \n                // if (charter.withSettings) {\n                //     REQT(\"when 'withSettings' is true, there must be a settings-policy delegate created\");\n                //     assert(namedDelegates.length == 1, \"only settingsDgt allowed at charter creation\");\n                    \n                //     settingsDgt = namedDelegates.get_safe(\"settingsPolicy\").switch {\n                //         None => error(\"missing required named delegate 'settingsPolicy'\"),\n                //         Some{dgt} => dgt\n                //     };\n                //     settingsDgt.hasValidOutput(mph, true, DgTkn::Created)\n\n                //     REQT(\"with settings, there must be a settings datum stored in the Capo\");\n                //     cctx = mkCapoCtx(mph).nowMinting(charter.owner, charterOutput);\n                //     foundSettingsOutput : TxOutput = cctx.delegatedOutputData(\n                //         mkUutName(settingsTnBase)\n                //     );\n                \n                //     // tx.outputs.find_safe( (output: TxOutput) -> Bool {\n                //     //     output.address == charter.owner &&\n                //     //         output.value.contains(mkTv(mph: mph, tn: mkUutName(settingsTnBase))\n                //     // }).switch {\n                //     //     None => error(\"missing required settings data\"),\n                //     //     Some{output} => output\n                //     // };\n                                    \n                //     outputAndDatum[CapoDatum::DelegatedData] = \n                //         charterData.mustFindSettingsOutput(mph: mph, inAddr: charter.owner);\n                //     assert(foundSettings == foundSettings, \"no way, no\");\n\n                //     true\n                // } else { \n                //     assert(namedDelegates.length == 0, \"no named delegates allowed at charter creation\");\n                //     true\n                //  };\n    \n                }\n            )\n        }),\n\n        // ------------------------- MOST MINTING ACTIVITIES USE THIS CODE PATH --------------------\n        mintWithDelegateAuthorizing => {\n            print(\"mintWithDelegateAuthorizing\\n\");\n            requiresMintDelegateApproval(mph)\n            // -------------------------  ^^^ deferring to the Capo's current minting delegate --------------------\n        },\n        _ => {\n            cctx = mkCapoCtx(mph).withCharterInput();\n            r.switch {\n                mintingCharter => error(\"unreachable\"),\n                mintWithDelegateAuthorizing => error(\"unreachable\"),\n                addingMintInvariant{_seed} => {\n                    print(\"checking for addingMintInvariant\\n\");\n                    assert(false, \"should be handled by the mintDelegate!\");\n                    false\n                },\n\n                addingSpendInvariant{_seed} => {\n                    print(\"checking for addingSpendInvariant\\n\");\n                    assert(false, \"should be handled by the mintDelegate!\");\n                    false\n                },\n\n                forcingNewMintDelegate{seed} => {\n                    print(\"checking for forcingNewMintDelegate\\n\");\n                    badCharterActivity = \"when forcingNewMintDelegate, capo charter must be spent with its capoLifecycleActivity.forcingNewMintDelegate activity\";\n                    REQT(\"Ensures the Capo charter is also forcingNewMintDelegate\");\n                    cctx.getCharterRedeemer().switch {\n                        capoLifecycleActivity{activity} => activity.switch {\n                            forcingNewMintDelegate{seedToCapo, purpose} => {\n                                print(\"WARNING: capo lifecycle activity is forcing a new mint-delegate with its Escape-hatch activity\");\n                                print(\"NOTE: the normal lifecycle is to use minter:mintWithDelegateAuthorizing, \\n\"+\n                                    \"  ... which defers to the Capo's current minting delegate and allows \\n\"+\n                                    \"  ... queuePendingChange(role: MintDgt) to queue the new mint delegate for installation\"\n                                );\n                                REQT(\"Ensures the new mintDgt-* uut is minted with a seed\");\n                                assert(seed == seedToCapo, \"seed mismatch:\"+\n                                    \"\\n  - Capo activity seed: \"+seedToCapo.show()+\n                                    \"\\n  - Minter seed: \"+seed.show()\n                                );\n                                assert(\"mintDgt\" == purpose, \"wrong Capo purpose '\"+purpose+\"'; should be 'mintDgt'\");\n                                validateUutMinting(\n                                    mph: mph,\n                                    seed: seed,\n                                    purposes: []String{purpose},\n                                    // forcing the new dgt; don't involve the current mintDgt\n                                    needsMintDelegateApproval: false \n                                )\n                            }, \n                            _ => error(badCharterActivity)\n                            \n                            // queuePendingChange{capoActivitySeed, purpose, role, name} => {\n                            //     assert(purpose == \"mintDgt\", \"wrong purpose\");\n                            //     role.switch {\n                            //         MintDgt => {\n                            //             print(\"ok: capo lifecycle activity is adding a (pending) mint-delegate\");\n                            //             true\n                            //         }, \n                            //         _ => error(\"wrong role in capo lifecycle activity\")\n                            //     }\n                            // }\n                        },\n                        _ => error(badCharterActivity)\n                    }\n                },\n\n                CreatingNewSpendDelegate{seed, replaceExisting} => {\n                    print(\"checking for CreatingNewSpendDelegate\\n\");\n\n                    needsCapoForcedInstall = replaceExisting.switch {\n                        Some => false,\n                        None => true\n                    };\n\n                    otherMintedValue : Value = replaceExisting.switch {\n                        Some{oldTokenName} => {\n                            BURNED: Int = -1;\n                            Value::new(\n                                AssetClass::new(mph, oldTokenName), \n                                BURNED\n                            )\n                        },\n                        None => Value::ZERO\n                    };\n                    mkTokenName = mkUutTnFactory(seed);\n                    spendDgtTn = mkTokenName(\"spendDgt\");\n\n                    hasCapoApproval = if (!needsCapoForcedInstall) {\n                        cctx.getCharterRedeemer().switch {\n                            updatingCharter => {\n                                TODO(\"the minter should see that the new spend delegate is QUEUED for installation by the Capo\");\n                                TODO(\"this essential logic vvvv will move to the installation moment\");\n                                REQT(\"the updated charter must reference the new spend delegate\");\n                                RelativeDelegateLink{uutName, _dvh, _config} = cctx.getNextCharterData().spendDelegateLink;\n                                print(\"expected uutName: \"+uutName);\n                                print(\"spendDgtTn in charter: \"+spendDgtTn);\n                                assert(uutName == spendDgtTn, \"new spend delegate not referenced in updated charter\");\n                                \n                                REQT(\"EXPECTS the Capo to validate that only the one thing is updated, and that the new UUT is deposited where it's expected\");\n                                true\n                            },\n                            // capoLifecycleActivity{activity} => activity.switch {                                \n                            // queuePendingChange{capoActivitySeed, purpose, role, name} => {\n                            //     assert(!replaceExisting, \"queuePendingChange can't use replaceExisting option\");\n\n                            //     assert(purpose == \"spendDgt\", \"wrong purpose\");\n                            //     role.switch {\n                            //         SpendDgt => {\n                            //             print(\"ok: capo lifecycle activity is adding a (pending) spend-delegate\");\n                            //             true\n                            //         }, \n                            //         _ => error(\"wrong role in capo lifecycle activity\")\n                            //     }\n                            // },\n                            _ => error(\"capo charter must be spent with its updatingCharter activity\")\n                        }\n                    } else {\n                        REQT(\"When the old dgTkn isn't replaced, it ensures the Capo charter is also forcingNewSpendDelegate\");\n                        badCharterActivity = \"when forcingNewSpendDelegate, capo charter must be spent with its capoLifecycleActivity.forcingNewSpendDelegate activity\";\n                        cctx.getCharterRedeemer().switch {\n                            capoLifecycleActivity{activity} => activity.switch {\n                                forcingNewSpendDelegate{seedToCapo, purpose} => {\n                                    print(\"WARNING: capo lifecycle activity is forcing a spend-delegate with its Escape-hatch activity\");\n                                    print(\"NOTE: the normal lifecycle is to use minter:mintWithDelegateAuthorizing, \\n\"+\n                                        \"  ... which defers to the Capo's current minting delegate and allows \\n\"+\n                                        \"  ... queuePendingChange(role: SpendDgt) to queue the new spend delegate for installation\"\n                                    );\n\n                                    REQT(\"Ensures the Capo activity's seed matches the minter's seed\");\n                                    assert(seed == seedToCapo, \"seed mismatch: \"\n                                        + \"\\n  - Capo activity seed: \" + seedToCapo.show()\n                                        + \"\\n  - Minter seed: \" + seed.show()\n                                    );\n                                    assert(\"spendDgt\" == purpose, \"wrong Capo purpose '\"+purpose+\"'; should be 'spendDgt'\");\n                                    true\n                                },\n                                _ => error(badCharterActivity)\n                            },\n                            _ => error(badCharterActivity)\n                        }\n                    };\n\n                    REQT(\"Ensures the new spendDgt-* uut is uniquely minted using the seed\");\n                    didMintUuts = validateUutMinting(\n                        mph: mph,\n                        seed: seed,\n                        purposes: []String{ \"spendDgt\" },\n                        mkTokenName: mkTokenName,\n                        otherMintedValue: otherMintedValue,\n                        // forcing the new dgt; don't involve the current mintDgt\n                        needsMintDelegateApproval: false \n                    );\n\n                    didMintUuts && hasCapoApproval\n                }        \n            }\n            // _ => true // don't catch other variants, for complete coverage above.\n        }\n    };\n\n    // print(\"defaultMinter: minting value: \" + value_minted.show());\n    print(\"\\n\\nðŸš¥ðŸŸ¢ Capo minter: ok!\\n\");\n    // assert(false, \"barfola\");\n    ok\n}\n\n", {
    project: "stellar-contracts",
    purpose: "minting",
    name:  "src/minting/CapoMinter.hl", // source filename
    moduleName:  "CapoMinter",
});

class CapoMinterBundle extends HeliosScriptBundle.usingCapoBundleClass(CapoHeliosBundle) {
  static currentRev = 1n;
  scriptParamsSource = "config";
  //pro-forma to make TypeScript happy
  requiresGovAuthority = true;
  static needsSpecializedDelegateModule = false;
  static needsCapoConfiguration = true;
  // constructor(
  //     setupDetails?: StellarBundleSetupDetails<any>
  // ) {
  //     super(setupDetails);
  //     //@ts-expect-error setting the required property
  // }
  get params() {
    const { configuredScriptDetails, configuredParams } = this.capoBundle || {};
    const noConfig = `${this.constructor.name}: capoMph not found in deployed capo bundle; can't make config yet (dbpa)`;
    if (!configuredScriptDetails) {
      if (configuredParams) {
        console.warn(noConfig);
        debugger;
      }
      return { rev: this.rev };
    }
    const capoConfig = configuredScriptDetails.config;
    const {
      mph,
      seedTxn,
      seedIndex
    } = capoConfig;
    if (!mph) {
      console.warn(noConfig);
      debugger;
      throw new Error(noConfig);
    }
    return {
      rev: this.rev,
      seedTxn,
      seedIndex
    };
  }
  // // no datum types in this script
  // declare Activity: makesUplcActivityEnumData<MinterActivityLike>;
  // constructor(capoBundle: CapoHeliosBundle) {
  //     super();
  //     this.capoBundle = capoBundle;
  // }
  get main() {
    return CapoMinter_hl;
  }
  async loadPrecompiledVariant(variant) {
    if (variant !== "singleton") {
      throw new Error(`unknown minter variant: ${variant}`);
    }
    return this.capoBundle.loadPrecompiledMinterScript();
  }
  // automatically-included modules from Capo don't need to be specified
  // get modules() {
  //     return [...this.capoBundle.modules];
  // }
  init(setupDetails) {
    const { capo } = setupDetails.params || {};
    if (capo?._bundle) {
      this.capoBundle = capo._bundle;
    }
    const { minter: minterDetails } = this.capoBundle.precompiledScriptDetails || {};
    if (minterDetails) {
      this.precompiledScriptDetails = {
        singleton: minterDetails
      };
      this.configuredScriptDetails = minterDetails;
      this.scriptParamsSource = "bundle";
    }
    super.init(setupDetails);
  }
}

export { CapoMinterBundle, CapoMinterBundle as default };
//# sourceMappingURL=CapoMinter.hlb.mjs.map
