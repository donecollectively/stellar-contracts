import { C as CapoHeliosBundle } from '../CapoHeliosBundle2.mjs';
import { makeSource } from '@helios-lang/compiler-utils';
import { I as HeliosScriptBundle } from '../HeliosScriptBundle.mjs';
import '../BasicDelegate.mjs';
import '../DefaultCapo.mjs';
import '@helios-lang/ledger';
import '@helios-lang/uplc';
import '@donecollectively/stellar-contracts/HeliosProgramWithCacheAPI';
import '@helios-lang/compiler';
import '@helios-lang/codec-utils';
import '@helios-lang/crypto';
import '@helios-lang/contract-utils';
import '@helios-lang/tx-utils';
import 'nanoid';
import '../environment.mjs';

const CapoMinter_hl = makeSource(
  "minting CapoMinter\n\nimport {\n    tx, \n    get_current_input,\n    get_current_validator_hash,\n    get_current_minting_policy_hash,\n    get_cont_outputs\n} from ScriptContext\n\nimport { \n    hasSeedUtxo, \n    mkUutTnFactory,\n    requiresMintDelegateApproval,\n    validateUutMinting, \n    MinterActivity\n} from CapoMintHelpers\n\nimport {\n    CapoDatum,\n    CapoActivity,\n    getRefCharterUtxo,\n    mkCapoCtx\n} from CapoHelpers\n\nimport {\n    DgTknDisposition as DgTkn,\n    RelativeDelegateLink\n} from CapoDelegateHelpers\n\nimport {\n    mustFindInputRedeemer,\n    TRACE,\n    REQT,\n    TODO,\n    mkTv,\n    outputAndDatum,\n    tvCharter\n} from StellarHeliosHelpers\n\n// seed parameters provide uniqueness for the script validator hash:\nconst seedTxn : TxId = TxId::new(#1234)\nconst seedIndex : Int = 42\nconst rev : Int = 1\n\nfunc hasContractSeedUtxo(tx: Tx) -> Bool {\n    REQT(\"verifies that the provided seed utxo is being spent, providing uniqueness assurances for the minting-script's seed parameters\");\n\n    hasSeedUtxo(tx, TxOutputId::new(seedTxn, seedIndex))\n}\n\nfunc main(r : MinterActivity) -> Bool {\n    mph: MintingPolicyHash = get_current_minting_policy_hash();\n    value_minted: Value = tx.minted;\n    assert(true || (/* never evaluated */ rev.serialize() == rev.serialize()), \"no\");\n    assert(true || (/* never evaluated */ seedTxn.serialize() == seedTxn.serialize()), \"no\");\n    TRACE(\"cm1\".encode_utf8(), \" 🚥❓ Capo minter\");\n    print(\"  -- minter policy id: \" + get_current_minting_policy_hash().show());\n\n    ok : Bool = r.switch {\n        charter: mintingCharter => {\n            charterVal : Value = mkTv(mph, \"charter\");\n\n            // these must be sorted BY LENGTH FIRST, then lexicographically\n            //   (actually byte-wise, but ~same diff)\n            // settingsTnBase: String = \"set\";\n            authTnBase : String = \"capoGov\";\n            mintDgtTnBase : String = \"mintDgt\";\n            spendDgtTnBase: String = \"spendDgt\";\n            purposes = []String{\n                // settingsTnBase,\n                authTnBase, \n                mintDgtTnBase, \n                spendDgtTnBase\n            };\n            // settingsDgtTnBase: String = \"settingsDgt\"\n            // if (charter.withSettings) purposes = purposes + []String{ settingsDgtTnBase, \"settings\" }\n\n            TRACE(\"cm2\".encode_utf8(), \"  -- creating Capo charter\");\n            REQT(\"must mint the charter token\");\n            assert(value_minted >= charterVal,\n                \"charter token not minted\");\n\n            hasSeed: Bool = hasContractSeedUtxo(tx);\n            minterSeed: TxOutputId = TxOutputId::new(seedTxn, seedIndex);\n            mkUutName: (String) -> String = mkUutTnFactory(\n                minterSeed  \n            );\n            TRACE(\"cm3\".encode_utf8(), \"validateUutMinting\");\n            REQT(\"must mint uuts for mintDgt, spendDgt, and govAuth using the same seed\");\n            mintsUuts: Bool = validateUutMinting(\n                mph: mph,\n                seed: minterSeed,\n                purposes: purposes, \n                mkTokenName: mkUutName,\n                bootstrapCharter: charterVal\n            );\n            TRACE(\"cm4\".encode_utf8(), \"output to expected address\");\n            REQT(\"must deposit the charter token to the new Capo address\");\n            charterOutput: TxOutput = tx.outputs.find( (output: TxOutput) -> Bool {\n                output.address == charter.owner &&\n                    output.value.contains(charterVal)\n            });\n            // ^^ fails if there's no charter output to the right address\n\n            // print(\"defaultMinter @C\");\n            rawCharterData : Data = charterOutput.datum.inline;\n            charterData = CapoDatum::CharterData::from_data(rawCharterData);\n            CharterData{\n                spendDgt, \n                spendInvariants,\n                namedDelegates,\n                mintDgt, \n                mintInvariants, \n                authDgt,\n                manifest,\n                pendingDelegates\n            } = charterData;\n            // settings are not essential to a Capo.\n            // ... some Capos could use settings, and it would be\n            // ... up to its mint/spend delegate to enforce their presence.\n            // Also, their verification by other delegates, in case of updating\n            // the settings.  This gives settings a slightly special role,\n            // but much less than the special status they had when Settings\n            // were a separate datum type.\n\n            TRACE(\"cm5\".encode_utf8(), \"validate charter data\");\n            REQT(\"the new charter must not have any mint invariants, spend invariants, manifest entry or pending-delegate-actions\");\n            // once we have burned down the test backlog a bit, we can add these in:\n            assert(mintInvariants.length == 0, \"no mint invariants allowed at charter creation\");\n            assert(spendInvariants.length == 0, \"no spend invariants allowed at charter creation\");\n            assert(manifest.length == 0, \"no UUTs allowed at charter creation\");\n            assert(pendingDelegates.length == 0, \"no pending delegates allowed at charter creation\");\n\n            REQT(\"the new charter must have mintDgt, spendDgt, and authDgt tokens, each deposited to their separate script addresses\");\n            TRACE(\"cm6\".encode_utf8(), \"  -- checking for required delegates\\n\");\n            hasGoodDelegates : Bool = true &&\n                authDgt.hasValidOutput(mph, true, DgTkn::Created) &&\n                mintDgt.hasValidOutput(mph, true, DgTkn::Created) &&\n                spendDgt.hasValidOutput(mph, true, DgTkn::Created) &&\n                true;\n\n                // if (charter.withSettings) {\n                //     REQT(\"when 'withSettings' is true, there must be a settings-policy delegate created\");\n                //     assert(namedDelegates.length == 1, \"only settingsDgt allowed at charter creation\");\n                    \n                //     settingsDgt = namedDelegates.get_safe(\"settingsPolicy\").switch {\n                //         None => error(\"missing required named delegate 'settingsPolicy'\"),\n                //         Some{dgt} => dgt\n                //     };\n                //     settingsDgt.hasValidOutput(mph, true, DgTkn::Created)\n\n                //     REQT(\"with settings, there must be a settings datum stored in the Capo\");\n                //     cctx = mkCapoCtx(mph).nowMinting(charter.owner, charterOutput);\n                //     foundSettingsOutput : TxOutput = cctx.delegatedOutputData(\n                //         mkUutName(settingsTnBase)\n                //     );\n                \n                //     // tx.outputs.find_safe( (output: TxOutput) -> Bool {\n                //     //     output.address == charter.owner &&\n                //     //         output.value.contains(mkTv(mph, mkUutName(settingsTnBase))\n                //     // }).switch {\n                //     //     None => error(\"missing required settings data\"),\n                //     //     Some{output} => output\n                //     // };\n                                    \n                //     outputAndDatum[CapoDatum::DelegatedData] = \n                //         charterData.mustFindSettingsOutput(mph: mph, inAddr: charter.owner);\n                //     assert(foundSettings == foundSettings, \"no way, no\");\n\n                //     true\n                // } else { \n                //     assert(namedDelegates.length == 0, \"no named delegates allowed at charter creation\");\n                //     true\n                //  };\n\n            TRACE(\"cm7\".encode_utf8(), \"\");\n            assert(namedDelegates.length == 0, \"no named delegates allowed at charter creation\");\n\n            TRACE(\"cm8\".encode_utf8(), \"finishing\");\n            print(\"\\n  -- hasSeed: \" + hasSeed.show());\n            print(\"\\n  -- mintsUuts: \" + mintsUuts.show());\n            print(\"\\n  -- hasGoodDelegates: \" + hasGoodDelegates.show());\n        \n            true\n            && hasGoodDelegates \n            && mintsUuts \n            && hasSeed\n        },\n\n        // ------------------------- MOST MINTING ACTIVITIES USE THIS CODE PATH --------------------\n        mintWithDelegateAuthorizing => {\n            print(\"mintWithDelegateAuthorizing\\n\");\n            requiresMintDelegateApproval(mph)\n            // -------------------------  ^^^ deferring to the Capo's current minting delegate --------------------\n        },\n        _ => {\n            cctx = mkCapoCtx(mph).withCharterInput();\n            r.switch {\n                mintingCharter => error(\"unreachable\"),\n                mintWithDelegateAuthorizing => error(\"unreachable\"),\n                addingMintInvariant{_seed} => {\n                    print(\"checking for addingMintInvariant\\n\");\n                    assert(false, \"should be handled by the mintDelegate!\");\n                    false\n                },\n\n                addingSpendInvariant{_seed} => {\n                    print(\"checking for addingSpendInvariant\\n\");\n                    assert(false, \"should be handled by the mintDelegate!\");\n                    false\n                },\n\n                forcingNewMintDelegate{seed} => {\n                    print(\"checking for forcingNewMintDelegate\\n\");\n                    badCharterActivity = \"when forcingNewMintDelegate, capo charter must be spent with its capoLifecycleActivity.forcingNewMintDelegate activity\";\n                    REQT(\"Ensures the Capo charter is also forcingNewMintDelegate\");\n                    cctx.getCharterRedeemer().switch {\n                        capoLifecycleActivity{activity} => activity.switch {\n                            forcingNewMintDelegate{seedToCapo, purpose} => {\n                                print(\"WARNING: capo lifecycle activity is forcing a new mint-delegate with its Escape-hatch activity\");\n                                print(\"NOTE: the normal lifecycle is to use minter:mintWithDelegateAuthorizing, \\n\"+\n                                    \"  ... which defers to the Capo's current minting delegate and allows \\n\"+\n                                    \"  ... queuePendingChange(role: MintDgt) to queue the new mint delegate for installation\"\n                                );\n                                REQT(\"Ensures the new mintDgt-* uut is minted with a seed\");\n                                assert(seed == seedToCapo, \"seed mismatch:\"+\n                                    \"\\n  - Capo activity seed: \"+seedToCapo.show()+\n                                    \"\\n  - Minter seed: \"+seed.show()\n                                );\n                                assert(\"mintDgt\" == purpose, \"wrong Capo purpose '\"+purpose+\"'; should be 'mintDgt'\");\n                                validateUutMinting(\n                                    mph: mph,\n                                    seed: seed,\n                                    purposes: []String{purpose},\n                                    // forcing the new dgt; don't involve the current mintDgt\n                                    needsMintDelegateApproval: false \n                                )\n                            }, \n                            _ => error(badCharterActivity)\n                            \n                            // queuePendingChange{capoActivitySeed, purpose, role, name} => {\n                            //     assert(purpose == \"mintDgt\", \"wrong purpose\");\n                            //     role.switch {\n                            //         MintDgt => {\n                            //             print(\"ok: capo lifecycle activity is adding a (pending) mint-delegate\");\n                            //             true\n                            //         }, \n                            //         _ => error(\"wrong role in capo lifecycle activity\")\n                            //     }\n                            // }\n                        },\n                        _ => error(badCharterActivity)\n                    }\n                },\n\n                CreatingNewSpendDelegate{seed, replaceExisting} => {\n                    print(\"checking for CreatingNewSpendDelegate\\n\");\n\n                    needsCapoForcedInstall = replaceExisting.switch {\n                        Some => false,\n                        None => true\n                    };\n\n                    otherMintedValue : Value = replaceExisting.switch {\n                        Some{oldTokenName} => {\n                            BURNED: Int = -1;\n                            Value::new(\n                                AssetClass::new(mph, oldTokenName), \n                                BURNED\n                            )\n                        },\n                        None => Value::ZERO\n                    };\n                    mkTokenName = mkUutTnFactory(seed);\n                    spendDgtTn = mkTokenName(\"spendDgt\");\n\n                    hasCapoApproval = if (!needsCapoForcedInstall) {\n                        cctx.getCharterRedeemer().switch {\n                            updatingCharter => {\n                                TODO(\"the minter should see that the new spend delegate is QUEUED for installation by the Capo\");\n                                TODO(\"this essential logic vvvv will move to the installation moment\");\n                                REQT(\"the updated charter must reference the new spend delegate\");\n                                RelativeDelegateLink{uutName, _dvh, _config} = cctx.getNextCharterData().spendDelegateLink;\n                                print(\"expected uutName: \"+uutName);\n                                print(\"spendDgtTn in charter: \"+spendDgtTn);\n                                assert(uutName == spendDgtTn, \"new spend delegate not referenced in updated charter\");\n                                \n                                REQT(\"EXPECTS the Capo to validate that only the one thing is updated, and that the new UUT is deposited where it's expected\");\n                                true\n                            },\n                            // capoLifecycleActivity{activity} => activity.switch {                                \n                            // queuePendingChange{capoActivitySeed, purpose, role, name} => {\n                            //     assert(!replaceExisting, \"queuePendingChange can't use replaceExisting option\");\n\n                            //     assert(purpose == \"spendDgt\", \"wrong purpose\");\n                            //     role.switch {\n                            //         SpendDgt => {\n                            //             print(\"ok: capo lifecycle activity is adding a (pending) spend-delegate\");\n                            //             true\n                            //         }, \n                            //         _ => error(\"wrong role in capo lifecycle activity\")\n                            //     }\n                            // },\n                            _ => error(\"capo charter must be spent with its updatingCharter activity\")\n                        }\n                    } else {\n                        REQT(\"When the old dgTkn isn't replaced, it ensures the Capo charter is also forcingNewSpendDelegate\");\n                        badCharterActivity = \"when forcingNewSpendDelegate, capo charter must be spent with its capoLifecycleActivity.forcingNewSpendDelegate activity\";\n                        cctx.getCharterRedeemer().switch {\n                            capoLifecycleActivity{activity} => activity.switch {\n                                forcingNewSpendDelegate{seedToCapo, purpose} => {\n                                    print(\"WARNING: capo lifecycle activity is forcing a spend-delegate with its Escape-hatch activity\");\n                                    print(\"NOTE: the normal lifecycle is to use minter:mintWithDelegateAuthorizing, \\n\"+\n                                        \"  ... which defers to the Capo's current minting delegate and allows \\n\"+\n                                        \"  ... queuePendingChange(role: SpendDgt) to queue the new spend delegate for installation\"\n                                    );\n\n                                    REQT(\"Ensures the Capo activity's seed matches the minter's seed\");\n                                    assert(seed == seedToCapo, \"seed mismatch: \"\n                                        + \"\\n  - Capo activity seed: \" + seedToCapo.show()\n                                        + \"\\n  - Minter seed: \" + seed.show()\n                                    );\n                                    assert(\"spendDgt\" == purpose, \"wrong Capo purpose '\"+purpose+\"'; should be 'spendDgt'\");\n                                    true\n                                },\n                                _ => error(badCharterActivity)\n                            },\n                            _ => error(badCharterActivity)\n                        }\n                    };\n\n                    REQT(\"Ensures the new spendDgt-* uut is uniquely minted using the seed\");\n                    didMintUuts = validateUutMinting(\n                        mph: mph,\n                        seed: seed,\n                        purposes: []String{ \"spendDgt\" },\n                        mkTokenName: mkTokenName,\n                        otherMintedValue: otherMintedValue,\n                        // forcing the new dgt; don't involve the current mintDgt\n                        needsMintDelegateApproval: false \n                    );\n\n                    didMintUuts && hasCapoApproval\n                }        \n            }\n            // _ => true // don't catch other variants, for complete coverage above.\n        }\n    };\n\n    // print(\"defaultMinter: minting value: \" + value_minted.show());\n    print(\"\\n\\n🚥🟢 Capo minter: ok!\\n\");\n    // assert(false, \"barfola\");\n    ok\n}\n\n", {
    project: "stellar-contracts",
    purpose: "minting",
    name:  "src/minting/CapoMinter.hl", // source filename
    moduleName:  "CapoMinter",
});

class CapoMinterBundle extends HeliosScriptBundle.usingCapoBundleClass(CapoHeliosBundle) {
  scriptParamsSource = "config";
  //pro-forma to make TypeScript happy
  requiresGovAuthority = true;
  static needsSpecializedDelegateModule = false;
  static needsCapoConfiguration = true;
  // constructor(
  //     setupDetails?: StellarBundleSetupDetails<any>
  // ) {
  //     super(setupDetails);
  //     //@ts-expect-error setting the required property
  // }
  get rev() {
    return 1n;
  }
  get params() {
    const { configuredScriptDetails, configuredParams } = this.capoBundle || {};
    debugger;
    const noConfig = `${this.constructor.name}: capoMph not found in deployed capo bundle; can't make config yet (dbpa)`;
    if (!configuredScriptDetails) {
      if (configuredParams) {
        console.warn(noConfig);
        debugger;
      }
      return void 0;
    }
    const capoConfig = configuredScriptDetails.config;
    const {
      mph,
      seedTxn,
      seedIndex
    } = capoConfig;
    if (!mph) {
      console.warn(noConfig);
      debugger;
      throw new Error(noConfig);
    }
    return {
      rev: this.rev,
      seedTxn,
      seedIndex
    };
  }
  // // no datum types in this script
  // declare Activity: makesUplcActivityEnumData<MinterActivityLike>;
  // constructor(capoBundle: CapoHeliosBundle) {
  //     super();
  //     this.capoBundle = capoBundle;
  // }
  get main() {
    return CapoMinter_hl;
  }
  // automatically-included modules from Capo don't need to be specified
  // get modules() {
  //     return [...this.capoBundle.modules];
  // }
}

export { CapoMinterBundle, CapoMinterBundle as default };
//# sourceMappingURL=CapoMinter.hlb.mjs.map
