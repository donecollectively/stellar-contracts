import { makeSource } from '@helios-lang/compiler-utils';

const UnspecializedDelegate_hl = makeSource(
  "module UnspecializedDelegate\n\nimport {\n    tx, \n    get_current_input,\n    get_current_validator_hash,\n    get_cont_outputs\n} from ScriptContext\n\n// specialized to ...\n//   -   NOT YET SPECIALIZED (replace with your specialization notes here) - \n// original notes about (un)specialization follow:\n\n\n//  //! provides a basic version, not yet specialized,\n//  // of the \"specializedDelegate\" interface, which simply\n//  // exports a DelegateDatum enum and DelegateActivities (redeemer enum).  \n\n//  //! Your specialization MUST include the enum variants found in this\n//  //  ... unspecialized version.  It MAY include additional Datum variants.\n//  // Any additional Redeemer/Activity variants should be added underneath \n//  // the SpendingActivity / MintingActivity top-level enum variants, instead \n//  // of adding new top-level enum variants to DelegateActivity.\n\n//  // The DelegateActivity (redeemer) enum conforms to the \n//  // Delegate Redeemer protocol, in which enum 0 is reserved for\n//  // lifecycle activities, enum 1 is used for spend-related activities \n//  // (if the delegate is used as a spend delegate), and enum 2 is called\n//  // for authorizing minting.  Enum 3 and beyond are reserved for\n//  // extensions to the Delegate Redeemer protocol.\n\n//  // Within the minting and spending activities, the specialization can \n//  // indicate a nested activity enum to support various dApp-specific\n//  // activities.  \n\n//  // Activities that validate minting of UUTs should contain enum fields \n//  // to identify the seed-transaction details needed for properly validating \n//  // UUT mints fitting the use-case.\n\n//  //! Your specialization MAY include any additional functions, imports or \n//  //  methods defined on any of the types in this file.\n\nimport {\n    AnyData,\n    REQT,\n    bREQT,\n    TODO,\n    REQTgroup,\n    REQTgroupUnit,\n    logGroupUnit,\n    logGroup,\n    logGroupStart,\n    logGroupEnd\n} from StellarHeliosHelpers\n\nimport {\n    DelegationDetail,\n    mustReturnValueToScript,\n    DelegateLifecycleActivity,\n    CapoLifecycleActivity,\n    unmodifiedDelegation\n} from CapoDelegateHelpers\n\nimport {\n    validateUutMinting,\n    mkUutTnFactory\n} from CapoMintHelpers\n\nimport {\n    CapoCtx,\n    mkCapoCtx\n} from CapoHelpers\n \n// import {\n//     ProtocolSettings\n// } from ProtocolSettings\n\nenum DelegateDatum {\n    // we only have to use this if we decide Constr#0 is essential for practical CIP-68 compat\n    Cip68RefToken {  \n        // NOTE: this datum contains reference details for a user-facing token minted according to the cip-68 standard \n        //  - the asset name (in the Value of this UTXO) MUST be:  #000643b0 + tokenName\n        //     - this asset name can serve user-side tokens using the CIP-68 \"222\", \"333\" or other token types.\n        //     - the user-side asset name with its (222/333/etc) CIP-67 prefix and \n        //       ... its remaining tokenName will be matched to this asset name (#000643b0 +tokenName)\n        //       ... to locate this reference datum; this datum content will be interpreted\n        //       ... according to the semantics implied by the user-side asset-name prefix.\n        //\n        //  - The attached 'meta' field in this Datum variant contains the relevant data, depending on the token type\n        //    - for \"222\" tokens, the meta field should contain the following fields:\n        //        - \"name\" : String\n        //        - \"description\" : String \n        //        - \"files\" :   // {mediaType, src (url), name?, ... otherFields)\n        //        - \"image\": String  // image url: https://, ar://, ipfs:// or data:// (RFC2397 data)\n        //    - for \"333\" tokens, the meta field should contain the following fields:\n        //        - \"name\" : String\n        //        - \"description\" : String \n        //        - \"ticker\" : String\n        //        - \"url\": String  // project URL\n        //        - \"logo\": String  // image url: https://, ar://, ipfs:// or data:// (RFC2397 data)\n        //                    - it must have a mime type `image/png`, `image/jpeg` or `image/svg+xml`\n        //        - \"decimals\" : Int\n\n        cip68meta: AnyData\n        cip68version: Int\n        otherDetails: Data\n        // otherDetails: Data // can be Unit () or anything else\n    }\n\n    IsDelegation {\n        dd: DelegationDetail\n    }\n    // same variant-index as Capo's DelegatedData\n    capoStoredData {\n        data: AnyData\n        version: Int\n        otherDetails: Data \n    }\n\n    // func validateSettings(self, settings: ProtocolSettings) -> Bool{\n    // ... get the settings object from the contract manifest via cctx\n    //     assert(false, \"not valid (stubbed)\");\n    //     settings.serialize() != self.serialize() &&\n    //     true\n    // }\n}\n\nenum MintingActivity {\n    // application can replace the placeholder, which is only here to \n    // avoid a syntax error in the unspecialized version\n    _placeholder1MA {\n        seed: TxOutputId\n    }\n}\n\n//! The minting delegate can also be used as a general spending \n// delegate (this is the default arrangement during the Capo \n// charter mint).  These activities are required by the Capo when\n// spending utxos having DelegatedDatum type.\nenum SpendingActivity {\n    // application can replace the placeholder, which is only here to \n    // avoid a syntax error in the unspecialized version\n    _placeholder1SA  {\n        recId: ByteArray\n    }\n}\n\nenum BurningActivity {\n    // application can replace the placeholder, which is only here to \n    // avoid a syntax error in the unspecialized version\n    _placeholder1BA {\n        recId: ByteArray\n    }\n}\nenum DelegateActivity {\n    // must ALWAYS be at Enum position 0\n    CapoLifecycleActivities {\n        activity: CapoLifecycleActivity\n    }\n\n    // must ALWAYS be at Enum position 1\n    DelegateLifecycleActivities {\n        // administrative activities for the delegate lifecycle, enforced\n        //  by the basic mint delegate code.  Specializations can add more \n        //  restrictions, but in many/most cases they will not need to.\n        activity: DelegateLifecycleActivity\n    }\n\n    // application-specific spending activities, ALWAYS at Enum position 2\n    SpendingActivities {\n        activity: SpendingActivity\n    }\n\n    // application-specific minting activities, ALWAYS at Enum position 3\n    // remember:M and 3 have a similar shape.\n    MintingActivities {\n        activity: MintingActivity\n    }\n\n    BurningActivities {\n        // application-specific burning activities, ALWAYS at Enum position 4\n        activity: BurningActivity\n    }\n\n    CreatingDelegatedData {\n        seed: TxOutputId\n        dataType: String\n        // id from seed\n    }\n\n    UpdatingDelegatedData {\n        // seed not used\n        dataType: String\n        recId: ByteArray\n    }\n\n    DeletingDelegatedData {\n        // seed not used\n        dataType: String\n        recId: ByteArray\n    }\n\n    OtherActivities {\n        activity: Data // anything defined in the specialization; nothing here.\n    }\n\n    MultipleDelegateActivities {\n        activities: []Data // actually a []DelegateActivity\n        // todo: change this back when the recursive enum's `__is_valid_data not found` error is resolved\n    }\n\n    // this function gives a general-purpose implementation of checking for \n    // valid uut minting. \n    //\n    // A specialization might modify it to use different policies\n    // or enforce additional requirements\n    // \n    // func genericUutMinting(self, \n    //     mdd: DelegateDatum,\n    // ) -> Bool {\n    //     //!!! replace with an activity using the same seed-txn pattern:\n    //     // MintingActivities::SomethingMintingUuts{seed, purposes} = self;\n    //     DelegateDatum::IsDelegation{dd} = mdd;\n    //     returnsAuthzToken : Bool = mustReturnValueToScript(dd.tvAuthorityToken());\n\n    //     o : []TxOutput = get_cont_outputs();\n    //     if (o.length != 1) { error(\"single utxo only\") };\n\n    //     print (\"in unsp_MD\");\n    //     isOk : Bool = returnsAuthzToken && \n\n    //     unmodifiedDelegation( /* isD, same as mdd */ mdd.serialize()) &&\n\n    //     // This call can serve as a template for enforcing expected mints \n    //     // of uuts (and additional token values) in validation of application-\n    //     // specific activities, given (mph, seed, purposes)\n    //     validateUutMinting(\n    //         mph: dd.mph,\n    //         seed: seed,\n    //         purposes: purposes,\n    //         // otherMintedValue: ()\n    //         mkTokenName: mkUutTnFactory(seed)\n    //     );\n\n    //     isOk\n    // }\n\n    //! used only for validating IsDelegation datum, that is,\n    //   ... to approve minting requests or any customize spending modes \n    //   ... of that datum.  \n    \n    //  Note that the basic delegate already enforces some basic\n    //    administrative expectations for DelegateLifecycleActivities and CapoLifecycleActivities\n    //    so a specialization doesn't need to re-implement those checks.\n    func additionalDelegateValidation( self,\n        priorMddd: DelegateDatum::IsDelegation,\n        cctx: CapoCtx\n    ) -> Bool {\n        // print(\"  ----- checking additional delegate validation\");\n        mph : MintingPolicyHash = priorMddd.dd.mph;\n\n        self.switch {\n            // generic DelegateLifecycleActivities is already validated, but \n            //  ... you can add more constraints here if needed\n            DelegateLifecycleActivities => true,\n            CapoLifecycleActivities{CLA} => {\n                // CapoLifecycleActivites.queuePendingChange is only relevant for the MINT delegate.\n                // CapoLifecycleActivites.{removing, committing}PendingChange(s) are served by the SPEND delegate\n                // Capo\n                // CapoLifecycleActivites.{forcing}* are ONLY ever served by the Capo itself as an escape-hatch\n                //  assert(isMintingDelegate, \"unreachable\"); // TODO access this const defined in the main script\n\n                // They're normally rejected in this unspecialized (minting) delegate:\n                //   ... but if you have cases for creating new delegates, such as \n                //   ... named delegates for advanced constellations of contracts \n                //   ... in your Capo, you can implement checks for that here.\n                //  You can use this construct as-is, or modify it to suit your needs.\n                CLA.switch {\n                    // queuePendingChange{action, role, name} => {\n                    //     print(\"unspecialized mint delegate allowing queuePendingChange\");\n                    // },\n                    // committingPendingDgtChange{action, role, name} => {\n                    //     print(\"unspecialized mint delegate allowing committingPendingChange\");\n                    // },\n                    CreatingDelegate{seed, purpose} => {\n                        self.supportedCapoDelegatePurposes().find_safe(\n                            (p : String) -> Bool { p == purpose } \n                        ).switch {\n                            None => {\n                                if (self.supportedCapoDelegatePurposes().length == 0) {\n                                    print(\"note: unspecialized delegate has no supported purposes\")\n                                };\n                                error(\"can't mint delegate with unsupported purpose\")\n                            },\n                            Some => {\n                                validateUutMinting(\n                                    mph: mph,\n                                    seed: seed,\n                                    purposes: []String{purpose},\n                                    // otherMintedValue: ()\n                                    mkTokenName: mkUutTnFactory(seed),\n                                    // WE ARE the mint delegate.\n                                    needsMintDelegateApproval: false \n                                )\n                            }\n                        }\n                    },\n                    _ => {\n                        REQT(\"   -- to customize: mint/spend delegates have an option to validate additional lifecycle constraints here\");\n                        true\n                    }\n                 }\n            },\n            MintingActivities => {\n                assert(cctx.withCharterRef().orFail(), \"can't\");\n\n                error(\"unspecialized mint delegate doesn't have any MintingActivities\")\n            },\n            CreatingDelegatedData{_, dataType} => {\n                print(\" ℹ️  mint: delegates CreatingDelegatedData authority to \"+dataType);\n                true\n            },\n            UpdatingDelegatedData{dataType, _recId} => {\n                print(\" ℹ️  spend: delegates UpdatingDelegatedData authority to \"+dataType);\n                true\n            },\n            DeletingDelegatedData{dataType, _recId} => {\n                print(\" ℹ️  spend: delegates DeletingDelegatedData authority to \"+dataType);\n                true\n            },\n            MultipleDelegateActivities => {\n                print(\"    -- mint/spend delegate: MultipleDelegateActivities: no special validation in this unspecialized delegate\");\n                true\n            },\n            OtherActivities => error(\n                \"no other activities exist in this unspecialized delegate\"\n            ),\n            _ => {\n                assert(false, \"mint/spend delegate rejecting other activity\");\n                false\n            }\n        } || tx.serialize() == priorMddd.serialize()\n    }\n\n    func supportedCapoDelegatePurposes(self) -> []String {\n        assert(true || /* prevent unused variable */ self == self, \"no way, man\" );\n         []String{ \n            // \"nothingHereYet\",\n        }\n    }\n\n    //! Use this only for validating non-IsDelegation datum types and activities,\n    //  stored in the delegate's own address, for special cases where that could \n    // be important (so far, it's never been used - please open a discussion if you \n    //    think it's needed for your special case)\n    // Typically, you should look to Activity validations above in additionalDelegateValidation,\n    // ...  in which the unique isDelegation token is being spent with an application-specific\n    // ...  activity/redeemer\n    func otherDatumValidation(self,\n        _priorMdd: DelegateDatum\n    ) -> Bool {\n        neverTriggered = () -> {  error(\"never called\") };\n        self.switch{\n            // Note: this set of DelegateActivities is reserved for the IsDelegation datum.\n            //  Using it on any other Datum type will always fail and execution will never arrive here.\n            DelegateLifecycleActivities => neverTriggered(),\n            CapoLifecycleActivities => neverTriggered(),\n\n            // -- Application-specific activities can be added here \n            // -- for special & app-specific types of datum in a delegate,\n            // -- for EXCEPTIONAL cases, if you really know what you're doing.  \n            //  -- see above for normal cases\n\n            _ => false  // prevents non-exhaustive match errors, even if you remove the above neverTriggered() calls\n        }\n    }\n}\n\n", {
    project: "stellar-contracts",
    purpose: "module",
    name:  "src/delegation/UnspecializedDelegate.hl", // source filename
    moduleName:  "UnspecializedDelegate",
});

export { UnspecializedDelegate_hl as U };
//# sourceMappingURL=UnspecializedDelegate.mjs.map
