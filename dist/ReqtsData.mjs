import { makeSource } from '@helios-lang/compiler-utils';

const ReqtsPolicy_hl = makeSource(
  "module ReqtsPolicy\n\nimport {\n    tx, \n    get_current_input,\n    get_current_validator_hash,\n    get_cont_outputs\n} from ScriptContext\n\n// this module provides the basic interface needed for a Capo delegate.\n//  ... see ./ReqtsDelegate.hl to see how the delegate interface is provided \n//  ... for that usage case (with a generic module name).\n\n// it is also packaged (with a unique module name above) to enable access \n// ...from other helios scopes.\n\n// THIS MODULE has been specialized to ...\n//  - do requirements-management kinds of things\n// ... more details here\n\n// original notes about (un)specialization follow:\n//  //! provides a basic version, ~~not yet specialized,~~\n//  // of the \"specializedDelegate\" interface, which simply\n//  // exports a DelegateDatum enum and DelegateActivities (redeemer enum).  \n\n//  //! Your specialization MUST include the enum variants found in this\n//  //  ... unspecialized version.  It MAY include additional Datum variants.\n//  // Any additional Redeemer/Activity variants should be added underneath \n//  // the SpendingActivity / MintingActivity top-level enum variants, instead \n//  // of adding new top-level enum variants to DelegateActivity.\n\n//  // The DelegateActivity (redeemer) enum conforms to the \n//  // Delegate Redeemer protocol, in which enum 0 is reserved for\n//  // lifecycle activities, enum 1 is used for spend-related activities \n//  // (if the delegate is used as a spend delegate), and enum 2 is called\n//  // for authorizing minting.  Enum 3 and beyond are reserved for\n//  // extensions to the Delegate Redeemer protocol.\n\n//  // Within the minting and spending activities, the specialization can \n//  // indicate a nested activity enum to support various dApp-specific\n//  // activities.  \n\n//  // Activities that validate minting of UUTs should contain enum fields \n//  // to identify the seed-transaction details needed for properly validating \n//  // UUT mints fitting the use-case.\n\n//  //! Your specialization MAY include any additional functions, imports or \n//  //  methods defined on any of the types in this file.\n\n\nimport {\n    DelegationDetail,\n    mustReturnValueToScript,\n    DelegateLifecycleActivity,\n    CapoLifecycleActivity,\n    unmodifiedDelegation\n} from CapoDelegateHelpers\n\nimport {\n    validateUutMinting,\n    tnCip68ref100,\n    tnCip68nft222,\n    mkUutTnFactory\n} from CapoMintHelpers\n\n// import {\n//     ProtocolSettings\n// } from ProtocolSettings\n\nimport {\n    CapoCtx,\n    mkCapoCtx,\n    mkTv,\n    AnyData \n} from CapoHelpers\n\n// import {\n//     TierLookupResult\n// } from TieredScale\n\nimport {\n    TODO,\n    REQT\n} from StellarHeliosHelpers\n\nimport { \n    ReqtData, \n    DelegateDatum, \n    MintingActivity, \n    SpendingActivity, \n    BurningActivity \n} from ReqtsData\n\n\nfunc ensureConstrainedTxValidity() -> () {\n    assert(\n        tx.time_range.end - tx.time_range.start \n            <= Duration::HOUR,\n        \"txn duration err\"\n    )\n}\n\nfunc daysInFuture(nowPlusDays: Int) -> TimeRange {\n    ensureConstrainedTxValidity();\n    expiryDuration : Duration = Duration::DAY * nowPlusDays;\n    leeway : Duration = 1 * Duration::HOUR;\n    latestAcceptable : Time = tx.time_range.end + expiryDuration + leeway;\n    \n    TimeRange::new(\n        tx.time_range.start + expiryDuration,\n        latestAcceptable\n    )\n}\n\nenum DelegateActivity {\n    // must ALWAYS be at Enum position 0\n    CapoLifecycleActivities {\n        activity: CapoLifecycleActivity\n    }\n\n    // must ALWAYS be at Enum position 1\n    DelegateLifecycleActivities {\n        // administrative activities for the delegate lifecycle, enforced\n        //  by the basic mint delegate code.  Specializations can add more \n        //  restrictions, but in many/most cases they will not need to.\n        activity: DelegateLifecycleActivity\n    }\n\n    // application-specific spending activities, ALWAYS at Enum position 2\n    SpendingActivities {\n        activity: SpendingActivity\n    }\n\n    // application-specific minting activities, ALWAYS at Enum position 3\n    // remember:M and 3 have a similar shape.\n    MintingActivities {\n        activity: MintingActivity\n    }\n\n    BurningActivities {\n        // application-specific burning activities, ALWAYS at Enum position 4\n        activity: BurningActivity\n    }\n\n    CreatingDelegatedData {\n        seed: TxOutputId\n        dataType: String\n        // id from seed\n    }\n\n    UpdatingDelegatedData {\n        // seed not used\n        dataType: String\n        recId: ByteArray\n    }\n\n    DeletingDelegatedData {\n        // seed not used\n        dataType: String\n        recId: ByteArray\n    }\n\n    MultipleDelegateActivities {\n        activities: []Data // actually a []DelegateActivity\n        // todo: change this back when the recursive enum's `__is_valid_data not found` error is resolved\n    }\n\n    // this function gives a general-purpose implementation of checking for \n    // valid uut minting. \n    //\n    // A specialization might modify it to use different policies\n    // or enforce additional requirements\n    // \n    // func genericUutMinting(self, \n    //     mdd: DelegateDatum,\n    // ) -> Bool {\n    //     //!!! replace with an activity using the same seed-txn pattern:\n    //     // MintingActivities::SomethingMintingUuts{sTxId, sIdx, purposes} = self;\n    //     DelegateDatum::IsDelegation{dd} = mdd;\n    //     returnsAuthzToken : Bool = mustReturnValueToScript(dd.tvAuthorityToken());\n\n    //     o : []TxOutput = get_cont_outputs();\n    //     if (o.length != 1) { error(\"single utxo only\") };\n\n    //     print (\"in unsp_MD\");\n    //     isOk : Bool = returnsAuthzToken && \n\n    //     unmodifiedDelegation( /* isD, same as mdd */ mdd.serialize()) &&\n\n    //     // This call can serve as a template for enforcing expected mints \n    //     // of uuts (and additional token values) in validation of application-\n    //     // specific activities, given (mph, sTxId, sIdx, purposes)\n    //     validateUutMinting(\n    //         mph: dd.mph,\n    //         seed: seed,\n    //         purposes: purposes,\n    //         //otherMintedValue: ()\n    //         mkTokenName: mkUutTnFactory(seed)\n    //     );\n\n    //     isOk\n    // }\n\n    //! used only for validating IsDelegation datum, that is,\n    //   ... to approve minting requests or any customize spending modes \n    //   ... of that datum.  \n    \n    //  Note that the basic delegate already enforces some basic\n    //    administrative expectations for DelegateLifecycleActivities and CapoLifecycleActivities\n    //    so a specialization doesn't need to re-implement those checks.\n    func additionalDelegateValidation( self,\n        priorMddd: DelegateDatum::IsDelegation,\n        cctx: CapoCtx\n    ) -> Bool {\n        print(\"  -- addl dgt validity check\");\n        self.switch {\n            // generic DelegateLifecycleActivities is already validated, but \n            //  ... you can add more constraints here if needed\n            DelegateLifecycleActivities => true,\n            // non-mintDelegate can't trigger these activities\n            CapoLifecycleActivities => error(\"unreachable\"),\n            MintingActivities{VMA} => VMA.switch {\n                CreatingRecord{seed} => {\n                    print(\"creating reqt record...\\n\");\n\n                    mkTn : (String) -> String = mkUutTnFactory(seed);\n                    assert(cctx.withCharterRef().orFail(), \"can't\");\n\n                    // settings : ProtocolSettings = cctx.getManifestDatum[ProtocolSettings](\"settings\");\n\n                    tokenName = mkTn(\"reqt\");\n                    // depositedValue: Value = mkTv(mph: priorMddd.dd.mph, tn: tokenName);\n                    // depositedAc : AssetClass = AssetClass::new(priorMddd.dd.mph, tokenName.encode_utf8());\n\n                    newReqt : TxOutput = cctx.delegatedTxOutput(tokenName.encode_utf8());\n\n                    reqtData: ReqtData = ReqtData::from_data(\n                        newReqt.datum.inline\n                    );\n\n                    assert(\n                        tx.time_range.end - tx.time_range.start \n                            <= Duration::HOUR,\n                        \"txn duration err\"\n                    );\n                    // has the right expiration date from settings\n                    // !!! todo get from settings                    \n                    acceptableExpiry : TimeRange = daysInFuture(73);\n\n                    discountEnds : Time = reqtData.mustFreshenBy;\n\n                    assert(\n                        acceptableExpiry.contains(discountEnds),\n                        \"wrong discount expiry date too late seconds: \" + (( discountEnds - acceptableExpiry.end) / Duration::SECOND).show() \n                    );\n\n                    // has the member-token reference\n                    // memberToken : String = reqtData.memberToken;\n                    // if (!reqtData.memberToken.starts_with(\"member-\")) { \n                    //     error(\"invalid member token name\"\n                    // ) };\n                    // expectedMemberToken : Value = mkTv(\n                    //     priorMddd.dd.mph, reqtData.memberToken\n                    // );\n\n                    // has the member-token in the txn\n                    // tx.inputs.find_safe((i: TxInput) -> Bool {\n                    //     i.value.contains(expectedMemberToken)\n                    // }).switch {\n                    //     None => error(\"missing member token\"),\n                    //     Some => true\n                    // } &&\n                    reqtData.validate() &&\n                    // mints a reqt UUT\n                    validateUutMinting(\n                        mph: priorMddd.dd.mph,\n                        seed: seed,\n                        purposes: []String{\"reqt\"},\n                        // otherMintedValue: ... ,\n                        mkTokenName: mkTn,\n                        // WE ARE the mint delegate.\n                        needsMintDelegateApproval: false \n                    )\n                }\n            },\n            SpendingActivities{VSA} => {\n                print(\"capo mph: \" + priorMddd.dd.mph.show());\n                // cctx : CapoCtx = mkCapoCtx(priorMddd.dd.mph).withCharterRef();\n                assert(cctx.withCharterRef().orFail(), \"can't\");\n                print( \"\\ncapo addr\" + cctx.resolveCharterUtxo().address.show());\n                print(\"\\n\");\n\n                VSA.switch {                    \n                    UpdatingRecord{recId} => {\n                        hasDD : (TxInput) -> Bool = cctx.mkDelegatedDataPredicate(\"Reqt\", recId);\n                        // settings: ProtocolSettings = ccts.getManifestDatum[ProtocolSettings](\"settings\");\n                        hasDDOutput : (TxOutput) -> Bool = cctx.mkDelegatedDataOutputPredicate(\"Reqt\", recId);\n    \n                        tx.inputs.filter(hasDD).for_each( (utxo : TxInput) -> () {\n                            // they're all reqts, because of the above filter\n                            reqtData : ReqtData = ReqtData::from_data(utxo.datum.inline);\n                            updatedUtxo : TxOutput = tx.outputs.find(hasDDOutput);\n                            updatedReqt : ReqtData = ReqtData::from_data(updatedUtxo.datum.inline);\n\n                            _previousDeposit : Int = utxo.value.get_lovelace(); \n                            _newDepositTotal : Int = updatedUtxo.value.get_lovelace();  \n\n                                                        \n                            freshExpiry : TimeRange = daysInFuture(73); // todo get from settings\n                            \n                            REQT(\"changes the expiration date on each update\");\n                            REQT(\"uses the expiration-date policy from settings\");\n                            if (tx.time_range.end > reqtData.mustFreshenBy) {\n                                print(\"  -- reqt expired.  freshening.\\n\");\n                                REQT(\"updates the expiration date if it's expired\");\n                                assert( \n                                    freshExpiry.contains(updatedReqt.mustFreshenBy), \n                                    \"wrong expiry date @expired\"\n                                )\n                            }\n                        });\n                        true\n                    }\n                }\n            },        \n            _ => false\n        } || tx.serialize() == priorMddd.serialize()        \n    }\n\n    func supportedCapoDelegatePurposes(self) -> []String {\n        assert(true || /* prevent unused variable */ self == self, \"no way t\" );\n        []String{ \n            // \"nothingHereYet\",\n        }\n    }\n\n    //! Used only for validating non-IsDelegation datum types and activities.\n    // if you have any special admininstrative data structures that inform \n    // ...  your minting policy, this might be useful.  Otherwise, and typically,\n    // ... you should look to Activity validations above in additionalDelegateValidation,\n    // ...  in which the isDelegation token is being spent with an application-specific\n    // ...  activity/redeemer\n    func otherDatumValidation( self,\n        _priorMdd: DelegateDatum\n    ) -> Bool {\n        neverTriggered = () -> {  error(\"never called\") };\n        self.switch{\n            // Note: this set of DelegateActivities is reserved for the IsDelegation datum.\n            //  Using it on any other Datum type will always fail and execution will never arrive here.\n            DelegateLifecycleActivities => neverTriggered(),\n            CapoLifecycleActivities => neverTriggered(),\n\n            // -- Application-specific activities can be added here \n            // -- for special & app-specific types of datum in a delegate,\n            // -- for EXCEPTIONAL cases, if you really know what you're doing.  \n            //  -- see above for normal cases\n\n            _ => false  // prevents non-exhaustive match errors, even if you remove the above neverTriggered() calls\n        }\n    }\n}\n\n", {
    project: "stellar-contracts",
    purpose: "module",
    name:  "src/reqts/ReqtsPolicy.hl", // source filename
    moduleName:  "ReqtsPolicy",
});

const ReqtsData_hl = makeSource(
  "module ReqtsData\n\nimport {\n    AnyData\n} from StellarHeliosHelpers\nimport {\n    DelegationDetail\n} from CapoDelegateHelpers\n\n// !!! reqts data is stored in the Capo, \n//   ... but controlled, via the reqtsPolicy-* UUT. by the reqts delegate script \n//   ... which uses the code in this module (see DelegateActivity::additionalDelegateValidation below)\nstruct ReqtData {\n    id : ByteArray \"@id\" // = \"reqt-XXXXyyyyZZZZ\"\n    type : String \"tpe\" // = \"Reqt\"\n    category: String \"cat\" // e.g. \"security\", \"usability\", \"performance\", \"compliance\"   \n    // for CIP-68 tokens issued from this requirement\n    name: String // e.g. \"Reqt XyZ\"\n    image: String // svg data for requirement graphic\n    description: String  // \"Holder of this token has a stake in the success of this requirement\"\n\n    mustFreshenBy: Time  \"exp\"\n    target: ByteArray  \"tgt\"\n    purpose: String   \"prps\"\n    details: []String  \"dtls\"\n    mech: []String  \n    impl: String\n    requires: []String\n    \n    // files: []AnyData optional\n\n    func validate(self) -> Bool {\n        assert(true || ( /* never executed*/ self.serialize() == self.serialize()), \"no\");\n        true\n    }\n}\n\nenum DelegateDatum {\n    Cip68RefToken {  \n        // NOTE: this datum contains reference details for a user-facing token minted according to the cip-68 standard \n        //  - the asset name (in the Value of this UTXO) MUST be:  #000643b0 + tokenName\n        //     - this asset name can serve user-side tokens using the CIP-68 \"222\", \"333\" or other token types.\n        //     - the user-side asset name with its (222/333/etc) CIP-67 prefix and \n        //       ... its remaining tokenName will be matched to this asset name (#000643b0 +tokenName)\n        //       ... to locate this reference datum; this datum content will be interpreted\n        //       ... according to the semantics implied by the user-side asset-name prefix.\n        //\n        //  - The attached 'meta' field in this Datum variant contains the relevant data, depending on the token type\n        //    - for \"222\" tokens, the meta field should contain the following fields:\n        //        - \"name\" : String\n        //        - \"description\" : String \n        //        - \"files\" :   // {mediaType, src (url), name?, ... otherFields)\n        //        - \"image\": String  // image url: https://, ar://, ipfs:// or data:// (RFC2397 data)\n        //    - for \"333\" tokens, the meta field should contain the following fields:\n        //        - \"name\" : String\n        //        - \"description\" : String \n        //        - \"ticker\" : String\n        //        - \"url\": String  // project URL\n        //        - \"logo\": String  // image url: https://, ar://, ipfs:// or data:// (RFC2397 data)\n        //                    - it must have a mime type `image/png`, `image/jpeg` or `image/svg+xml`\n        //        - \"decimals\" : Int\n\n        cip68meta: AnyData\n        cip68version: Int\n        otherDetails: Data // can be Unit () or anything else\n    }\n\n    IsDelegation {\n        dd: DelegationDetail\n    }\n    // same variant-index as Capo's DelegatedData\n    capoStoredData {\n        data: ReqtData\n        version: Int\n        otherDetails: Data \n    }\n\n    // func validateSettings(self, _settings: ProtocolSettings) -> Bool{\n    //   ... get the settings from the manifest via cctx\n    //     assert(false, \"not valid (stubbed)\");\n    //     // settings.serialize() != self.serialize() &&\n    //     true\n    // }\n\n}\n\nenum MintingActivity {\n    CreatingRecord {\n        seed: TxOutputId\n    }\n}\n\nenum SpendingActivity {\n    UpdatingRecord {\n        id: ByteArray\n    }\n\n}\n\nenum BurningActivity {\n    DeletingRecord {\n        id: ByteArray\n    }\n}\n", {
    project: "stellar-contracts",
    purpose: "module",
    name:  "src/reqts/ReqtsData.hl", // source filename
    moduleName:  "ReqtsData",
});

export { ReqtsPolicy_hl as R, ReqtsData_hl as a };
//# sourceMappingURL=ReqtsData.mjs.map
