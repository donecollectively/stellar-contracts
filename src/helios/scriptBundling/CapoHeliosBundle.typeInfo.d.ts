// generated by StellarHeliosProject using Stellar heliosRollupTypeGen()
// recommended: CHECK THIS FILE INTO YOUR VERSION CONTROL SYSTEM
//   ... and keep checking in the changes as your on-chain types evolve.
//
// NOTE: this file is auto-generated; do not edit directly

import type { UplcData } from "@helios-lang/uplc";
import type {
    Address,
    AssetClass,
    DatumHash,
    MintingPolicyHash,
    PubKey,
    PubKeyHash,
    ScriptHash,
    SpendingCredential,
    StakingCredential,
    StakingValidatorHash,
    TimeRange,
    TxId,
    TxInput,
    TxOutput,
    TxOutputId,
    InlineTxOutputDatum,
    ValidatorHash,
    Value,
} from "@helios-lang/ledger";
import type { Cast } from "@helios-lang/contract-utils";
import type { 
    IntLike,
    // BytesLike,
 } from "@helios-lang/codec-utils";

 type TimeLike = IntLike;
 

import {HeliosScriptBundle} from "./HeliosScriptBundle.ts"
import type { 
    tagOnly, 
    EnumTypeMeta, 
    singleEnumVariantMeta
} from "../HeliosMetaTypes.ts"
import type { minimalData } from "../../delegation/DelegatedData.ts"
import type { IntersectedEnum } from "../typeUtils.ts"
                


/**
 * A strong type for the canonical form of RelativeDelegateLink
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see ErgoRelativeDelegateLink instead.
 * @public
 */
export interface RelativeDelegateLink {
    uutName: /*minStructField*/ string
    delegateValidatorHash: /*minStructField*/ ValidatorHash | undefined
    config: /*minStructField*/ number[]
}


/**
 * An ergonomic, though less strictly-safe form of RelativeDelegateLink
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the RelativeDelegateLinkLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type ErgoRelativeDelegateLink = RelativeDelegateLink/*like canon-other*/

/**
 * A strong type for the permissive form of RelativeDelegateLink
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface RelativeDelegateLinkLike {
    uutName: /*minStructField*/ string
    delegateValidatorHash: /*minStructField*/ ValidatorHash | string | number[] | undefined
    config: /*minStructField*/ number[]
}



/**
 * A strong type for the canonical form of ManifestEntryType$DgDataPolicy
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see ManifestEntryType$Ergo$DgDataPolicy instead.
 * @public
 */
export interface ManifestEntryType$DgDataPolicy {
    policyLink: RelativeDelegateLink  /*minVariantField*/ ,
    idPrefix: string  /*minVariantField*/ ,
    refCount: bigint  /*minVariantField*/ 
}


/**
 * An ergonomic, though less strictly-safe form of ManifestEntryType$DgDataPolicy
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the ManifestEntryType$DgDataPolicyLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type ManifestEntryType$Ergo$DgDataPolicy = {
    policyLink: ErgoRelativeDelegateLink  /*minVariantField*/ ,
    idPrefix: string  /*minVariantField*/ ,
    refCount: bigint  /*minVariantField*/ 
}


/**
 * A strong type for the permissive form of ManifestEntryType$DgDataPolicy
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface ManifestEntryType$DgDataPolicyLike {
    policyLink: RelativeDelegateLinkLike  /*minVariantField*/ ,
    idPrefix: string  /*minVariantField*/ ,
    refCount: IntLike  /*minVariantField*/ 
}



export type DelegateRoleMeta = EnumTypeMeta<
    {module: "CapoDelegateHelpers", enumName: "DelegateRole"}, {
        MintDgt: singleEnumVariantMeta<DelegateRoleMeta, "MintDgt",
            "Constr#0", "tagOnly", tagOnly, "noSpecialFlags"
        >,
        SpendDgt: singleEnumVariantMeta<DelegateRoleMeta, "SpendDgt",
            "Constr#1", "tagOnly", tagOnly, "noSpecialFlags"
        >,
        MintInvariant: singleEnumVariantMeta<DelegateRoleMeta, "MintInvariant",
            "Constr#2", "tagOnly", tagOnly, "noSpecialFlags"
        >,
        SpendInvariant: singleEnumVariantMeta<DelegateRoleMeta, "SpendInvariant",
            "Constr#3", "tagOnly", tagOnly, "noSpecialFlags"
        >,
        DgDataPolicy: singleEnumVariantMeta<DelegateRoleMeta, "DgDataPolicy",
            "Constr#4", "singletonField", /* implied wrapper { name: ... } for singleVariantField */ 
			string   , "noSpecialFlags"
        >,
        OtherNamedDgt: singleEnumVariantMeta<DelegateRoleMeta, "OtherNamedDgt",
            "Constr#5", "singletonField", /* implied wrapper { name: ... } for singleVariantField */ 
			string   , "noSpecialFlags"
        >,
        BothMintAndSpendDgt: singleEnumVariantMeta<DelegateRoleMeta, "BothMintAndSpendDgt",
            "Constr#6", "tagOnly", tagOnly, "noSpecialFlags"
        >,
        HandledByCapoOnly: singleEnumVariantMeta<DelegateRoleMeta, "HandledByCapoOnly",
            "Constr#7", "tagOnly", tagOnly, "noSpecialFlags"
        >
    }
>;


/**
 * DelegateRole enum variants
 * 
 * @remarks - expresses the essential raw data structures
 * supporting the **8 variant(s)** of the DelegateRole enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `DelegateRoleHelper` class
 *     for generating UPLC data for this enum type
 * @public
 */
export type DelegateRole = 
        | { MintDgt: tagOnly /*minEnumVariant*/ }
        | { SpendDgt: tagOnly /*minEnumVariant*/ }
        | { MintInvariant: tagOnly /*minEnumVariant*/ }
        | { SpendInvariant: tagOnly /*minEnumVariant*/ }
        | { DgDataPolicy: /* implied wrapper { name: ... } for singleVariantField */ 
			string    /*minEnumVariant*/ }
        | { OtherNamedDgt: /* implied wrapper { name: ... } for singleVariantField */ 
			string    /*minEnumVariant*/ }
        | { BothMintAndSpendDgt: tagOnly /*minEnumVariant*/ }
        | { HandledByCapoOnly: tagOnly /*minEnumVariant*/ }

/**
 * ergonomic type enabling easy access to values converted from the on-chain form
 * @remarks
 * The data will be expressed in canonical form, and enum variants are merged to a single type with optional fields.
 * Nested enums are also merged in this ergonomic way.
 * @public
 */
export type ErgoDelegateRole = IntersectedEnum<DelegateRole/*like canon enum*/>

/**
 * DelegateRole enum variants (permissive)
 * 
 * @remarks - expresses the allowable data structure
 * for creating any of the **8 variant(s)** of the DelegateRole enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `DelegateRoleHelper` class
 *     for generating UPLC data for this enum type
 *
 * #### Permissive Type
 * This is a permissive type that allows additional input data types, which are 
 * converted by convention to the canonical types used in the on-chain context.
 * @public
 */
export type DelegateRoleLike = IntersectedEnum<
        | { MintDgt: tagOnly /*minEnumVariant*/ }
        | { SpendDgt: tagOnly /*minEnumVariant*/ }
        | { MintInvariant: tagOnly /*minEnumVariant*/ }
        | { SpendInvariant: tagOnly /*minEnumVariant*/ }
        | { DgDataPolicy: /* implied wrapper { name: ... } for singleVariantField */ 
			string    /*minEnumVariant*/ }
        | { OtherNamedDgt: /* implied wrapper { name: ... } for singleVariantField */ 
			string    /*minEnumVariant*/ }
        | { BothMintAndSpendDgt: tagOnly /*minEnumVariant*/ }
        | { HandledByCapoOnly: tagOnly /*minEnumVariant*/ }
>

/**
 * A strong type for the canonical form of ManifestEntryType$DelegateThreads
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see ManifestEntryType$Ergo$DelegateThreads instead.
 * @public
 */
export interface ManifestEntryType$DelegateThreads {
    role: DelegateRole  /*minVariantField*/ ,
    refCount: bigint  /*minVariantField*/ 
}


/**
 * An ergonomic, though less strictly-safe form of ManifestEntryType$DelegateThreads
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the ManifestEntryType$DelegateThreadsLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type ManifestEntryType$Ergo$DelegateThreads = {
    role: ErgoDelegateRole  /*minVariantField*/ ,
    refCount: bigint  /*minVariantField*/ 
}


/**
 * A strong type for the permissive form of ManifestEntryType$DelegateThreads
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface ManifestEntryType$DelegateThreadsLike {
    role: DelegateRoleLike  /*minVariantField*/ ,
    refCount: IntLike  /*minVariantField*/ 
}



export type ManifestEntryTypeMeta = EnumTypeMeta<
    {module: "CapoHelpers", enumName: "ManifestEntryType"}, {
        NamedTokenRef: singleEnumVariantMeta<ManifestEntryTypeMeta, "NamedTokenRef",
            "Constr#0", "tagOnly", tagOnly, "noSpecialFlags"
        >,
        DgDataPolicy: singleEnumVariantMeta<ManifestEntryTypeMeta, "DgDataPolicy",
            "Constr#1", 
            "fields", ManifestEntryType$DgDataPolicy, "noSpecialFlags"
        >,
        DelegateThreads: singleEnumVariantMeta<ManifestEntryTypeMeta, "DelegateThreads",
            "Constr#2", 
            "fields", ManifestEntryType$DelegateThreads, "noSpecialFlags"
        >,
        MerkleMembership: singleEnumVariantMeta<ManifestEntryTypeMeta, "MerkleMembership",
            "Constr#3", "tagOnly", tagOnly, "noSpecialFlags"
        >,
        MerkleStateRoot: singleEnumVariantMeta<ManifestEntryTypeMeta, "MerkleStateRoot",
            "Constr#4", "tagOnly", tagOnly, "noSpecialFlags"
        >
    }
>;


/**
 * ManifestEntryType enum variants
 * 
 * @remarks - expresses the essential raw data structures
 * supporting the **5 variant(s)** of the ManifestEntryType enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `ManifestEntryTypeHelper` class
 *     for generating UPLC data for this enum type
 * @public
 */
export type ManifestEntryType = 
        | { NamedTokenRef: tagOnly /*minEnumVariant*/ }
        | { DgDataPolicy: ManifestEntryType$DgDataPolicy /*minEnumVariant*/ }
        | { DelegateThreads: ManifestEntryType$DelegateThreads /*minEnumVariant*/ }
        | { MerkleMembership: tagOnly /*minEnumVariant*/ }
        | { MerkleStateRoot: tagOnly /*minEnumVariant*/ }

/**
 * ergonomic type enabling easy access to values converted from the on-chain form
 * @remarks
 * The data will be expressed in canonical form, and enum variants are merged to a single type with optional fields.
 * Nested enums are also merged in this ergonomic way.
 * @public
 */
export type ErgoManifestEntryType = IntersectedEnum<
        | { NamedTokenRef: tagOnly /*minEnumVariant*/ }
        | { DgDataPolicy: ManifestEntryType$Ergo$DgDataPolicy /*minEnumVariant*/ }
        | { DelegateThreads: ManifestEntryType$Ergo$DelegateThreads /*minEnumVariant*/ }
        | { MerkleMembership: tagOnly /*minEnumVariant*/ }
        | { MerkleStateRoot: tagOnly /*minEnumVariant*/ }
>

/**
 * ManifestEntryType enum variants (permissive)
 * 
 * @remarks - expresses the allowable data structure
 * for creating any of the **5 variant(s)** of the ManifestEntryType enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `ManifestEntryTypeHelper` class
 *     for generating UPLC data for this enum type
 *
 * #### Permissive Type
 * This is a permissive type that allows additional input data types, which are 
 * converted by convention to the canonical types used in the on-chain context.
 * @public
 */
export type ManifestEntryTypeLike = IntersectedEnum<
        | { NamedTokenRef: tagOnly /*minEnumVariant*/ }
        | { DgDataPolicy: ManifestEntryType$DgDataPolicyLike /*minEnumVariant*/ }
        | { DelegateThreads: ManifestEntryType$DelegateThreadsLike /*minEnumVariant*/ }
        | { MerkleMembership: tagOnly /*minEnumVariant*/ }
        | { MerkleStateRoot: tagOnly /*minEnumVariant*/ }
>

/**
 * A strong type for the canonical form of CapoManifestEntry
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see ErgoCapoManifestEntry instead.
 * @public
 */
export interface CapoManifestEntry {
    entryType: /*minStructField*/ ManifestEntryType
    tokenName: /*minStructField*/ number[]
    mph: /*minStructField*/ MintingPolicyHash | undefined
}


/**
 * An ergonomic, though less strictly-safe form of CapoManifestEntry
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the CapoManifestEntryLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type ErgoCapoManifestEntry = {
    entryType: /*minStructField*/ ErgoManifestEntryType
    tokenName: /*minStructField*/ number[]
    mph: /*minStructField*/ MintingPolicyHash | undefined
}


/**
 * A strong type for the permissive form of CapoManifestEntry
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface CapoManifestEntryLike {
    entryType: /*minStructField*/ ManifestEntryTypeLike
    tokenName: /*minStructField*/ number[]
    mph: /*minStructField*/ MintingPolicyHash | string | number[] | undefined
}



/**
 * A strong type for the canonical form of PendingDelegateAction$Add
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see PendingDelegateAction$Ergo$Add instead.
 * @public
 */
export interface PendingDelegateAction$Add {
    seed: TxOutputId  /*minVariantField*/ ,
    purpose: string  /*minVariantField*/ ,
    idPrefix: string  /*minVariantField*/ 
}


/**
 * An ergonomic, though less strictly-safe form of PendingDelegateAction$Add
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the PendingDelegateAction$AddLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type PendingDelegateAction$Ergo$Add = PendingDelegateAction$Add  /*ergo like-canonical-this-variant*/

/**
 * A strong type for the permissive form of PendingDelegateAction$Add
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface PendingDelegateAction$AddLike {
    seed: TxOutputId | string  /*minVariantField*/ ,
    purpose: string  /*minVariantField*/ ,
    idPrefix: string  /*minVariantField*/ 
}



/**
 * A strong type for the canonical form of PendingDelegateAction$Replace
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see PendingDelegateAction$Ergo$Replace instead.
 * @public
 */
export interface PendingDelegateAction$Replace {
    seed: TxOutputId  /*minVariantField*/ ,
    purpose: string  /*minVariantField*/ ,
    idPrefix: string  /*minVariantField*/ ,
    replacesDgt: AssetClass  /*minVariantField*/ 
}


/**
 * An ergonomic, though less strictly-safe form of PendingDelegateAction$Replace
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the PendingDelegateAction$ReplaceLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type PendingDelegateAction$Ergo$Replace = PendingDelegateAction$Replace  /*ergo like-canonical-this-variant*/

/**
 * A strong type for the permissive form of PendingDelegateAction$Replace
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface PendingDelegateAction$ReplaceLike {
    seed: TxOutputId | string  /*minVariantField*/ ,
    purpose: string  /*minVariantField*/ ,
    idPrefix: string  /*minVariantField*/ ,
    replacesDgt: AssetClass | string | [string | MintingPolicyHash | number[], string | number[]] | {mph: MintingPolicyHash | string | number[], tokenName: string | number[]}  /*minVariantField*/ 
}



export type PendingDelegateActionMeta = EnumTypeMeta<
    {module: "CapoDelegateHelpers", enumName: "PendingDelegateAction"}, {
        Add: singleEnumVariantMeta<PendingDelegateActionMeta, "Add",
            "Constr#0", 
            "fields", PendingDelegateAction$Add, "isSeededActivity"
        >,
        Remove: singleEnumVariantMeta<PendingDelegateActionMeta, "Remove",
            "Constr#1", "tagOnly", tagOnly, "noSpecialFlags"
        >,
        Replace: singleEnumVariantMeta<PendingDelegateActionMeta, "Replace",
            "Constr#2", 
            "fields", PendingDelegateAction$Replace, "isSeededActivity"
        >
    }
>;


/**
 * PendingDelegateAction enum variants
 * 
 * @remarks - expresses the essential raw data structures
 * supporting the **3 variant(s)** of the PendingDelegateAction enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `PendingDelegateActionHelper` class
 *     for generating UPLC data for this enum type
 * @public
 */
export type PendingDelegateAction = 
        | { Add: PendingDelegateAction$Add /*minEnumVariant*/ }
        | { Remove: tagOnly /*minEnumVariant*/ }
        | { Replace: PendingDelegateAction$Replace /*minEnumVariant*/ }

/**
 * ergonomic type enabling easy access to values converted from the on-chain form
 * @remarks
 * The data will be expressed in canonical form, and enum variants are merged to a single type with optional fields.
 * Nested enums are also merged in this ergonomic way.
 * @public
 */
export type ErgoPendingDelegateAction = IntersectedEnum<
        | { Add: PendingDelegateAction$Ergo$Add /*minEnumVariant*/ }
        | { Remove: tagOnly /*minEnumVariant*/ }
        | { Replace: PendingDelegateAction$Ergo$Replace /*minEnumVariant*/ }
>

/**
 * PendingDelegateAction enum variants (permissive)
 * 
 * @remarks - expresses the allowable data structure
 * for creating any of the **3 variant(s)** of the PendingDelegateAction enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `PendingDelegateActionHelper` class
 *     for generating UPLC data for this enum type
 *
 * #### Permissive Type
 * This is a permissive type that allows additional input data types, which are 
 * converted by convention to the canonical types used in the on-chain context.
 * @public
 */
export type PendingDelegateActionLike = IntersectedEnum<
        | { Add: PendingDelegateAction$AddLike /*minEnumVariant*/ }
        | { Remove: tagOnly /*minEnumVariant*/ }
        | { Replace: PendingDelegateAction$ReplaceLike /*minEnumVariant*/ }
>

/**
 * A strong type for the canonical form of PendingDelegateChange
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see ErgoPendingDelegateChange instead.
 * @public
 */
export interface PendingDelegateChange {
    action: /*minStructField*/ PendingDelegateAction
    role: /*minStructField*/ DelegateRole
    dgtLink: /*minStructField*/ RelativeDelegateLink | undefined
}


/**
 * An ergonomic, though less strictly-safe form of PendingDelegateChange
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the PendingDelegateChangeLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type ErgoPendingDelegateChange = {
    action: /*minStructField*/ ErgoPendingDelegateAction
    role: /*minStructField*/ ErgoDelegateRole
    dgtLink: /*minStructField*/ ErgoRelativeDelegateLink | undefined
}


/**
 * A strong type for the permissive form of PendingDelegateChange
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface PendingDelegateChangeLike {
    action: /*minStructField*/ PendingDelegateActionLike
    role: /*minStructField*/ DelegateRoleLike
    dgtLink: /*minStructField*/ RelativeDelegateLinkLike | undefined
}



/**
 * A strong type for the canonical form of ManifestActivity$updatingEntry
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see ManifestActivity$Ergo$updatingEntry instead.
 * @public
 */
export interface ManifestActivity$updatingEntry {
    key: string  /*minVariantField*/ ,
    tokenName: number[]  /*minVariantField*/ 
}


/**
 * An ergonomic, though less strictly-safe form of ManifestActivity$updatingEntry
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the ManifestActivity$updatingEntryLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type ManifestActivity$Ergo$updatingEntry = ManifestActivity$updatingEntry  /*ergo like-canonical-this-variant*/

/**
 * A strong type for the permissive form of ManifestActivity$updatingEntry
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface ManifestActivity$updatingEntryLike {
    key: string  /*minVariantField*/ ,
    tokenName: number[]  /*minVariantField*/ 
}



/**
 * A strong type for the canonical form of ManifestActivity$addingEntry
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see ManifestActivity$Ergo$addingEntry instead.
 * @public
 */
export interface ManifestActivity$addingEntry {
    key: string  /*minVariantField*/ ,
    tokenName: number[]  /*minVariantField*/ 
}


/**
 * An ergonomic, though less strictly-safe form of ManifestActivity$addingEntry
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the ManifestActivity$addingEntryLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type ManifestActivity$Ergo$addingEntry = ManifestActivity$addingEntry  /*ergo like-canonical-this-variant*/

/**
 * A strong type for the permissive form of ManifestActivity$addingEntry
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface ManifestActivity$addingEntryLike {
    key: string  /*minVariantField*/ ,
    tokenName: number[]  /*minVariantField*/ 
}



/**
 * A strong type for the canonical form of ManifestActivity$forkingThreadToken
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see ManifestActivity$Ergo$forkingThreadToken instead.
 * @public
 */
export interface ManifestActivity$forkingThreadToken {
    key: string  /*minVariantField*/ ,
    newThreadCount: bigint  /*minVariantField*/ 
}


/**
 * An ergonomic, though less strictly-safe form of ManifestActivity$forkingThreadToken
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the ManifestActivity$forkingThreadTokenLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type ManifestActivity$Ergo$forkingThreadToken = ManifestActivity$forkingThreadToken  /*ergo like-canonical-this-variant*/

/**
 * A strong type for the permissive form of ManifestActivity$forkingThreadToken
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface ManifestActivity$forkingThreadTokenLike {
    key: string  /*minVariantField*/ ,
    newThreadCount: IntLike  /*minVariantField*/ 
}



/**
 * A strong type for the canonical form of ManifestActivity$burningThreadToken
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see ManifestActivity$Ergo$burningThreadToken instead.
 * @public
 */
export interface ManifestActivity$burningThreadToken {
    key: string  /*minVariantField*/ ,
    burnedThreadCount: bigint  /*minVariantField*/ 
}


/**
 * An ergonomic, though less strictly-safe form of ManifestActivity$burningThreadToken
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the ManifestActivity$burningThreadTokenLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type ManifestActivity$Ergo$burningThreadToken = ManifestActivity$burningThreadToken  /*ergo like-canonical-this-variant*/

/**
 * A strong type for the permissive form of ManifestActivity$burningThreadToken
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface ManifestActivity$burningThreadTokenLike {
    key: string  /*minVariantField*/ ,
    burnedThreadCount: IntLike  /*minVariantField*/ 
}



export type ManifestActivityMeta = EnumTypeMeta<
    {module: "CapoDelegateHelpers", enumName: "ManifestActivity"}, {
        retiringEntry: singleEnumVariantMeta<ManifestActivityMeta, "retiringEntry",
            "Constr#0", "singletonField", /* implied wrapper { key: ... } for singleVariantField */ 
			string   , "noSpecialFlags"
        >,
        updatingEntry: singleEnumVariantMeta<ManifestActivityMeta, "updatingEntry",
            "Constr#1", 
            "fields", ManifestActivity$updatingEntry, "noSpecialFlags"
        >,
        addingEntry: singleEnumVariantMeta<ManifestActivityMeta, "addingEntry",
            "Constr#2", 
            "fields", ManifestActivity$addingEntry, "noSpecialFlags"
        >,
        forkingThreadToken: singleEnumVariantMeta<ManifestActivityMeta, "forkingThreadToken",
            "Constr#3", 
            "fields", ManifestActivity$forkingThreadToken, "noSpecialFlags"
        >,
        burningThreadToken: singleEnumVariantMeta<ManifestActivityMeta, "burningThreadToken",
            "Constr#4", 
            "fields", ManifestActivity$burningThreadToken, "noSpecialFlags"
        >
    }
>;


/**
 * ManifestActivity enum variants
 * 
 * @remarks - expresses the essential raw data structures
 * supporting the **5 variant(s)** of the ManifestActivity enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `ManifestActivityHelper` class
 *     for generating UPLC data for this enum type
 * @public
 */
export type ManifestActivity = 
        | { retiringEntry: /* implied wrapper { key: ... } for singleVariantField */ 
			string    /*minEnumVariant*/ }
        | { updatingEntry: ManifestActivity$updatingEntry /*minEnumVariant*/ }
        | { addingEntry: ManifestActivity$addingEntry /*minEnumVariant*/ }
        | { forkingThreadToken: ManifestActivity$forkingThreadToken /*minEnumVariant*/ }
        | { burningThreadToken: ManifestActivity$burningThreadToken /*minEnumVariant*/ }

/**
 * ergonomic type enabling easy access to values converted from the on-chain form
 * @remarks
 * The data will be expressed in canonical form, and enum variants are merged to a single type with optional fields.
 * Nested enums are also merged in this ergonomic way.
 * @public
 */
export type ErgoManifestActivity = IntersectedEnum<
        | { retiringEntry: /* implied wrapper { key: ... } for singleVariantField */ 
			string    /*minEnumVariant*/ }
        | { updatingEntry: ManifestActivity$Ergo$updatingEntry /*minEnumVariant*/ }
        | { addingEntry: ManifestActivity$Ergo$addingEntry /*minEnumVariant*/ }
        | { forkingThreadToken: ManifestActivity$Ergo$forkingThreadToken /*minEnumVariant*/ }
        | { burningThreadToken: ManifestActivity$Ergo$burningThreadToken /*minEnumVariant*/ }
>

/**
 * ManifestActivity enum variants (permissive)
 * 
 * @remarks - expresses the allowable data structure
 * for creating any of the **5 variant(s)** of the ManifestActivity enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `ManifestActivityHelper` class
 *     for generating UPLC data for this enum type
 *
 * #### Permissive Type
 * This is a permissive type that allows additional input data types, which are 
 * converted by convention to the canonical types used in the on-chain context.
 * @public
 */
export type ManifestActivityLike = IntersectedEnum<
        | { retiringEntry: /* implied wrapper { key: ... } for singleVariantField */ 
			string    /*minEnumVariant*/ }
        | { updatingEntry: ManifestActivity$updatingEntryLike /*minEnumVariant*/ }
        | { addingEntry: ManifestActivity$addingEntryLike /*minEnumVariant*/ }
        | { forkingThreadToken: ManifestActivity$forkingThreadTokenLike /*minEnumVariant*/ }
        | { burningThreadToken: ManifestActivity$burningThreadTokenLike /*minEnumVariant*/ }
>

/**
 * A strong type for the canonical form of PendingCharterChange$otherManifestChange
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see PendingCharterChange$Ergo$otherManifestChange instead.
 * @public
 */
export interface PendingCharterChange$otherManifestChange {
    activity: ManifestActivity  /*minVariantField*/ ,
    remainingDelegateValidations: Array<DelegateRole>  /*minVariantField*/ 
}


/**
 * An ergonomic, though less strictly-safe form of PendingCharterChange$otherManifestChange
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the PendingCharterChange$otherManifestChangeLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type PendingCharterChange$Ergo$otherManifestChange = {
    activity: ErgoManifestActivity  /*minVariantField*/ ,
    remainingDelegateValidations: Array<ErgoDelegateRole>  /*minVariantField*/ 
}


/**
 * A strong type for the permissive form of PendingCharterChange$otherManifestChange
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface PendingCharterChange$otherManifestChangeLike {
    activity: ManifestActivityLike  /*minVariantField*/ ,
    remainingDelegateValidations: Array<DelegateRoleLike>  /*minVariantField*/ 
}



export type PendingCharterChangeMeta = EnumTypeMeta<
    {module: "CapoDelegateHelpers", enumName: "PendingCharterChange"}, {
        delegateChange: singleEnumVariantMeta<PendingCharterChangeMeta, "delegateChange",
            "Constr#0", "singletonField", /* implied wrapper { change: ... } for singleVariantField */ 
			PendingDelegateChange   , "noSpecialFlags"
        >,
        otherManifestChange: singleEnumVariantMeta<PendingCharterChangeMeta, "otherManifestChange",
            "Constr#1", 
            "fields", PendingCharterChange$otherManifestChange, "noSpecialFlags"
        >
    }
>;


/**
 * PendingCharterChange enum variants
 * 
 * @remarks - expresses the essential raw data structures
 * supporting the **2 variant(s)** of the PendingCharterChange enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `PendingCharterChangeHelper` class
 *     for generating UPLC data for this enum type
 * @public
 */
export type PendingCharterChange = 
        | { delegateChange: /* implied wrapper { change: ... } for singleVariantField */ 
			PendingDelegateChange    /*minEnumVariant*/ }
        | { otherManifestChange: PendingCharterChange$otherManifestChange /*minEnumVariant*/ }

/**
 * ergonomic type enabling easy access to values converted from the on-chain form
 * @remarks
 * The data will be expressed in canonical form, and enum variants are merged to a single type with optional fields.
 * Nested enums are also merged in this ergonomic way.
 * @public
 */
export type ErgoPendingCharterChange = IntersectedEnum<
        | { delegateChange: /* implied wrapper { change: ... } for singleVariantField */ 
			ErgoPendingDelegateChange    /*minEnumVariant*/ }
        | { otherManifestChange: PendingCharterChange$Ergo$otherManifestChange /*minEnumVariant*/ }
>

/**
 * PendingCharterChange enum variants (permissive)
 * 
 * @remarks - expresses the allowable data structure
 * for creating any of the **2 variant(s)** of the PendingCharterChange enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `PendingCharterChangeHelper` class
 *     for generating UPLC data for this enum type
 *
 * #### Permissive Type
 * This is a permissive type that allows additional input data types, which are 
 * converted by convention to the canonical types used in the on-chain context.
 * @public
 */
export type PendingCharterChangeLike = IntersectedEnum<
        | { delegateChange: /* implied wrapper { change: ... } for singleVariantField */ 
			PendingDelegateChangeLike    /*minEnumVariant*/ }
        | { otherManifestChange: PendingCharterChange$otherManifestChangeLike /*minEnumVariant*/ }
>

/**
 * A strong type for the canonical form of CapoDatum$CharterData
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see CapoDatum$Ergo$CharterData instead.
 * @public
 */
export interface CapoDatum$CharterData {
    spendDelegateLink: RelativeDelegateLink  /*minVariantField*/ ,
    spendInvariants: Array<RelativeDelegateLink>  /*minVariantField*/ ,
    otherNamedDelegates: Map<string, RelativeDelegateLink>  /*minVariantField*/ ,
    mintDelegateLink: RelativeDelegateLink  /*minVariantField*/ ,
    mintInvariants: Array<RelativeDelegateLink>  /*minVariantField*/ ,
    govAuthorityLink: RelativeDelegateLink  /*minVariantField*/ ,
    manifest: Map<string, CapoManifestEntry>  /*minVariantField*/ ,
    pendingChanges: Array<PendingCharterChange>  /*minVariantField*/ 
}


/**
 * An ergonomic, though less strictly-safe form of CapoDatum$CharterData
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the CapoDatum$CharterDataLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type CapoDatum$Ergo$CharterData = {
    spendDelegateLink: ErgoRelativeDelegateLink  /*minVariantField*/ ,
    spendInvariants: Array<ErgoRelativeDelegateLink>  /*minVariantField*/ ,
    otherNamedDelegates: Map<string, ErgoRelativeDelegateLink>  /*minVariantField*/ ,
    mintDelegateLink: ErgoRelativeDelegateLink  /*minVariantField*/ ,
    mintInvariants: Array<ErgoRelativeDelegateLink>  /*minVariantField*/ ,
    govAuthorityLink: ErgoRelativeDelegateLink  /*minVariantField*/ ,
    manifest: Map<string, ErgoCapoManifestEntry>  /*minVariantField*/ ,
    pendingChanges: Array<ErgoPendingCharterChange>  /*minVariantField*/ 
}


/**
 * A strong type for the permissive form of CapoDatum$CharterData
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface CapoDatum$CharterDataLike {
    spendDelegateLink: RelativeDelegateLinkLike  /*minVariantField*/ ,
    spendInvariants: Array<RelativeDelegateLinkLike>  /*minVariantField*/ ,
    otherNamedDelegates: Map<string, RelativeDelegateLinkLike>  /*minVariantField*/ ,
    mintDelegateLink: RelativeDelegateLinkLike  /*minVariantField*/ ,
    mintInvariants: Array<RelativeDelegateLinkLike>  /*minVariantField*/ ,
    govAuthorityLink: RelativeDelegateLinkLike  /*minVariantField*/ ,
    manifest: Map<string, CapoManifestEntryLike>  /*minVariantField*/ ,
    pendingChanges: Array<PendingCharterChangeLike>  /*minVariantField*/ 
}



/**
 * A strong type for the canonical form of CapoDatum$DelegatedData
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see CapoDatum$Ergo$DelegatedData instead.
 * @public
 */
export interface CapoDatum$DelegatedData {
    data: Map<string, UplcData>  /*minVariantField*/ ,
    version: bigint  /*minVariantField*/ ,
    otherDetails: UplcData  /*minVariantField*/ 
}


/**
 * An ergonomic, though less strictly-safe form of CapoDatum$DelegatedData
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the CapoDatum$DelegatedDataLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type CapoDatum$Ergo$DelegatedData = CapoDatum$DelegatedData  /*ergo like-canonical-this-variant*/

/**
 * A strong type for the permissive form of CapoDatum$DelegatedData
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface CapoDatum$DelegatedDataLike {
    data: Map<string, UplcData>  /*minVariantField*/ ,
    version: IntLike  /*minVariantField*/ ,
    otherDetails: UplcData  /*minVariantField*/ 
}



export type CapoDatumMeta = EnumTypeMeta<
    {module: "CapoHelpers", enumName: "CapoDatum"}, {
        CharterData: singleEnumVariantMeta<CapoDatumMeta, "CharterData",
            "Constr#0", 
            "fields", CapoDatum$CharterData, "noSpecialFlags"
        >,
        ScriptReference: singleEnumVariantMeta<CapoDatumMeta, "ScriptReference",
            "Constr#1", "tagOnly", tagOnly, "noSpecialFlags"
        >,
        DelegatedData: singleEnumVariantMeta<CapoDatumMeta, "DelegatedData",
            "Constr#2", 
            "fields", CapoDatum$DelegatedData, "noSpecialFlags"
        >
    }
>;


/**
 * CapoDatum enum variants
 * 
 * @remarks - expresses the essential raw data structures
 * supporting the **3 variant(s)** of the CapoDatum enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `CapoDatumHelper` class
 *     for generating UPLC data for this enum type
 * @public
 */
export type CapoDatum = 
        | { CharterData: CapoDatum$CharterData /*minEnumVariant*/ }
        | { ScriptReference: tagOnly /*minEnumVariant*/ }
        | { DelegatedData: CapoDatum$DelegatedData /*minEnumVariant*/ }

/**
 * ergonomic type enabling easy access to values converted from the on-chain form
 * @remarks
 * The data will be expressed in canonical form, and enum variants are merged to a single type with optional fields.
 * Nested enums are also merged in this ergonomic way.
 * @public
 */
export type ErgoCapoDatum = IntersectedEnum<
        | { CharterData: CapoDatum$Ergo$CharterData /*minEnumVariant*/ }
        | { ScriptReference: tagOnly /*minEnumVariant*/ }
        | { DelegatedData: CapoDatum$Ergo$DelegatedData /*minEnumVariant*/ }
>

/**
 * CapoDatum enum variants (permissive)
 * 
 * @remarks - expresses the allowable data structure
 * for creating any of the **3 variant(s)** of the CapoDatum enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `CapoDatumHelper` class
 *     for generating UPLC data for this enum type
 *
 * #### Permissive Type
 * This is a permissive type that allows additional input data types, which are 
 * converted by convention to the canonical types used in the on-chain context.
 * @public
 */
export type CapoDatumLike = IntersectedEnum<
        | { CharterData: CapoDatum$CharterDataLike /*minEnumVariant*/ }
        | { ScriptReference: tagOnly /*minEnumVariant*/ }
        | { DelegatedData: CapoDatum$DelegatedDataLike /*minEnumVariant*/ }
>

/**
 * A strong type for the canonical form of CapoLifecycleActivity$CreatingDelegate
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see CapoLifecycleActivity$Ergo$CreatingDelegate instead.
 * @public
 */
export interface CapoLifecycleActivity$CreatingDelegate {
    seed: TxOutputId  /*minVariantField*/ ,
    purpose: string  /*minVariantField*/ 
}


/**
 * An ergonomic, though less strictly-safe form of CapoLifecycleActivity$CreatingDelegate
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the CapoLifecycleActivity$CreatingDelegateLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type CapoLifecycleActivity$Ergo$CreatingDelegate = CapoLifecycleActivity$CreatingDelegate  /*ergo like-canonical-this-variant*/

/**
 * A strong type for the permissive form of CapoLifecycleActivity$CreatingDelegate
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface CapoLifecycleActivity$CreatingDelegateLike {
    seed: TxOutputId | string  /*minVariantField*/ ,
    purpose: string  /*minVariantField*/ 
}



/**
 * A strong type for the canonical form of CapoLifecycleActivity$forcingNewSpendDelegate
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see CapoLifecycleActivity$Ergo$forcingNewSpendDelegate instead.
 * @public
 */
export interface CapoLifecycleActivity$forcingNewSpendDelegate {
    seed: TxOutputId  /*minVariantField*/ ,
    purpose: string  /*minVariantField*/ 
}


/**
 * An ergonomic, though less strictly-safe form of CapoLifecycleActivity$forcingNewSpendDelegate
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the CapoLifecycleActivity$forcingNewSpendDelegateLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type CapoLifecycleActivity$Ergo$forcingNewSpendDelegate = CapoLifecycleActivity$forcingNewSpendDelegate  /*ergo like-canonical-this-variant*/

/**
 * A strong type for the permissive form of CapoLifecycleActivity$forcingNewSpendDelegate
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface CapoLifecycleActivity$forcingNewSpendDelegateLike {
    seed: TxOutputId | string  /*minVariantField*/ ,
    purpose: string  /*minVariantField*/ 
}



/**
 * A strong type for the canonical form of CapoLifecycleActivity$forcingNewMintDelegate
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see CapoLifecycleActivity$Ergo$forcingNewMintDelegate instead.
 * @public
 */
export interface CapoLifecycleActivity$forcingNewMintDelegate {
    seed: TxOutputId  /*minVariantField*/ ,
    purpose: string  /*minVariantField*/ 
}


/**
 * An ergonomic, though less strictly-safe form of CapoLifecycleActivity$forcingNewMintDelegate
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the CapoLifecycleActivity$forcingNewMintDelegateLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type CapoLifecycleActivity$Ergo$forcingNewMintDelegate = CapoLifecycleActivity$forcingNewMintDelegate  /*ergo like-canonical-this-variant*/

/**
 * A strong type for the permissive form of CapoLifecycleActivity$forcingNewMintDelegate
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface CapoLifecycleActivity$forcingNewMintDelegateLike {
    seed: TxOutputId | string  /*minVariantField*/ ,
    purpose: string  /*minVariantField*/ 
}



export type CapoLifecycleActivityMeta = EnumTypeMeta<
    {module: "CapoDelegateHelpers", enumName: "CapoLifecycleActivity"}, {
        CreatingDelegate: singleEnumVariantMeta<CapoLifecycleActivityMeta, "CreatingDelegate",
            "Constr#0", 
            "fields", CapoLifecycleActivity$CreatingDelegate, "isSeededActivity"
        >,
        queuePendingChange: singleEnumVariantMeta<CapoLifecycleActivityMeta, "queuePendingChange",
            "Constr#1", "tagOnly", tagOnly, "noSpecialFlags"
        >,
        removePendingChange: singleEnumVariantMeta<CapoLifecycleActivityMeta, "removePendingChange",
            "Constr#2", "singletonField", /* implied wrapper { role: ... } for singleVariantField */ 
			DelegateRole   , "noSpecialFlags"
        >,
        commitPendingChanges: singleEnumVariantMeta<CapoLifecycleActivityMeta, "commitPendingChanges",
            "Constr#3", "tagOnly", tagOnly, "noSpecialFlags"
        >,
        forcingNewSpendDelegate: singleEnumVariantMeta<CapoLifecycleActivityMeta, "forcingNewSpendDelegate",
            "Constr#4", 
            "fields", CapoLifecycleActivity$forcingNewSpendDelegate, "isSeededActivity"
        >,
        forcingNewMintDelegate: singleEnumVariantMeta<CapoLifecycleActivityMeta, "forcingNewMintDelegate",
            "Constr#5", 
            "fields", CapoLifecycleActivity$forcingNewMintDelegate, "isSeededActivity"
        >,
        updatingManifest: singleEnumVariantMeta<CapoLifecycleActivityMeta, "updatingManifest",
            "Constr#6", "singletonField", /* implied wrapper { activity: ... } for singleVariantField */ 
			ManifestActivity   , "noSpecialFlags"
        >
    }
>;


/**
 * CapoLifecycleActivity enum variants
 * 
 * @remarks - expresses the essential raw data structures
 * supporting the **7 variant(s)** of the CapoLifecycleActivity enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `CapoLifecycleActivityHelper` class
 *     for generating UPLC data for this enum type
 * @public
 */
export type CapoLifecycleActivity = 
        | { CreatingDelegate: CapoLifecycleActivity$CreatingDelegate /*minEnumVariant*/ }
        | { queuePendingChange: tagOnly /*minEnumVariant*/ }
        | { removePendingChange: /* implied wrapper { role: ... } for singleVariantField */ 
			DelegateRole    /*minEnumVariant*/ }
        | { commitPendingChanges: tagOnly /*minEnumVariant*/ }
        | { forcingNewSpendDelegate: CapoLifecycleActivity$forcingNewSpendDelegate /*minEnumVariant*/ }
        | { forcingNewMintDelegate: CapoLifecycleActivity$forcingNewMintDelegate /*minEnumVariant*/ }
        | { updatingManifest: /* implied wrapper { activity: ... } for singleVariantField */ 
			ManifestActivity    /*minEnumVariant*/ }

/**
 * ergonomic type enabling easy access to values converted from the on-chain form
 * @remarks
 * The data will be expressed in canonical form, and enum variants are merged to a single type with optional fields.
 * Nested enums are also merged in this ergonomic way.
 * @public
 */
export type ErgoCapoLifecycleActivity = IntersectedEnum<
        | { CreatingDelegate: CapoLifecycleActivity$Ergo$CreatingDelegate /*minEnumVariant*/ }
        | { queuePendingChange: tagOnly /*minEnumVariant*/ }
        | { removePendingChange: /* implied wrapper { role: ... } for singleVariantField */ 
			ErgoDelegateRole    /*minEnumVariant*/ }
        | { commitPendingChanges: tagOnly /*minEnumVariant*/ }
        | { forcingNewSpendDelegate: CapoLifecycleActivity$Ergo$forcingNewSpendDelegate /*minEnumVariant*/ }
        | { forcingNewMintDelegate: CapoLifecycleActivity$Ergo$forcingNewMintDelegate /*minEnumVariant*/ }
        | { updatingManifest: /* implied wrapper { activity: ... } for singleVariantField */ 
			ErgoManifestActivity    /*minEnumVariant*/ }
>

/**
 * CapoLifecycleActivity enum variants (permissive)
 * 
 * @remarks - expresses the allowable data structure
 * for creating any of the **7 variant(s)** of the CapoLifecycleActivity enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `CapoLifecycleActivityHelper` class
 *     for generating UPLC data for this enum type
 *
 * #### Permissive Type
 * This is a permissive type that allows additional input data types, which are 
 * converted by convention to the canonical types used in the on-chain context.
 * @public
 */
export type CapoLifecycleActivityLike = IntersectedEnum<
        | { CreatingDelegate: CapoLifecycleActivity$CreatingDelegateLike /*minEnumVariant*/ }
        | { queuePendingChange: tagOnly /*minEnumVariant*/ }
        | { removePendingChange: /* implied wrapper { role: ... } for singleVariantField */ 
			DelegateRoleLike    /*minEnumVariant*/ }
        | { commitPendingChanges: tagOnly /*minEnumVariant*/ }
        | { forcingNewSpendDelegate: CapoLifecycleActivity$forcingNewSpendDelegateLike /*minEnumVariant*/ }
        | { forcingNewMintDelegate: CapoLifecycleActivity$forcingNewMintDelegateLike /*minEnumVariant*/ }
        | { updatingManifest: /* implied wrapper { activity: ... } for singleVariantField */ 
			ManifestActivityLike    /*minEnumVariant*/ }
>

export type CapoActivityMeta = EnumTypeMeta<
    {module: "CapoHelpers", enumName: "CapoActivity"}, {
        capoLifecycleActivity: singleEnumVariantMeta<CapoActivityMeta, "capoLifecycleActivity",
            "Constr#0", "singletonField", /* implied wrapper { activity: ... } for singleVariantField */ 
			CapoLifecycleActivity   , "noSpecialFlags"
        >,
        usingAuthority: singleEnumVariantMeta<CapoActivityMeta, "usingAuthority",
            "Constr#1", "tagOnly", tagOnly, "noSpecialFlags"
        >,
        retiringRefScript: singleEnumVariantMeta<CapoActivityMeta, "retiringRefScript",
            "Constr#2", "tagOnly", tagOnly, "noSpecialFlags"
        >,
        addingSpendInvariant: singleEnumVariantMeta<CapoActivityMeta, "addingSpendInvariant",
            "Constr#3", "tagOnly", tagOnly, "noSpecialFlags"
        >,
        spendingDelegatedDatum: singleEnumVariantMeta<CapoActivityMeta, "spendingDelegatedDatum",
            "Constr#4", "tagOnly", tagOnly, "noSpecialFlags"
        >,
        updatingCharter: singleEnumVariantMeta<CapoActivityMeta, "updatingCharter",
            "Constr#5", "tagOnly", tagOnly, "noSpecialFlags"
        >
    }
>;


/**
 * CapoActivity enum variants
 * 
 * @remarks - expresses the essential raw data structures
 * supporting the **6 variant(s)** of the CapoActivity enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `CapoActivityHelper` class
 *     for generating UPLC data for this enum type
 * @public
 */
export type CapoActivity = 
        | { capoLifecycleActivity: /* implied wrapper { activity: ... } for singleVariantField */ 
			CapoLifecycleActivity    /*minEnumVariant*/ }
        | { usingAuthority: tagOnly /*minEnumVariant*/ }
        | { retiringRefScript: tagOnly /*minEnumVariant*/ }
        | { addingSpendInvariant: tagOnly /*minEnumVariant*/ }
        | { spendingDelegatedDatum: tagOnly /*minEnumVariant*/ }
        | { updatingCharter: tagOnly /*minEnumVariant*/ }

/**
 * ergonomic type enabling easy access to values converted from the on-chain form
 * @remarks
 * The data will be expressed in canonical form, and enum variants are merged to a single type with optional fields.
 * Nested enums are also merged in this ergonomic way.
 * @public
 */
export type ErgoCapoActivity = IntersectedEnum<
        | { capoLifecycleActivity: /* implied wrapper { activity: ... } for singleVariantField */ 
			ErgoCapoLifecycleActivity    /*minEnumVariant*/ }
        | { usingAuthority: tagOnly /*minEnumVariant*/ }
        | { retiringRefScript: tagOnly /*minEnumVariant*/ }
        | { addingSpendInvariant: tagOnly /*minEnumVariant*/ }
        | { spendingDelegatedDatum: tagOnly /*minEnumVariant*/ }
        | { updatingCharter: tagOnly /*minEnumVariant*/ }
>

/**
 * CapoActivity enum variants (permissive)
 * 
 * @remarks - expresses the allowable data structure
 * for creating any of the **6 variant(s)** of the CapoActivity enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `CapoActivityHelper` class
 *     for generating UPLC data for this enum type
 *
 * #### Permissive Type
 * This is a permissive type that allows additional input data types, which are 
 * converted by convention to the canonical types used in the on-chain context.
 * @public
 */
export type CapoActivityLike = IntersectedEnum<
        | { capoLifecycleActivity: /* implied wrapper { activity: ... } for singleVariantField */ 
			CapoLifecycleActivityLike    /*minEnumVariant*/ }
        | { usingAuthority: tagOnly /*minEnumVariant*/ }
        | { retiringRefScript: tagOnly /*minEnumVariant*/ }
        | { addingSpendInvariant: tagOnly /*minEnumVariant*/ }
        | { spendingDelegatedDatum: tagOnly /*minEnumVariant*/ }
        | { updatingCharter: tagOnly /*minEnumVariant*/ }
>

/**
 * A strong type for the canonical form of AnyData
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see ErgoAnyData instead.
 * @public
 */
export interface AnyData {
    id: /*minStructField*/ number[]
    type: /*minStructField*/ string
}


/**
 * An ergonomic, though less strictly-safe form of AnyData
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the AnyDataLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type ErgoAnyData = AnyData/*like canon-other*/

/**
 * A strong type for the permissive form of AnyData
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface AnyDataLike {
    id: /*minStructField*/ number[]
    type: /*minStructField*/ string
}


/**
 * expresses the essential fields needed for initiating creation of a AnyData
 * @public
 */
export type minimalAnyData = minimalData<AnyDataLike>

