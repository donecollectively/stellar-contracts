
import type {
    anyTypeDetails,
    EnumId,
    EnumTypeMeta,
    enumTypeDetails,
    HeliosBundleTypeDetails,
    HeliosBundleTypes, makesUplcActivityEnumData,
    singleEnumVariantMeta,
    typeDetails,
    variantTypeDetails
} from "../HeliosMetaTypes.js";
import type {
    EnumTypeSchema,
    TypeSchema,
    VariantTypeSchema,
} from "@helios-lang/type-utils";

// import { BundleTypes } from "./BundleTypes.js";
import { BundleBasedGenerator } from "./BundleBasedGenerator.js";

/**
 * Gathers any number of types expressible for an on-chain Helios script,
 * and generates types and type aliases for the off-chain TypeScript context.
 *
 * Each struct type is directly expressed as its name
 * Each enum type is expressed as a proxy type, unioned with the possible raw enum variants for that type
 * As each type is encountered (as a **nested field** within a datum or redeemer), any named types encountered
 * are added to the context, with any recursive expansions generated and added to the context, depth-first,
 * ... then the named type is used for the **nested field** where it was encountered.
 * @public
 */
export class BundleTypeGenerator extends BundleBasedGenerator {
    createAllTypesSource(
        className: string,
        parentClassName: string,
        inputFile: string
    ) {
        let stellarImports = `        
import type {
    CapoHeliosBundle,
    CapoDelegateBundle,
    minimalData,
    HeliosScriptBundle,
    EnumTypeMeta,
    singleEnumVariantMeta,
    tagOnly,
    IntersectedEnum
} from "@donecollectively/stellar-contracts"
`;
        if (this._isSC) {
            stellarImports = `
import {HeliosScriptBundle} from "${this.mkRelativeImport(
                inputFile,
                "src/helios/scriptBundling/HeliosScriptBundle.js"
            )}"
import type { 
    tagOnly, 
    EnumTypeMeta, 
    singleEnumVariantMeta
} from "${this.mkRelativeImport(
                inputFile,
                "src/helios/HeliosMetaTypes.js"
            )}"
import type { minimalData } from "${this.mkRelativeImport(
            inputFile,
            "src/delegation/DelegatedData.js"
)}"
import type { IntersectedEnum } from "${this.mkRelativeImport(
                inputFile,
                "src/helios/typeUtils.js"
            )}"
                
`;
            // import type {CapoHeliosBundle} from "${this.mkRelativeImport(
            //                 inputFile,
            //                 "src/CapoHeliosBundle.js"
            //             )}"
            // import type {CapoDelegateBundle} from "${this.mkRelativeImport(
            //                 inputFile,
            //                 "src/delegation/CapoDelegateBundle.js"
            //             )}"
            // `;
        }
        return (
            "" +
            `// generated by StellarHeliosProject using Stellar heliosRollupTypeGen()
// recommended: CHECK THIS FILE INTO YOUR VERSION CONTROL SYSTEM
//   ... and keep checking in the changes as your on-chain types evolve.
//
// NOTE: this file is auto-generated; do not edit directly

import type { UplcData } from "@helios-lang/uplc";
import type {
    Address,
    AssetClass,
    DatumHash,
    MintingPolicyHash,
    PubKey,
    PubKeyHash,
    ScriptHash,
    SpendingCredential,
    StakingCredential,
    StakingValidatorHash,
    TimeRange,
    TxId,
    TxInput,
    TxOutput,
    TxOutputId,
    InlineTxOutputDatum,
    ValidatorHash,
    Value,
} from "@helios-lang/ledger";
import type { Cast } from "@helios-lang/contract-utils";
import type { 
    IntLike,
    // BytesLike,
 } from "@helios-lang/codec-utils";

/**
 * @public
 */
export type TimeLike = IntLike;
 
${stellarImports}

${this.generateNamedDependencyTypes()}
`
            // export default
            // class ${className}
            // extends ${parentClassName} {
            // ${this.generateDatumApiTypes()}
            // ${this.generateRedeemerApiTypes()}
            // }
            // `
        );
    }

    generateNamedDependencyTypes() {
        return Object.entries(this.namedTypes)
            .map(([name, typeInfo]) => {
                if (typeInfo.typeSchema.kind === "enum") {
                    return this.generateEnumTypeSource(
                        name,
                        typeInfo as enumTypeDetails
                    );
                } else {
                    return this.generateOtherNamedTypeSource(
                        name,
                        typeInfo as typeDetails
                    );
                }
            })
            .join("\n");
    }

    generateEnumTypeSource(name: string, typeInfo: enumTypeDetails) {
        return (
            `
            /**
            * @internal
            */
            export type ${name}Meta = ${typeInfo.canonicalMetaType}\n` +
            `\n/**\n` +
            ` * ${name} enum variants\n` +
            ` * \n` +
            ` * @remarks - expresses the essential raw data structures\n` +
            ` * supporting the **${
                Object.keys(typeInfo.variants).length
            } variant(s)** of the ${name} enum type\n` +
            ` * \n` +
            ` * - **Note**: Stellar Contracts provides a higher-level \`${name}Helper\` class\n` +
            ` *     for generating UPLC data for this enum type\n` +
            ` * @public\n`+
            ` */\n` +
            `export type ${name} = ${typeInfo.canonicalType}\n` +
            `/**
 * ergonomic type enabling easy access to values converted from the on-chain form
 * @remarks
 * The data will be expressed in canonical form, and enum variants are merged to a single type with optional fields.
 * Nested enums are also merged in this ergonomic way.
 * @public
 */\n`+
            `export type ${typeInfo.ergoCanonicalTypeName} = IntersectedEnum<${typeInfo.ergoCanonicalType}>\n` +
            // `// factory signatures for this Enum: \n` +
            // `// makesUplcEnumData<${name}Like>;\n` +
            // `// ^^ calling such a factory makes a EnumUplcResult\n` +
            // `// makesUplcActivityEnumData<${name}Like>; // if activity!\n` +
            // `// ^^ calling such a factory makes a EnumUplcResult\n` +
            // `// reader signature for this Enum: \n` +
            // `// readsUplcEnumData<${name}>;\n` +
            `\n/**\n` +
            ` * ${name} enum variants (permissive)\n` +
            ` * \n` +
            ` * @remarks - expresses the allowable data structure\n` +
            ` * for creating any of the **${
                Object.keys(typeInfo.variants).length
            } variant(s)** of the ${name} enum type\n` +
            ` * \n` +
            ` * - **Note**: Stellar Contracts provides a higher-level \`${name}Helper\` class\n` +
            ` *     for generating UPLC data for this enum type\n` +
            ` *\n` +
            ` * #### Permissive Type\n` +
            ` * This is a permissive type that allows additional input data types, which are \n` +
            ` * converted by convention to the canonical types used in the on-chain context.\n` +
            ` * @public\n` +
            ` */\n` +
            `export type ${name}Like = IntersectedEnum<${typeInfo.permissiveType}>\n` +
            ""
        );
    }

    generateOtherNamedTypeSource(name: string, typeInfo: typeDetails) {
        if (!typeInfo.ergoCanonicalTypeName) throw new Error("missing ergoCanonicalTypeName");
        if (!typeInfo.permissiveTypeName) throw new Error("missing permissiveTypeName");
        const schema = typeInfo.typeSchema;
        const minimalTypeInfo = schema.kind === "struct" &&
        !! schema.fieldTypes.find((f) => f.name === "id" && f.type.kind == "internal" && f.type.name == "ByteArray") &&
        !! schema.fieldTypes.find((f) => f.name === "type" && f.type.kind == "internal" && f.type.name == "String") 
        ?
            `
/**
 * expresses the essential fields needed for initiating creation of a ${typeInfo.canonicalTypeName}
 * @public
 */
export type minimal${typeInfo.canonicalTypeName} = minimalData<${typeInfo.permissiveTypeName}>` : "";

        return (
`/**
 * A strong type for the canonical form of ${typeInfo.canonicalTypeName || name}
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see ${typeInfo.ergoCanonicalTypeName} instead.
 * @public
 */
export interface ${typeInfo.canonicalTypeName || name} ${typeInfo.canonicalType}

/**
 * An ergonomic, though less strictly-safe form of ${typeInfo.canonicalTypeName || name}
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the ${typeInfo.permissiveTypeName} type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type ${typeInfo.ergoCanonicalTypeName} = ${typeInfo.ergoCanonicalType}

/**
 * A strong type for the permissive form of ${typeInfo.canonicalTypeName || name}
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface ${typeInfo.permissiveTypeName} ${typeInfo.permissiveType}
${minimalTypeInfo}
`
        );
    }

    // // redeemer is write-only
    // generateRedeemerApiTypes() {
    //     return this.generateWriteApiTypes(
    //         this.topLevelTypeDetails.redeemer,
    //         "Activity"
    //     );
    // }

    // // datums are read/write, when present
    // generateDatumApiTypes() {
    //     // datum: HeliosTypeInfo | HeliosEnumInfo) {
    //     if (!this.topLevelTypeDetails.datum) {
    //         return `// no datum types in this script`;
    //     }

    //     return (
    //         this.generateWriteApiTypes(
    //             this.topLevelTypeDetails.datum,
    //             "mkDatum"
    //         ) +
    //         this.generateReadApiTypes(
    //             this.topLevelTypeDetails.datum,
    //             "readDatum"
    //         )
    //     );

    //     // mkDatum: {
    //     //     placeholder: "generate proxy types here";
    //     // }
    //     // readDatum: {
    //     //     placeholder: "show proxy types here";
    //     // }
    // }

    // generateWriteApiTypes(typeInfo: anyTypeDetails, accessorName?: string) {
    //     if (!accessorName) {
    //         //@ts-expect-error - name not always present
    //         if (!typeInfo.typeSchema.name) {
    //             throw new Error("typeName must be provided for unnamed types");
    //         }
    //         //@ts-expect-error - name already guarded above
    //         accessorName = `mk${typeInfo.typeSchema.name}`;
    //     }
    //     const isActivity = "Activity" == accessorName ? "Activity" : "";
    //     if (typeInfo.typeSchema.kind === "enum") {
    //         return `    ${accessorName}: makesUplc${isActivity}EnumData<${typeInfo.typeSchema.name}Like>;\n`;
    //     }

    //     //@ts-expect-error - name not always present
    //     if (typeInfo.typeSchema.name) {
    //         //@ts-expect-error - name already guarded above
    //         return `    ${accessorName}: uplcDataMaker<${typeInfo.typeSchema.name}Like>;\n`;
    //     } else {
    //         console.log(
    //             " ????????? is non-named uplcDataMaker ever used?\nyes:" +
    //                 new Error("").stack!.split("\n").splice(2).join("\n")
    //         );
    //         return `    ${accessorName}: uplcDataMaker<${typeInfo.permissiveType}>;\n`;
    //     }
    // }

    // generateReadApiTypes(typeInfo: anyTypeDetails, accessorName?: string) {
    //     if (!accessorName) {
    //         //@ts-expect-error - name not always present
    //         if (!typeInfo.typeSchema.name) {
    //             throw new Error("typeName must be provided for unnamed types");
    //         }
    //         //@ts-expect-error - name already guarded above
    //         accessorName = `read${typeInfo.typeSchema.name}`;
    //     }
    //     if (typeInfo.typeSchema.kind === "enum") {
    //         return `    ${accessorName}: readsUplcEnumData<${typeInfo.typeSchema.name}>;\n`;
    //     }
    //     //@ts-expect-error - name not always present
    //     if (typeInfo.typeSchema.name) {
    //         //@ts-expect-error - name already guarded above
    //         return `    ${accessorName}: readsUplcData<${typeInfo.typeSchema.name}>;\n`;
    //     }
    //     return `    ${accessorName}: readsUplcData<${typeInfo.canonicalType}>;\n`;
    // }
}
