module CapoHelpers 

import {
    mkTv,
    tvCharter,
    mustFindInputRedeemer,
    outputAndDatum,
    fromCip68Wrapper,
    AnyData,
    REQT,
    TODO
} from StellarHeliosHelpers

import {tx, get_current_input} from ScriptContext
// import {
//     TypeMap
// } from TypeMapMetadata

import { 
    RelativeDelegateLink,
    AbstractDelegateActivitiesEnum,
    CapoLifecycleActivity,
    DgTknDisposition as DgTkn,
    DelegateRole,
    PendingCharterChange    
} from CapoDelegateHelpers

enum UtxoSource {
    RefInput
    Input

}

enum dgd_DataSrc {
    Unk
    Input { utxo: TxInput }
    Output { txo: TxOutput }
    Both {
        utxo: TxInput
        txo: TxOutput
    }
    // Reference { ref: TxInput }
}

/**
 * Future: we can require for named tokens to be chartered explicitly
 * by the protocol before they can be minted using this structure.  However,
 * This would only be worthwhile if this structure provides a clear benefit,
 * in terms of reliable enforcement of policy constraints such as supply limits.
 * 
 * For now, we leave it out (govAuthority can authorize arbitrary token minting),
 * with a placeholder on the roadmap for a future extension to add
 * constraint expression + enforcement.  In that future moment, we can 
 * adopt this kind of extension to the manifest, or we can use a specific type of
 * dgDataPolicy for this purpose, with this structure as a prototype to be pushed
 * down into its internal structure.
 */
struct MftDetails {
    // the token name is mapped to this ManifestEntryType
    maxSupply: Option[Int]
    // supplyMintingRecords: []SupplyMintingRecord // points to an aggregate receipt 

    func validate(self) -> Bool {
        REQT("MintsFungibleToken: has forward-looking/placeholder structure for future constraint enforcement");

        self.maxSupply.switch {
            Some => error("maxSupply not yet supported"),
            None => true
        } 
        // && (
        //     self.supplyMintingRecords.length > 0
        // ).trace("empty supplyMintingRecords? ")
    }
}    

enum ManifestEntryType {
    // the name (entry's key) is simply a reference to a specific token 
    // (typically a specific kind of dgData record 
    //  ...using application-specific convention)
    NamedTokenRef 
    // the referenced token controls a specific type of dgData record,
    // ... indicated by the entry's key.  With refCount, it inventories multiple 
    // ... thread tokens, each held by the delegate contract, for parallelism.
    DgDataPolicy {
        policyLink: RelativeDelegateLink
        idPrefix: String
        refCount: Int
    }
    // the referenced token inventories thread-tokens for a specific delegate role
    //  ... the key is expected to match that delegate role (
    //    mintDgt, spendDgt, mintInvar, spendInvar,
    //    govDgt, or ‹name› of otherNamedDelegate)
    // the first thread doesn't ever require a manifest entry,
    // ... and the first forked thread makes an entry with refCount = 2
    DelegateThreads {
        role: DelegateRole 
        refCount: Int
    }
    // the referenced token is a merkle-root of a membership-proof-tree
    MerkleMembership 

    // the referenced token is a merkle-root of a state-root-tree
    MerkleStateRoot    

    /** the referenced token name has been chartered as an "official" 
     * asset class as part of this protocol.  See notes above for roadmap guidance.
     */
    // xxxMintsFungibleToken {
    //     mftDetails: MftDetails
    // }

    // func validate(self) -> Bool {
    //     self.switch {
    //         MintsFungibleToken{mftDetails} => mftDetails.validate(),
    //         _ => true
    //     }
    // }
}

/*
 * The UtxoManifest is a data structure that references a set of UUTs
 * that are important to the operation of a Capo (and its family of contract 
 * scripts).  It is used to maintain positive control over these operational
 * UUTs, inventorying them and giving every transaction a way to easily
 * reference their data for validation, operation, and reporting.
 *
 * A prime use-case for the capo's Manifest is for storing protocol-settings 
 * data ("settings").  Any application will need its own defined data structures
 * for settings, but the "settings" key is reserved for this general purpose.
 * The protocol ensures that every collaborating script ("delegate") has a
 * chance to validate any new settings before the (updated settings or the 
 * delegate, during installation) are activated.
 *
 * An additional case for manifest entries is for UUTs used as "thread tokens",
 * where multiple separate contract utxos are used to manage independent
 * threads of parallel operation for a single contract.  This provides a scalability
 * mechanism.
 */
struct CapoManifestEntry {
    // key: String // redundant / same as its map-key
    entryType: ManifestEntryType "tpe"
    tokenName: ByteArray "tn"
    mph: Option[MintingPolicyHash] // default = Capo's MPH
    
    func validate(self) -> Bool {
        // 3 bytes plus encoding overhead
        print("foo".serialize().length.show() + "<-- 3 chars has this serialized length");
        // assert(self.key.serialize().length > 5, "key too short");
        // assert("settings" == self.key, "manifest only supports 'settings' for now");

        assert(self.tokenName.length > 0, "no token name");
        // assert(self.refCount == 1, "only one ref allowed for now");
        // assert(!self.isThreadToken, "thread tokens not yet supported");
        self.mph.switch {
            Some => error("custom mph not yet supported"),
            _ => true
        }
    }
}

// func mkTokenShow(mph: MintingPolicyHash) -> (Value) -> String {
//     (v: Value) -> String {
//         others : String = Value::from_map(
//             v.get_assets().to_map().filter( (someMph: MintingPolicyHash, _) -> Bool {
//                 mph != someMph
//             })
//         ).show();
//         ada : String = (
//             (
//                 (0.0 + v.get_lovelace()) / 1_000.0
//             ).round() / 1_000.0
//         ).show() + " ADA";
//         mine : String = v.get_policy(mph).fold[[]String]( (previous: []String, tokenName: ByteArray, c: Int) -> []String {
//             tn = tokenName.decode_utf8_safe();
//             []String{
//                 c.show(), "×💴 ", tn
//             } + previous
//         }, []String{}).join(" + ");
//         // v.assets()

//         mine + " + " + ada  + others
//     }
// }

/**************************************************************
      ************************************************************
      ************************************************************
      *******************                      *******************
      *******************                      *******************
      *******************        CapoDatum     *******************
      *******************                      *******************
      *******************                      *******************
      ************************************************************
      ************************************************************
      ************************************************************
*/      

enum CapoDatum {
    CharterData {
        spendDelegateLink: RelativeDelegateLink
        spendInvariants: []RelativeDelegateLink
        otherNamedDelegates: Map[String]RelativeDelegateLink
        mintDelegateLink: RelativeDelegateLink
        mintInvariants: []RelativeDelegateLink
        govAuthorityLink: RelativeDelegateLink
        manifest: Map[String]CapoManifestEntry
        pendingChanges: []PendingCharterChange
        // typeMapUut: Option[ByteArray]   // optional reference to a UUT having TypeMapInfo datum
    }
    ScriptReference
    // settings are now just a distinguished case of delegated data
    // ... for contracts that use settings,
    // ... instead of being a special type of Datum
    // SettingsData {
    //     data:  Map[String]Data
    // }

    // same variant-index as delegate's capoStoredData:
    DelegatedData {  // the Capo redirects control of these to the spend delegate
        data: Map[String]Data // matches pattern of AnyData + other fields // the spend delegate may redirect control further, depending on what it sees in there
        version: Int // for CIP-68 compatibility
        otherDetails: Data // abstract additional info
    }

    func hasCharterRefInput(
        self,
        mph : MintingPolicyHash
    ) -> Option[CapoDatum::CharterData] {
        assert(false, "deprecated use of hasCharterRefInput(); use CapoCtx instead.");

        assert( // avoid "unused variable self" error
            true || ( /* never executed */
                self.serialize() != mph.serialize()
            ), "never thrown"
        );
        assert(false, "unused?"); // see standalone getRefCharterData()
        
        // chVal : Value = tvCharter(mph);
        charterAc : AssetClass = AssetClass::new(mph, "charter".encode_utf8());
        hasCharter = (txin : TxInput) -> Bool { txin.value.get_safe(charterAc) > 0 };

        tx.ref_inputs.find_safe(hasCharter).switch{
            Some{txin} => Option[CapoDatum::CharterData]::Some{
                CapoDatum::from_data( 
                    txin.datum.inline
                ).switch{
                    c : CharterData => c,
                    _ => error("wrong enum")
                }
            },
            None => Option[CapoDatum::CharterData]::None
        }
    }

    func countUpdatedThings(self, oldDatum: CapoDatum) -> Int {
        self.switch {
            CharterData{ 
                nextSpendDelegate, 
                nextSpendInvariants, 
                nextNamedDelegates, 
                nextMintDelegate, 
                nextMintInvariants, 
                nextGovDelegate, 
                nextManifest,
                _nextPendinghanges
            } => {
                CharterData {
                    oldSpendDelegate,
                    oldSpendInvariants,
                    oldNamedDelegates,
                    oldMintDelegate,
                    oldMintInvariants,
                    oldGovDelegate,
                    oldManifest,
                    _oldPendingChanges
                } = oldDatum;
                changedSpendDgt : Bool = ( nextSpendDelegate.serialize() != oldSpendDelegate.serialize() );
                changedSpendInvariants : Bool = ( nextSpendInvariants != oldSpendInvariants );
                changedNamedDelegate : Bool = ( nextNamedDelegates.serialize() != oldNamedDelegates.serialize() );

                changedMintDgt : Bool = ( nextMintDelegate.serialize() != oldMintDelegate.serialize() );    
                changedMintInvariants : Bool =  ( nextMintInvariants != oldMintInvariants );
                changedGovDelegate : Bool = ( nextGovDelegate.serialize() != oldGovDelegate.serialize() );
                changedManifest : Bool = ( nextManifest.serialize() != oldManifest.serialize() );
    
                if ((changedSpendDgt).trace(" -- spendDgt changed? ") ) { 1 } else { 0 } +
                if ((changedSpendInvariants).trace(" -- spendInvs changed? ") ) { 1 } else { 0 } +
                if (changedNamedDelegate.trace(" -- namedDgt changed? ") ) { 1 } else { 0 }+
                if ((changedMintDgt).trace(" -- mintDgt changed? ") ) { 1 } else { 0 } +
                if ((changedMintInvariants).trace(" -- mintInvs changed? ") ) { 1 } else { 0 } +
                if ((changedGovDelegate).trace(" -- govDgt changed? ")) { 1 } else { 0 } +
                if ((changedManifest).trace(" -- manifest changed? ") ) { 1 } else { 0 }
            },
            _ => error("only CharterData datum can count updated things")
        }
    }

    // func mustFindSettingsOutput(self, mph: MintingPolicyHash, inAddr: Address) -> outputAndDatum[CapoDatum::SettingsData] {
    //     settingsVal : Value = mkTv(mph: mph, tnBytes: self.switch {
    //         ct: CharterData => {
    //             print( " ⬅️ 🔎 finding settings output: "+ ct.settingsUut.decode_utf8_safe());
    //             ct.settingsUut
    //         },
    //         _ => error("mustFindSettings - only valid on CharterData datum")
    //     });
        
    //     notFound = Option[outputAndDatum[CapoDatum::SettingsData]]::None;
    //     foundSettings: []outputAndDatum[CapoDatum::SettingsData] = 
    //         tx.outputs.map_option[
    //             outputAndDatum[CapoDatum::SettingsData]
    //         ](
    //              (output: TxOutput) -> Option[outputAndDatum[CapoDatum::SettingsData]] {
    //                 if ( output.address != inAddr ) {
    //                     // print("not the right address");
    //                     notFound
    //                 } else {
    //                     rawDatum : Data = output.datum.inline;
    //                     CapoDatum::from_data(
    //                         rawDatum
    //                     ).switch {
    //                         settings: SettingsData => {
    //                             Option[
    //                                 outputAndDatum[CapoDatum::SettingsData]
    //                             ]::Some{
    //                                 outputAndDatum[CapoDatum::SettingsData] {
    //                                     output, settings, rawDatum
    //                                 }
    //                             }
    //                         },
    //                         _ => {
    //                             // print("found non-SettingsData");
    //                             notFound
    //                         }
    //                     }
    //                 }
    //             }
    //         );

    //     assert(foundSettings.length < 2, "too many settings outputs") ;
    //     assert(foundSettings.length == 1, "no settings output");

    //     settingsOutput : TxOutput = foundSettings.head.output;
    //     assert(
    //         // already checked above.
    //         // settingsOutput.address == charter.owner &&
    //         settingsOutput.value.contains(settingsVal),
    //             "settings output not found in contract with expected UUT"
    //     );
    //     assert(settingsVal.contains(settingsOutput.value.get_assets()), 
    //         "excess value in settings output: "+(settingsOutput.value - settingsVal).show()
    //     );
    //     print("⬅️ ✅ found CapoDatum::SettingsData");
    //     foundSettings.head
    //     // ^^ fails if there's no settings output to the right address

    // }
}

enum cctx_CharterInputType {
    Unk
    RefInput { 
        datum: CapoDatum::CharterData
        utxo: TxInput
    }
    Input { 
        datum: CapoDatum::CharterData 
        utxo: TxInput 
    }
    // Minting {
    //     datum: CapoDatum::CharterData
    //     address: Address
    // }
}    

/**************************************************************
      ************************************************************
      ************************************************************
      *******************                      *******************
      *******************                      *******************
      *******************      CapoActivity    *******************
      *******************                      *******************
      *******************                      *******************
      ************************************************************
      ************************************************************
      ************************************************************
*/      

enum CapoActivity {
    capoLifecycleActivity { // variant 0 mostly delegated to spendDgt
        activity: CapoLifecycleActivity
    }
    usingAuthority // variant 1
    retiringRefScript // variant 2
    addingSpendInvariant // variant 3
    spendingDelegatedDatum // variant 4

    // // possibly move this into CapoLifecycleActivity:
    // updatingManifest { // variant 5 always delegated to spendDgt
    //     activity: ManifestActivity
    // }
    updatingCharter // deprecated variant 5
}

func getRefCharterUtxo(mph : MintingPolicyHash) -> TxInput {
    // chVal : Value = tvCharter(mph);
    charterAc : AssetClass = AssetClass::new(mph, "charter".encode_utf8());
    hasCharter = (txin : TxInput) -> Bool { txin.value.get_safe(charterAc) > 0 };
    print("  -- getting ref_input for charter");
    charterUtxo : TxInput = tx.ref_inputs.find_safe(hasCharter).switch{
        Some{ch} => ch,
        //!!! todo adjust this message: Missing required charter in ref_inputs
        None => {
            error("Missing charter in required ref_inputs (use tcxWithCharterRef(tcx) in txn building functions)")
        }
    };

    charterUtxo
}

func getRefCharterData(mph : MintingPolicyHash) -> CapoDatum::CharterData {
    charterUtxo : TxInput = getRefCharterUtxo(mph);
    ctd : CapoDatum::CharterData = CapoDatum::CharterData::from_data( 
        charterUtxo.datum.inline
    );

    ctd
}

//! retrieves a required Capo Charter datum for the indicated minting-policy - 
// ... either from the txn's reference inputs  or inputs.
// prefer mkCapoCtx.needsCharter() for "get from anywhere" semantics
// and cctx.getCharterData() to get the datum
//  (... or mkCapoCtx.withCharterRef() to require unchanged charter)
//  (... or mkCapoCtx.withCharterInput() to require the charter to be spent & maybe updated)
func getTxCharterData(
    mph : MintingPolicyHash,
    refInputs : []TxInput = tx.ref_inputs
) -> CapoDatum::CharterData {
    // chVal : Value = tvCharter(mph);
    charterAc : AssetClass = AssetClass::new(mph, "charter".encode_utf8());   
    hasCharter = (txin : TxInput) -> Bool { txin.value.get_safe(charterAc) > 0 };

    charterUtxo : TxInput = refInputs.find_safe(hasCharter).switch{
        Some{ch} => ch,
        None => tx.inputs.find_safe(hasCharter).switch{
            Some{ch} => ch,
            None => error("Missing charter inputs / ref_inputs")
        }
    };
    ctd : CapoDatum::CharterData = CapoDatum::CharterData::from_data( 
        charterUtxo.datum.inline
    );

    ctd
}

func mustHaveGovAuthority(
    mph : MintingPolicyHash,
    charterData : CapoDatum::CharterData = getTxCharterData(mph)
) -> Bool {
    charterData.govAuthorityLink.hasValidOutput(mph)
}

/**************************************************************
      ************************************************************
      ************************************************************
      *******************                      *******************
      *******************                      *******************
      *******************     DelegateInput    *******************
      *******************                      *******************
      *******************                      *******************
      ************************************************************
      ************************************************************
      ************************************************************
*/

/**
 * A high-level helper for delegates, enabling various kinds of
 * validation and delegation-related operations.  Although this
 * is defined as related to an "Input", this object provides a gateway
 * for any script to involve that delegate policy in the abstract, by
 * virtue of having included that input in the transaction.
 * Callers should expect that the other policy will
 * do its responsibilities and may use this object to enforce that
 * the other policy is **triggered** in expected ways.
 */
struct DelegateInput {
    link: RelativeDelegateLink
    role: DelegateRole
    idPrefix: Option[String]
    input: Option[TxInput]
    mph: MintingPolicyHash

    func genericDelegateActivityAsData(self) -> Data {
        i : TxInput = self.input.unwrap();
        inputData : Data = mustFindInputRedeemer(i);
        inputData.switch {
            ConstrData{index, fields} => {
                // ladybug emoji: "🐞"
                print("    --🐞 generic delegate activity at index "+ index.show() );
                fields.head.switch {
                    ConstrData{index2, _fields2} => {
                        print("    --🐞 nested activity at index "+ index2.show() )
                    }
                }
                // doesn't get optimized out:
                // inpIdStr = i.output_id.tx_id.show() + "🔹#" + i.output_id.index.show();
                // valStr = i.value.show();
                // print("    ---- from input id:" + inpIdStr + " = "+valStr)
            } 
        };
        inputData
    }

    func genericDelegateActivity(self) -> AbstractDelegateActivitiesEnum {
        AbstractDelegateActivitiesEnum::from_data(
            self.genericDelegateActivityAsData()
        )
    }    

    /**
     * Throws an error message including the delegation token id,
     * if the assertion is false.
     */
     func assert(self, assertionOk : Bool, msg: String) -> () {
        assert(true || /* never executed */ self.serialize() == self.serialize(), msg);
        if(assertionOk) { assert(true, "" ) } else {
            self.error(msg)
        }
     }

    /**
     * Throws an error message including the delegation token id.
     */     
    func error(self, msg: String) -> () {
        assert(true || /* never executed */ self.serialize() == self.serialize(), msg);
        // warning emoji: "⚠️"
        print("⚠️ ⚠️ ⚠️ error executing policy for dgTkn: "+ self.link.uutName);
        print("     ---- with input value: "+ self.input.unwrap().value.show());
        // print( mkTokenShow(self.mph)(
        //         (self.input.unwrap().value)
        //     )
        // );
        print("\n");
        assert(false, msg)
    }

    func withSpendingActivity(self) -> DelegateInput {
        self.genericDelegateActivity().switch {
            SpendingActivities => self,
            _ => {
                self.error("non-spend activity!");
                error("")
            }
        }
    }

    func withMintingActivity(self) -> DelegateInput {
        self.genericDelegateActivity().switch {
            MintingActivities => self,
            _ => {
                self.error("non-mint activity!"); 
                error("") 
            }
        }
    }

    func updatingManifest(self) -> DelegateInput {
        self.role.switch {
            SpendDgt => {
                print("checking presence of SpendDgt: updatingManifest activity");
                self.genericDelegateActivity().switch {                    
                    CapoLifecycleActivities{cla} => cla.switch {
                        updatingManifest => self,
                        _ => {
                            self.error("not using required updatingManifest activity");
                            error("") // unreachable
                        }
                    },
                    _ => {
                        self.error("updatingManifest: only valid for CapoLifecycleActivities");
                        error("unreachable")
                    }
                }
            },
            _ => {
                self.error("updatingManifest: only valid for SpendDgt");
                error("unreachable")
            }
        }
    }

    func withUniqueSeededMintingActivity(self, seed: TxOutputId) -> DelegateInput {
        // tnFactory : (String) -> String = mkUutTnFactory(seed);

        REQT("withUniqSeededMinting: ensures the delegate is unchanged, so callers needn't.");
        self.genericDelegateActivity().switch {
            MintingActivities{ma} => {
                ma.switch {
                    ConstrData{_index, fields} => {
                        // assert(index==index, "no way"); // unused field can't be _
                        assert(
                            seed == TxOutputId::from_data(fields.get(0)),
                            "seed mismatch"
                        )
                    },
                    _ => error("no way")
                };
                self.delegateUnchanged()
            },
            MultipleDelegateActivities{activities} => {
                // can do one or more minting activities, but each one needs to be bound to a separate seed
                print("-- the delegated-data policy is triggered with a multi-activity");

                assert(activities.length > 0, "no minting activities found");
                foundWithThisSeed : []Data = activities.filter( (a : Data) -> Bool {
                    AbstractDelegateActivitiesEnum::from_data(a).switch {
                        MintingActivities{ma} => {
                            ma.switch {
                                ConstrData{index, fields} => {
                                    assert(index==index, "no way c"); // unused field can't be _ in switch
                                    seed == TxOutputId::from_data(fields.head) &&
                                    true
                                },
                                _ => error("no way d")
                            }
                        },
                        _ => false
                    }
                });
                REQT("one of the delegate multi-activities must be minting with this seed");
                self.assert(foundWithThisSeed.length > 0, "no minting activity found for seed!");
                REQT("only one of a multi-activity for a given seed is allowed");
                self.assert(foundWithThisSeed.length == 1, "multiple minting activities found for seed");

                self.delegateUnchanged()
            },
            _ => {
                self.error("non-mint activity!");
                error("")
            }
        }
    }

    func withUniqueDDSpendingActivity(self, recId: ByteArray) -> DelegateInput {
        self.role.switch {
            DgDataPolicy => print("ok, checking spending activity for a delegated-data policy"),
            _ => error("withUniqueDDSpendingActivity: only valid for DgDataPolicy")
        };

        REQT("withUniqueDDSpendingActivity: checks presence of delegated-data controller's spending activity for recId");
        strId : String = recId.decode_utf8_safe();
        print("    -- recId: "+ strId);

        TODO("TEST THIS v");
        REQT("spendDgt must be acting on the matching record-id");
        REQT("ensures the delegate is unchanged, so callers needn't also check that"); 

        self.genericDelegateActivity().switch {
            SpendingActivities{sa} => {
                sa.switch {
                    ConstrData{index, fields } => {
                        assert(index==index, "no way e"); // unused field can't be _
                        foundRecId: ByteArray = ByteArray::from_data(fields.head);
                        if(recId != foundRecId) {
                            print("  -- expected: Spending:"+strId);
                            print("  -- actual: Spending:"+foundRecId.show());
                            self.error("recId mismatch")
                        } else {
                            print ("  -- ok: DD controller spending activity for "+strId)
                        }
                    },
                    _ => error("no way f")
                };
                self.delegateUnchanged()
            },
            MultipleDelegateActivities{activities} => {
                print( "    -- multiple activities found" );

                self.assert(activities.length > 0, "no spending activities found");
                // can do one or more spending activities, but each one needs to be bound to a separate recId
                actsOnThisRecord : []Data = activities.filter( (a : Data) -> Bool {
                    AbstractDelegateActivitiesEnum::from_data(a).switch {
                        CreatingDelegatedData => {
                            self.error(
                                "dgInput: withSpendingActivity: CreatingDelegatedData invalid"
                            );
                            error("")
                        },
                        UpdatingDelegatedData => {
                            self.error(
                                "dgInput: withSpendingActivity: UpdatingDgData invalid; use a Spending variant in the delegated-data policy"
                            );
                            error("")
                            // " not the delegate controller's activities (use SpendingDelegatedData for that)"
                        },
                        DeletingDelegatedData => {
                            self.error(
                                "dgInput: withSpendingActivity: DeletingDelegatedData invalid" 
                                // is only valid in context of a mintDgt- when destroying a data record
                            );
                            error("")
                        },
                        SpendingActivities{sa} => {
                            // assert(false && sa.serialize() == sa.serialize(), "no way g");
                            // false
                            sa.switch {
                                ConstrData{index, fields} => {
                                    assert(index==index, "no way h"); // unused field can't be _
                                    foundRecId: ByteArray = ByteArray::from_data(fields.head);
                                    if(recId != foundRecId) {
                                        actualIdStr = foundRecId.decode_utf8_safe();
                                        self.error("recId mismatch: found "+actualIdStr+" (expected "+strId+")");
                                        error("")
                                    } else { true }
                                },
                                _ => {
                                    self.error("wrong structure for spending activity");
                                    error("")
                                }
                            }
                        },
                        
                        _ => false
                    }
                });
                REQT("one of the delegate data-controller multi-activities must treat this recId");
                self.assert(
                    (actsOnThisRecord.length > 0).trace("dgt acting on this recId? ")
                    , "no spending activity found for recId: "+strId
                );
                REQT("only one of a multi-activity for a given recId is allowed");
                self.assert(
                    (actsOnThisRecord.length == 1).trace("exactly one activity? ")
                    , "multiple spending activities found for recId: "+strId
                );
                self.delegateUnchanged()
            },
            _ => {
                self.error("non-spend activity!");
                error("")
            }
        }
    }

    func requiresValidOutput(self, createdOrReturned : DgTkn=DgTkn::Returned) -> Bool {
        // TODO - would want this to be able to call our assert/error methods
        self.link.hasValidOutput(
            mph: self.mph, 
            required: true,
            createdOrReturned: createdOrReturned
        )
    }

    func getActivity[ACTIVITY](self) -> ACTIVITY {
        ACTIVITY::from_data(
            mustFindInputRedeemer(self.input.unwrap())
        )
    }

    func getDatum[DATUM](self) -> DATUM {
        DATUM::from_data(
            self.input.unwrap().datum.inline
        )
    }

    func delegateUnchanged(self) -> DelegateInput {
        DelegateInput{link, _role, _idPrefix, input, mph} = self;

        RelativeDelegateLink{
            uut,
            validatorHash,
            _configJson
        } = link;
        targetValue : Value = link.tvAuthorityToken(mph);
        returnedUnchanged : Bool = validatorHash.switch {
            Some{vh} => {
                // print(" ⬅️ 🔎 💁 expect dgTkn "+uut + " sent to vh " + vh.show());
                self.assert(
                    tx.value_locked_by(vh)   .
                    contains(
                        targetValue
                    ), 
                    "dgTkn not returned: "+ uut
                );
                tx.outputs.find_safe((o : TxOutput) -> Bool {
                    o.datum.serialize() == input.unwrap().datum.serialize()
                }).switch {
                    Some => {
                        print(" -- good, the dgTkn is unchanged: "+uut);
                        true
                    }, 
                    None => {
                        self.error("dgt modified");
                        error("")
                    }
                }
            },
            None => {
                self.error("unchOut - no vh"); // this method not valid on non-contract delegate tokens
                error("")
                // todo maybe make it valid by enforcing return to the input address?
            }
        };
        assert(returnedUnchanged, "no"); // already thrown
        assert(link.hasValidOutput(mph), "no"); // thrown inside the method

        self
    }
    // syntax sugar.  Implied is that that any other function calls will trip errors,
    func orFail(self) -> Bool {
        // assert(true || /* never executed */ self.serialize() == self.serialize(), "no way i");
        _t = self;
        true
    }
}

// func genericDelegateActivity(
//     link: RelativeDelegateLink,
//     input: TxInput
// ) -> DelegateActivity[AbstractDelegateActivitiesEnum] {
//     DelegateActivity[AbstractDelegateActivitiesEnum]::new{
//         link,
//         input,
//         // datum: Option[DATUM]::None,
//         activity: Option[AbstractDelegateActivitiesEnum]::None
//     }
// }


/**************************************************************
      ************************************************************
      ************************************************************
      *******************                      *******************
      *******************                      *******************
      *******************     DgDataDetails    *******************
      *******************                      *******************
      *******************                      *******************
      ************************************************************
      ************************************************************
      ************************************************************
*/      


struct DgDataDetails {
    dataSrc: dgd_DataSrc
    // filteredInputs: []TxInput
    id: ByteArray
    type: String
    mph: MintingPolicyHash
    // inputs: []TxInput

    // see CapoCtx::updatingDgData(id)
    func updating(id : ByteArray, input: TxInput, output : TxOutput, mph : MintingPolicyHash) -> DgDataDetails {
        DgDataDetails{
            dataSrc: dgd_DataSrc::Both{input, output},
            id: id,
            type: "",
            mph: mph
        }
    }
    
    // see CapoCtx::creatingDgData(id)
    func creating(id : ByteArray, output : TxOutput, mph : MintingPolicyHash
    ) -> DgDataDetails {
        DgDataDetails{
            dataSrc: dgd_DataSrc::Output{output},
            id: id,
            type: "",
            mph: mph
        }
    } 

    // see CapoCtx::referencingDgData(id)
    func referencing(id : ByteArray, input : TxInput, mph : MintingPolicyHash) -> DgDataDetails {
        DgDataDetails{
            dataSrc: dgd_DataSrc::Input{input},
            id: id,
            type: "",
            mph: mph
        }
    }    

    func uutValue(self) -> Value {
        Value::new(
            AssetClass::new(self.mph, self.id), 
            1
        )
    }

    // func withOutput(id : ByteArray, input: []TxInput, output : TxOutput) -> DgDataDetails {
    //     DgDataDetails{
    //         dataSrc: dgd_DataSrc::Output{output},
    //         // filteredInputs: []TxInput{},
    //         id: id,
    //         type: ""
    //         // inputs: inputs
    //     }
    // }

    // func withInput(self) -> DgDataDetails {
    //     assert(self.id.length > 0, "no id; try cctx.updatingDgDat (id)");
    //     self.dataSrc.switch {
    //         Input => self,
    //         Both => self,
    //         _ => {
    //             oneInput: []TxInput = self.filterInputs();
    //             assert(1 == oneInput.length, "yikes! too many inputs");
    //             dataSrc : dgd_DataSrc = self.dataSrc.switch {
    //                 Unk => dgd_DataSrc::Input{oneInput.head},
    //                 Output{txo} => dgd_DataSrc::Both{oneInput.head, txo},
    //                 _ => error("no way j ") // already returned self
    //             };

    //             DgDataDetails{
    //                 dataSrc: dataSrc,
    //                    // filteredInputs: oneInput,
    //                 id: self.id,
    //                 type: self.type,
    //                 inputs: self.inputs
    //             }
    //         }
    //     }
    // }

    func input(self) -> TxInput {
        // assert(1 == self.filteredInputs.length, "use withId(id)");
        // assert(self.id.length > 0, "use withId(id) or cctx.updatingDgData(id).withInput()");

        // self.inputs.head
        self.dataSrc.switch {
            Input{utxo} => utxo,
            Both{utxo, _} => utxo,
            _ => error("no input data; use findInput() first")
        }
    }

    func output(self) -> TxOutput {
        self.dataSrc.switch {
            Output{txo} => txo,
            Both{_, txo} => txo,
            _ => error("no output data")
        }
    }

    // doesn't work - something about the way the IR is generated?
    //   - seems like it might be the list operations, 
    //   - or scoping of the fields of type []TxInput?
    //
    // func findInput(self) -> DgDataDetails {
    //     self.dataSrc.switch {
    //         Input => self,
    //         Both => self,
    //         _ => {
    //             targetId : ByteArray = self.id;
    //             isEmpty : Bool = targetId.length == 0;
    //             print("finding input dgData id: "+self.id.decode_utf8_safe());
    //             utxo: TxInput = self.inputs.find_safe( (txin : TxInput) -> Bool {
    //                 rec : AnyData = AnyData::from_data(
    //                     txin.datum.inline
    //                 );
    //                 rec.type.starts_with(self.type)
    //                 && (isEmpty || rec.id == targetId)
    //             }).switch {
    //                 Some{x} => x,
    //                 None => error("❌ no input dgData")
    //             };
    //             newSrc: dgd_DataSrc = self.dataSrc.switch {
    //                 Output{txo} => dgd_DataSrc::Both{utxo, txo},
    //                 Unk => dgd_DataSrc::Input{utxo},
    //                 _ => error("no way k") // unreachable
    //             };

    //             DgDataDetails{
    //                 dataSrc: newSrc,
    //                 // filteredInputs: [utxo],
    //                 id: self.id,
    //                 type: self.type,
    //                 inputs: self.inputs
    //             }
    //         }
    //     }
    // }


    // func filterInputs(self) -> []TxInput {
    //     self.inputs
    //     // targetId : ByteArray = self.id;
    //     // isEmpty : Bool = targetId.length == 0;
    //     // self.inputs.filter( (txin : TxInput) -> Bool {
    //     //     rec : AnyData = AnyData::from_data(
    //     //         txin.datum.inline
    //     //     );

    //     //     rec.type.starts_with(self.type)
    //     //     && (isEmpty || rec.id == targetId)
    //     // })
    // }

    // func withFilteredInputs(self) -> DgDataDetails {
    //     //!!! causes IR assertion error
    //     // if (self.filteredInputs.is_empty()) {
    //     // if (self.filteredInputs.length == 0) {
    //     if(true) {
    //             self
    //         // DgDataDetails {
    //         //     dataSrc: self.dataSrc,
    //         //     filteredInputs: self.filterInputs(),
    //         //     id: self.id,
    //         //     type: self.type,
    //         //     inputs: self.inputs
    //         // }

    //     // dataSrc: dgd_DataSrc
    //     // filteredInputs: []TxInput
    //     // id: ByteArray
    //     // type: String
    //     // inputs: []TxInput
    
    //     } else {
    //         self
    //     }
    // }

    func inputData(self) -> Data {
        self.input().datum.inline.switch {
            ConstrData{_, fields} => fields.head,
            _ => error("expected ConstrData{mStruct} for DgData input")
        }
        // self.dataSrc.switch {
        //     Input{utxo} => utxo.datum.inline,
        //     Both{utxo, _} => utxo.datum.inline,
        //     _ => error("no input data")
        // }
    }

    func outputData(self) -> Data {
        self.output().datum.inline.switch {
            ConstrData{_, fields} => fields.head,
            _ => error("expected ConstrData{mStruct} for DgData output")
        }

        // self.dataSrc.switch {
        //     Output{txo} => txo.datum.inline,
        //     Both{_, txo} => txo.datum.inline,
        //     _ => error("no output data")
        // }
    }
    
    // func mustHaveUut(self, uut: String) -> Bool {
    //     // todo
    //     false
    // }

    /**
     * Allows the object's creation to be an implicit assertion
     * of presence / input / output conditions, without the caller having to
     * use the object in any other way (prevents an unused-variable error).
     */
    func orFail(self) -> Bool {
        _t = self;
        true
    }
}

/**************************************************************
      ************************************************************
      ************************************************************
      *******************                      *******************
      *******************                      *******************
      *******************        CapoCtx       *******************
      *******************                      *******************
      *******************                      *******************
      ************************************************************
      ************************************************************
      ************************************************************
*/      

struct CapoCtx {
    mph: MintingPolicyHash
    charter: cctx_CharterInputType

    func mkTv(self,
        tn: String = "",
        tnBytes : ByteArray = tn.encode_utf8(),
        count : Int = 1
    ) -> Value {
        assert(tnBytes.length > 0, "missing reqd tn");
        Value::new(
            AssetClass::new(self.mph, tnBytes), 
            count
        )
    }

    func mkAc(self, 
        tn: String = "",
        tnBytes : ByteArray = tn.encode_utf8()
    ) -> AssetClass {
        AssetClass::new(self.mph, tnBytes)
    }

    // use this or updatingDgData() instead of getDDOutput()
    func creatingDgData(
        self,
        recId : String="", 
        recIdBytes : ByteArray = recId.encode_utf8()
    ) -> DgDataDetails {
        output : TxOutput = self.delegatedTxOutput(recIdBytes);
        
        DgDataDetails::creating(recIdBytes, output, self.mph)
    }

    func updatingDgData(
        self,
        recId : String="", 
        recIdBytes : ByteArray = recId.encode_utf8()
    ) -> DgDataDetails {
        output : TxOutput = self.delegatedTxOutput(recIdBytes);
        input : TxInput = self.delegatedDataTxInput(recIdBytes: recIdBytes);
        DgDataDetails::updating(recIdBytes, input, output, self.mph)
    }

    func referencingDgData(self, recId : String="", recIdBytes : ByteArray = recId.encode_utf8()) -> DgDataDetails {
        input : TxInput = self.delegatedDataRef(recIdBytes: recIdBytes);
        DgDataDetails::referencing(recIdBytes, input, self.mph)
    }
    
    func getCharterRedeemer(self) -> CapoActivity {
        e : String = "requires charter as input";
        self.charter.switch {
            Unk => error(e),
            RefInput => error(e),
            Input{_, utxo} => {
                activity : CapoActivity = CapoActivity::from_data(
                    mustFindInputRedeemer(utxo)
                );
                // error-factory:
                wrongActivity = () -> CapoActivity { 
                    if (true) { error("non-CharterData activity") } else { 
                        // unreachable
                        CapoActivity::usingAuthority
                    } 
                };
                // returns any activity valid for the CharterData utxo:
                activity.switch {
                    retiringRefScript => wrongActivity(),
                    // updatingSettings => wrongActivity(),
                    // retiringSettings => wrongActivity(),                    
                    spendingDelegatedDatum => wrongActivity(),
                    usingAuthority => activity,
                    updatingCharter => activity, //todo: make this obsolete
                    addingSpendInvariant => activity,
                    capoLifecycleActivity => activity

                    // _ => // leaving other potential variants out to generate compile errors if they're added
                }
            }
        }
    }

    func findManifestEntry(self, key: String) -> Option[CapoManifestEntry] {
        print("    -- looking for capo's manifest entry: "+key);
        charterData : CapoDatum::CharterData = self.getCharterData();
        charterData.manifest.get_safe(key)
    }

    func mustFindManifestEntry(self, key: String) -> CapoManifestEntry {
        self.findManifestEntry(key).switch {
            Some{entry} => entry,
            None => error("missing required manifest entry: " + key)
        }
    }

    func findManifestTokenName(self, key: String, required: Bool = true) -> Option[ByteArray] {
        oe = self.findManifestEntry(key);
        oe.switch {
            None => {
                assert(!required, "missing required manifest entry: " + key);
                Option[ByteArray]::None
            }, 
            Some{e} => Option[ByteArray]::Some{e.tokenName}
        }
    }

    func getSettingsId(self, required : Bool = true) -> Option[ByteArray] {
        self.findManifestTokenName("currentSettings", required)
    }

    func getManifestedData(self, key: String,
        which : UtxoSource = UtxoSource::RefInput
    ) -> Data {
        print("  -- finding manifest symbol "+ key);
        manifestEntry : CapoManifestEntry = self.mustFindManifestEntry(key);
        tokenName : ByteArray = manifestEntry.tokenName;
        manifestAc = AssetClass::new(self.mph, tokenName);
        // manifestValue : Value = mkTv(mph: self.mph, tnBytes: tokenName);
        tnStr = tokenName.decode_utf8_safe();
        // print("     ... with input dgData token name: "+ tnStr);
        // print("     with value: "+manifestValue.show());

        inputs: []TxInput = which.switch {
            RefInput => tx.ref_inputs,
            Input => tx.inputs
        };
        utxo : TxInput = inputs.find_safe((txin : TxInput) -> Bool {
            txin.value.get_safe(manifestAc) > 0
        }).switch{
            Some{txin} => {
                print ("     ✅ ➡️  📀💁 found input dgData utxo for "+tnStr );
                txin
            },
            None => {                
                error(
                    "_❌ ➡️ 📀💁💣💥💣💥💣💥  missing required "+
                    which.switch{RefInput => "ref_input", Input => "input"}+
                    " for manifest's '"+key+"' data="+tnStr+
                    "\n   -- this probably indicates capo.tcxWithSettingsRef(tcx, ...) was not called"
                    // lifecycle management should always ensure a good linkage between
                    // the capo's manifest entry and the matching utxo having that uut.
                )
            }
        };

        utxo.datum.inline.switch {
            ConstrData{_, fields} => {
                // print("utxo: "+ utxo.output_id.show());
                // print("manifested data fields = "+fields.length.show());
                fields.head.switch {
                    MapData => {
                        // print("mapData found");
                        fields.head
                    },
                    _ => error("expected MapData for manifested data: "+ key)
                }
            },
            _ => error("expected ConstrData{‹any›, mStruct} for manifested data: "+ key)
        }
    }

    func getNextManifestDatum[DATUM_TYPE](self, key: String) -> DATUM_TYPE {
        DATUM_TYPE::from_data(
            self.getNextManifestedDatumRaw(key)
        )
    }

    func getNextManifestedDatumRaw(self, key: String) -> Data {
        charterData : CapoDatum::CharterData = self.getCharterData();
        manifestEntry : CapoManifestEntry = charterData.manifest.get_safe(key).switch{
            Some{entry} => entry,
            None => error("missing required manifest entry: " + key)
        };
        manifestAc = AssetClass::new(self.mph, manifestEntry.tokenName);
        // manifestValue : Value = mkTv(mph: self.mph, tnBytes: manifestEntry.tokenName);
        utxo : TxOutput = tx.outputs.find_safe((txo : TxOutput) -> Bool {
            txo.value.get_safe(manifestAc) > 0
        }).switch{
            Some{txo} => txo,
            None => error("missing required '"+key+"' manifest entry in outputs")
        };

        utxo.datum.inline.switch {
            ConstrData{_, fields} => fields.head,
            _ => error("expected ConstrData{mStruct} for manifested data: "+ key)
        }
    }

    // func getRefSettingsUtxo(self) -> TxInput {
    //     charterData : CapoDatum::CharterData = self.getCharterData();
    //     settingsValue : Value = mkTv(mph: self.mph, tnBytes: charterData.settingsUut);
    //     hasSettings = (txin : TxInput) -> Bool { txin.value.contains(settingsValue) };

    //     print("getting ref_input for settings");
    //     settingsUtxo : TxInput =  tx.ref_inputs.find_safe(hasSettings).switch{
    //         Some{s} => s,
    //         //!!! todo adjust this message: Missing required charter in ref_inputs
    //         None => error("Missing settings in required ref_inputs (use capo.addSettingsRef(tcx, 'refInput') in txn builder)")
    //     };
    
    //     settingsUtxo
    // }

    func requiresGovAuthority(self) -> CapoCtx {
        REQT("it must have the Capo's govAuthority approval");
        
        assert(
            self.getCharterData().govAuthorityLink.hasValidOutput( 
                self.mph  
            ), /*always true*/
            "no way m"
        ); 

        self
    }

    // func getSettings[SettingsTYPE](self) -> SettingsTYPE {
    //     settings : TxInput = self.getRefSettingsUtxo();

    //     SettingsTYPE::from_data(settings.datum.inline)
    // }

    func requiresNamedDelegateInput(self, dgtName: String) -> DelegateInput {
        self.getCharterData().otherNamedDelegates.get_safe(dgtName).switch{
            None => error("missing required delegate with name: " + dgtName),

            Some{dgtLink} => {
                self.requiresDelegateInput(dgtLink, DelegateRole::OtherNamedDgt{dgtName})
            }
        }
    }

    func requiresDgDataPolicyInput(self, typeName: String, required: Bool = true) -> DelegateInput {
        REQT("  -- requiresDgDataPolicyInput(): locates the manifest's data-policy for this record-type");

        self.getCharterData().manifest.get_safe(typeName).switch{
            None => error("missing data-policy manifest for record-type '" + typeName + "'"),
            Some{entry} => {
                ( dgtLink : RelativeDelegateLink, idPrefix: String ) = entry.entryType.switch {
                    DgDataPolicy{policyLink, idPrefix, _refCount} => ( policyLink, idPrefix ),
                    _ => error("manifest entry is not a data policy: "+typeName)
                };
                REQT("requires the delegated-data policy for type="+typeName);
                self.requiresDelegateInput(
                    dgtLink, 
                    DelegateRole::DgDataPolicy{typeName}, 
                    required,
                    Option[String]::Some{idPrefix}
                )
            }
        }
    }

    func nowActingAsMintDgt(self, required: Bool = true) -> Bool {
        input : TxInput = get_current_input();
        acMintDgt : AssetClass = self.getCharterData().mintDelegateLink.acAuthorityToken(self.mph);
        isUsingMintDgt = (
            input.value.get_safe(acMintDgt) > 0
        ).trace("    -- acting on mintDgt-* token right now? ");
        // isMintDgt : Bool = (
        //     self.requiresMintDelegateInput(required: required).input.switch {
        //         Some{i} => i == input,
        //         None => false
        //     }
        // ).trace("    -- acting on mintDgt-* right now? ");
        assert(
            isUsingMintDgt || !required
            , "not acting as mint delegate!"
        );
        isUsingMintDgt
    }

    func nowActingAsSpendDgt(self, required: Bool = true) -> Bool {
        input : TxInput = get_current_input();
        acSpendDgt : AssetClass = self.getCharterData().spendDelegateLink.acAuthorityToken(self.mph);
        isUsingSpendDgt = (
            input.value.get_safe(acSpendDgt) > 0
        ).trace("    -- acting on spendDgt-* token right now? ");
        // isSpendDgt : Bool = (
        //     self.requiresSpendDelegateInput(required: required).input.switch {
        //         Some{i} => i == input,
        //         None => false
        //     }
        // ).trace("    -- acting on spendDgt-* right now? ");
        assert(
             isUsingSpendDgt || !required
            , "not acting as spend delegate!"
        );
        isUsingSpendDgt
    }

    func requiresMintDelegateInput(self, required: Bool = true) -> DelegateInput {
        dgtLink : RelativeDelegateLink = self.getCharterData().mintDelegateLink;
        self.requiresDelegateInput(
            dgtLink: dgtLink, 
            role: DelegateRole::MintDgt,
            required: required
        )
    }

    func requiresSpendDelegateInput(self, required: Bool = true) -> DelegateInput {
        dgtLink : RelativeDelegateLink = self.getCharterData().spendDelegateLink;

        self.requiresDelegateInput(
            dgtLink: dgtLink, 
            role: DelegateRole::SpendDgt,
            required: required
        )
    }

    // internal / low-level function
    func getCharterData(self) -> CapoDatum::CharterData {
        self.charter.switch {
            RefInput{datum, _} => datum,
            Input{datum, _} => datum,
            _ => error("CapoCtx.getCharterData(): unknown charter strategy; use result of withCharterInput(), withCharterRef(), or needsCharter() to resolve charter datum first")
        }
    }

    func getNextCharterData(self) -> CapoDatum::CharterData {
        charterAc : AssetClass = AssetClass::new(self.mph, "charter".encode_utf8());
        capoAddr : Address = self.address();
        self.charter.switch {
            Input => {
                charterData : CapoDatum::CharterData = CapoDatum::from_data(
                    tx.outputs.find( (txo: TxOutput) -> Bool {
                        txo.address == capoAddr &&
                        txo.value.get_safe(charterAc) > 0
                    }).datum.inline
                );
                charterData
            },
            _ => error("CapoCtx.getNextCharterData(): invalid except with charter strategy Input")
        }
    }

    func resolveCharterUtxo(self) -> TxInput {
        self.charter.switch {
            RefInput{_, utxo} => utxo,
            Input{_, utxo} => utxo,
            // Minting => error("can't get utxo during minting; be satisfied with the .address()!"),
            _ => error("CapoCtx.resolveCharterUtxo(): unknown charter strategy; use result of withCharterInput(), withCharterRef(), or needsCharter() to resolve charter utxo first")
        }
    }

    // internal / low-level function
    func requiresDelegateInput(self, 
        dgtLink: RelativeDelegateLink, 
        role: DelegateRole,
        required: Bool = true,
        idPrefix: Option[String] = Option[String]::None
    ) -> DelegateInput {
        DelegateInput{
            dgtLink,
            role,
            idPrefix,
            dgtLink.hasDelegateInput(
                inputs: tx.inputs, 
                mph: self.mph,
                required: required
            ),
            self.mph
        }
    }

    func address(self) -> Address {
        addr : Address = self.resolveCharterUtxo().address;
                // print("Capo addr: " + addr.show());
        addr    
    }

    func delegatedDataRef(self,
        recId: String="",
        recIdBytes: ByteArray=recId.encode_utf8()
    ) -> TxInput {
        hasDD : (TxInput) -> Bool = self.mkDelegatedDataPredicate(
            id: recIdBytes
        );

        recIdStr = recIdBytes.decode_utf8_safe();
        REQT("Expects reference to delegated-data record");
        tx.ref_inputs.find_safe(hasDD).switch {
            None => {
                error("❌❌ 📎 input: delegated-data ref not found: "+recIdStr)
            },
            Some{txin} => {
                print("     ✅ 📎 input: delegated-data ref ok: "+recIdStr);

                txin
            }
        }
    }

    func delegatedDataTxInput(self, 
        recId: String="",
        recIdBytes: ByteArray=recId.encode_utf8()
    ) -> TxInput {
        hasDD : (TxInput) -> Bool = self.mkDelegatedDataPredicate(
            id: recIdBytes
        );

        recIdStr = recIdBytes.decode_utf8_safe();
        REQT("expects delegated-data record as input");

        tx.inputs.find_safe(hasDD).switch {
            None => {
                error("❌❌ 📎 input: delegated-data record: not found: "+recIdStr)
            },
            Some{txin} => {
                print("     ✅ 📎 input: delegated-data record: ok: "+recIdStr);

                txin
            }
        }
    }
                
    func mkDelegatedDataPredicate(self, typeName: String="", id: ByteArray=#) -> (TxInput) -> Bool {
        capoAddr : Address = self.address();
        assert( 
            id.length > 0 
            || typeName.serialize().length > 0, 
            "data predicate must have id or typeName"
        );
        (txin : TxInput) -> Bool {
            if(txin.address == capoAddr) {
                data : Data = txin.datum.inline;

                CapoDatum::from_data(data).switch {
                    DelegatedData => {
                        x = AnyData::from_data(fromCip68Wrapper(data));
                        true 
                        && (typeName == "" || x.type == typeName) 
                        && (id == # || x.id == id)
                    },
                    _ => false
                }
            } else { false }
        }
    }

    func mkDelegatedDataOutputPredicate(self, typeName: String, id: ByteArray=#) -> (TxOutput) -> Bool {
        capoAddr : Address = self.address();
        // print("capoAddr: "+ capoAddr.show());
        // print("seeking type "+ typeName);
        (txo : TxOutput) -> Bool {
            // print("txo.address: "+ txo.address.show());
            if(txo.address == capoAddr) {
                data : Data = txo.datum.inline;
                CapoDatum::from_data(data).switch {
                    DelegatedData => {
                        x : AnyData = AnyData::from_data(fromCip68Wrapper(data));
                        // print( "found type " + x.type );
                        // print( "found id " + x.id.decode_utf8_safe() );
                        // isMatch : Bool = 
                        x.type == typeName && (id == # || x.id == id)
                        // print( "isMatch: " + isMatch.show() );
                        // isMatch
                    },
                    _ => {
                        // print ("not DelegatedData");
                        false
                    }
                }
            } else { 
                // print ("not in capoAddr");
                false
             }
        }
    }


    // func toDelegatedData(self, typeName: String) -> (TxInput) -> Option[Data] {
    //     capoAddr : Address = self.resolveCharterUtxo().address;
    //     none : Option[Data]::None = Option[Data]::None;
    //     (txin : TxInput) -> Option[Data] {
    //         if(txin.address == capoAddr) {
    //             data : Data = txin.datum.inline;
    //             CapoDatum::from_data(data).switch {
    //                 DelegatedData => {
    //                     x : AnyData = AnyData::from_data(data);
    //                     if (x.type == typeName) {
    //                         Option[Data]::Some{data}
    //                     } else {
    //                         none
    //                     }
    //                 },
    //                 _ => none
    //             }
    //         } else { none }
    //     }
    // }

    // func foldDelegatedData_lazy[RT]( self, 
    //     typeName: String, 
    //     reducer: (
    //         Data, () -> RT
    //     ) -> RT, 
    //     final: RT
    // ) -> RT {
    //     // filter : (TxInput) -> Bool = self.delegatedDataFilter(typeName);
    //     hasDD : (TxInput) -> Option[Data] = self.toDelegatedData(typeName);
    //     // capoAddr : Address = self.resolveCharterUtxo().address;
    //     tx.inputs.fold_lazy[RT](
    //         (txin : TxInput, myNext: () -> RT) -> RT {
    //             hasDD(txin).switch {
    //                 Some{data} => reducer(data, myNext),
    //                 None => myNext()
    //             }
    //         }, final
    //     )
    // }

    // func filterDelegatedData(self, type: String, filter: (Data) -> Bool) -> []TxInput {
    //     //NOT: hasDD : (TxInput) -> Bool = self.delegatedDataFilter(type);
    //     // use toDelegatedData:
        
    //     hasDD : (TxInput) -> Option[Data] = self.mkDelegatedDataPredicate(type);
    //     tx.inputs.filter( (txin : TxInput) -> Bool {
    //         hasDD(txin).switch { 
    //             Some{data} => filter(data),
    //             None => false
    //         }
    //     })
    // }

    // func findDelegatedData[T](self, 
    //     type: String, 
    //     transform: (Data) -> Option[T],
    //     optional: Bool = false
    // ) -> []T {
    //     //not hasDD : (TxInput) -> Bool = self.delegatedDataFilter(type);
    //     // use toDelegatedData:
    //     hasDD : (TxInput) -> Option[Data] = self.toDelegatedData(type);
    //     none : Option[T]::None = Option[T]::None;
    //     result : []T = tx.inputs.map_option[T]( (txin : TxInput) -> Option[T] {
    //         hasDD(txin).switch { 
    //             Some{data} => {
    //                 transform(data)
    //             },
    //             None => none
    //         }
    //     });
    //     if (!optional && (result.length == 0)) {
    //         error(type + ": no match")
    //     };

    //     result
    // }

    // func findDelegatedDataUtxos(self, 
    //     type: String, 
    //     filter: (Data, TxInput) -> Bool,
    //     id: ByteArray=#,
    //     optional: Bool = false
    // ) -> []TxInput {
    //     //not hasDD : (TxInput) -> Bool = self.delegatedDataFilter(type);
    //     // use toDelegatedData:
    //     hasDD : (TxInput) -> Bool = self.mkDelegatedDataPredicate(type, id);
    //     none : Option[TxInput]::None = Option[TxInput]::None;
    //     result : []TxInput = tx.inputs.map_option[TxInput]( (txin : TxInput) -> Option[TxInput]{
    //         if (hasDD(txin)
    //             Some{data} => {
    //                 if (filter(data, txin)) {
    //                     Option[TxInput]::Some{txin}
    //                 } else {
    //                     none
    //                 }
    //             },
    //             None => none
    //         }
    //     });
    //     if (!optional && (result.length == 0)) {
    //         error(type + ": no match")
    //     };

    //     result
    // }

    func mustOutputDelegatedData(self, newDataId : ByteArray, dataTypePurpose : String) -> Bool{
        REQT("The new record must be saved in the Capo address");

        dgData : Data = self.delegatedTxOutput(newDataId).datum.inline;
        dgDatum : CapoDatum = CapoDatum::from_data(dgData);

        REQT("   -- validates that the new record matches the type-name indicated in the dgDataPolicy manifest");
        dgDatum.switch {
            DelegatedData => {
                data : AnyData = AnyData::from_data(fromCip68Wrapper(dgData));
                recIdStr = newDataId.decode_utf8_safe();
                if (data.id != newDataId) {
                    actualIdStr = data.id.decode_utf8_safe();
                    error("❌❌ 📎 outDD: wrong id: "+actualIdStr + " (expected "+recIdStr+")")
                } else {
                    if (data.type != dataTypePurpose) {
                        error("❌❌ 📎 outDD: bad type: "+data.type + " (expected "+dataTypePurpose+")")
                    } else {
                        print("     ✅ 📎 delegated-data saved in Capo: "+recIdStr);
                        true
                    }
                }
            },
            _ => {
                error("output not delegated data")
            }
        }
    }        

    // func delegatedOutputData(self, 
    //     recId: ByteArray
    // ) -> Data {
    //     self.delegatedTxOutput(recId).datum.inline
    // }

    func delegatedTxOutput(self, 
        recId: ByteArray
    ) -> TxOutput {
        recIdStr = recId.decode_utf8_safe();
        ac = AssetClass::new(self.mph, recId);
        capoAddr = self.address();
        tx.outputs.find_safe(
            (txout : TxOutput) -> Bool {
                // print("?? txOut" + txout.value.show());
                // print("@addr" + txout.address.show());
                true
                && (txout.value.get_safe(ac) == 1)
                    .trace("    -- check output has value? ")
                && (txout.address == capoAddr)
                    .trace("     -- ... at the right capoAddr? ")
            }
        ).switch{
            None => {
                error("❌❌ 📎 delegated-data output: not found: " + recIdStr)
            },
            Some{txout} => {
                print("     ✅ 📎 delegated-data output: found "+ recIdStr);
                txout
            }
        }
    }

    // func XXXmustFindDelegatedDatum[T](self, mph: MintingPolicyHash, tnBytes: ByteArray, inAddr: Address) -> outputAndDatum[T] {
    //     notFound = Option[outputAndDatum[T]]::None;
    //     idTokenValue = mkTv(mph: mph, tnBytes: tnBytes);
    //     print( " ⬅️ 🔎 finding DelegatedData output: "+ tnbBytes.decode_utf8_safe());

    //     foundDelegatedData: []outputAndDatum[T] = 
    //         tx.outputs.map_option[
    //             outputAndDatum[T]
    //         ](
    //             (output: TxOutput) -> Option[outputAndDatum[T]] {
    //                 if ( output.address != inAddr ) {
    //                     notFound
    //                 } else if (!output.value.contains(idTokenValue)) {
    //                     notFound
    //                 } else {
    //                     rawDatum : Data = output.datum.inline;
    //                     CapoDatum::from_data(
    //                         rawDatum
    //                     ).switch {
    //                         dd: DelegatedData => {
    //                             Option[
    //                                 outputAndDatum[T]
    //                             ]::Some{
    //                                 outputAndDatum[T] {
    //                                     output, dd, rawDatum
    //                                 }
    //                             }
    //                         },
    //                         _ => {
    //                             notFound
    //                         }
    //                     }
    //                 }
    //             }
    //         );
    //     assert(foundDelegatedData.length < 2, "too many delegated data outputs") ;
    //     assert(foundDelegatedData.length == 1, "no delegated data output");
    //     assert(idTokenValue.contains(foundDelegatedData.value.get_assets()), 
    //         "excess value in delegated-data output: "+(settingsOutput.value - settingsVal).show()
    //     );

    //     print("⬅️ ✅ found DelegatedData");
    //     foundDelegatedData.head
    // }


    
    // doesn't care where the charter info comes from - refinput or input, both OK
    func needsCharter(self) -> CapoCtx {
        charter : cctx_CharterInputType = self.charter;
        charter.switch {
            RefInput => {
                print("      -- needs charter, anywhere in the tx (already found as ref : )");
                self
            },
            Input => {
                print("      -- needs charter, anywhere in the tx (already found as input : )");
                self
            },
            Unk => {
                CapoCtx{mph, _} = self;
                REQT("requires the charter to be available in the transaction (input or ref)");

                charterAc : AssetClass = AssetClass::new(mph, "charter".encode_utf8());
                hasCharter = (txin : TxInput) -> Bool { txin.value.get_safe(charterAc) > 0 };

                tx.ref_inputs.find_safe(hasCharter).switch{
                    None => {
                        print("CapoCtx needsCharter(): no charter ref; must be in inputs...");

                        self.withCharterInput()
                    },
                    Some{charterUtxo} => {
                        print("    -- CapoCtx needsCharter(): found charter ref");

                        datum : CapoDatum::CharterData = CapoDatum::CharterData::from_data( 
                            charterUtxo.datum.inline
                        );
                        CapoCtx{mph, cctx_CharterInputType::RefInput{datum, charterUtxo}}
                    }
                }
                // _ => self
            }
        }
    }

    func withCharterInput(self) -> CapoCtx {

        charter : cctx_CharterInputType = self.charter;
        charter.switch {
            Input => {
                print("      -- needs charter spent in inputs (already checked : )");
                self
            },
            RefInput => error("CapoCtx.withCharterInput(): charter is from ref!"),
            Unk => {
                CapoCtx{mph, _} = self;
                REQT("requires the charter to be spent in the inputs");

                charterAc : AssetClass = AssetClass::new(mph, "charter".encode_utf8());
                hasCharter = (txin : TxInput) -> Bool { txin.value.get_safe(charterAc) > 0 };
        
                print("    -- CapoCtx finding charter in inputs");
                charterUtxo: TxInput = tx.inputs.find_safe(hasCharter).switch{
                    Some{ch} => ch,
                    None => error("Missing required charter input")
                };
                datum : CapoDatum::CharterData = CapoDatum::CharterData::from_data( 
                    charterUtxo.datum.inline
                );
                // datum : CapoDatum::CharterData = getTxCharterData(self.mph);
                CapoCtx{mph, cctx_CharterInputType::Input{datum, charterUtxo}}
                // self.copy(charter: cctx_CharterInputType::Input{charterUtxo, datum})
            }
        }
    }

    // func nowMinting(self, address: Address, output: TxOutput) -> Bool {
    //     self.charter.switch {
    //         Input => error("CapoCtx.nowMinting(): charter is from inputs!"),
    //         RefInput => error("CapoCtx.nowMinting(): charter is from ref!"),
    //         Unk => {
    //             CapoCtx{mph, _} = self;
    //             datum: CapoDatum::CharterData = CapoDatum::CharterData::from_data( 
    //                 output.datum.inline
    //             );
    //             CapoCtx{mph, cctx_CharterInputType::Minting{datum, address}}
    //     }
    // }

    func withCharterRef(self) -> CapoCtx {

        charter : cctx_CharterInputType = self.charter;
        charter.switch {
            RefInput => {
                print("      -- needs charter ref (already checked : )");
                self
            },
            Input => error("CapoCtx.withCharterRef(): charter is from inputs!"),
            Unk => {
                CapoCtx{mph, _} = self;
                REQT("requires the charter to be referenced in the txn, but unspent");
                utxo : TxInput = getRefCharterUtxo(mph);
                datum : CapoDatum::CharterData = CapoDatum::CharterData::from_data( 
                    utxo.datum.inline 
                );
            
                CapoCtx{mph, cctx_CharterInputType::RefInput{datum, utxo}}

                // self.copy(charter: cctx_CharterInputType::RefInput{datum})
            }
        }
    }

    func allDelegatesAreValidatingSettings(self) -> Bool {
        charterData = self.getCharterData();
        mph = self.mph;
        // REQT( "gov authority must be present to update settings");
        // hasGovAuthority : Bool = mustHaveGovAuthority(
        //     mph: mph,
        //     charterData: charterData // already resolved
        // );

        CapoDatum::CharterData{
            _spendDelegate,
            spendInvariants,
            otherNamedDelegates,
            _mintDelegate,
            mintInvariants,
            govDelegate,
            manifest,
            _pendingDelegates
        } = charterData;

        // REQT("the current Settings must be spent and updated");
        // settingsDgtLink : RelativeDelegateLink = manifest.get_safe("settings").switch {
        //     None => error("'settings' delegate must be present to do updatingSettings activity"),
        //     Some{dgt} => dgt.dgDataPolicy.unwrap()
        // };
        
        // //!!! note, this is a hard-coded version of requiring the settings policy script:
        // settingsDgtInput = settingsDgtLink.hasDelegateInput(
        //     inputs: tx.inputs,
        //     mph: mph
        // ).unwrap();
        // settingsDelegateIsValid : Bool = AbstractDelegateActivitiesEnum::from_data( 
        //     mustFindInputRedeemer(settingsDgtInput)
        // ).switch {
        //     SpendingActivities => true,
        //     _ => error(
        //         "settings delegate must be updating the settings with its SpendingActivities variant"
        //     )
        // };
        // _nextSettings : Data = self.getNextManifestedDatumRaw("settings");
        // isUpdatingSettings : Bool = true;
        
        inputs: []TxInput = tx.inputs;
        //!!! actually requiring delegates' SettingsValidation starts here.
        REQT("   -- only the spend delegate calls this function");
        spendDelegateIsValidating : Bool = self.nowActingAsSpendDgt();
        REQT("  -- spend delegate requires the other delegates validate (except mint delegate == same as spend delegate)");

        // govAuthority is checking the settings
        REQT( "govDelegate MAY contribute to settings validation");
        govDelegateMaybeValidating : Bool = 
            govDelegate.validatesUpdatedSettings(
                inputs: inputs,
                mph: mph,
                inputRequired: false
            ).switch{
                Some => true,
                None => {
                    print("  -- govAuthority isn't a script-based validator; doesn't validate new settings");
                    true
                }
            };
        checkOneInvariant : (RelativeDelegateLink) -> Bool = 
        (oneDgt: RelativeDelegateLink) -> Bool {
            REQT( "invariant must validate settings");
            oneDgt.validatesUpdatedSettings(
                inputs: inputs,
                mph: mph,
                inputRequired: true
            ).unwrap()
        };
        // spendInvariants are checking the settings
        REQT( "spend invariants must validate settings");
        spendInvariantsAreValidating : Bool = spendInvariants.all( 
            checkOneInvariant
        );
        // mintInvariants are checking the settings
        REQT( "mint invariants must validate settings");
        mintInvariantsAreValidating : Bool = mintInvariants.all( 
            checkOneInvariant
        );
        REQT("dgDataControllers must validate settings");
        // dgDataControllers are checking the settings

        dgDataPoliciesAreValidating :Bool = manifest.all( 
            (key: String, entry: CapoManifestEntry) -> Bool {
                entry.entryType.switch{
                    DgDataPolicy{policyLink, _idPrefix, _refCount} => {
                        policyLink.validatesUpdatedSettings(
                            inputs: inputs,
                            mph: mph,
                            inputRequired: true
                        ).unwrap()
                    },
                    _ => {
                        print("  -- ignoring manifest entry (not a data policy): " + key);
                        true
                    }
                }
            }
        );

        // namedDelegates are checking the settings
        REQT( "named delegates must validate settings");        
        namedDelegatesAreValidating : Bool = otherNamedDelegates.fold( 
            REQT( "  - each other-named-delegate must validate settings");
            (ok: Bool, key: String, dgt: RelativeDelegateLink) -> Bool {
                print("  - other-named-delegate: " + key);
                print("\n");
                ok && dgt.validatesUpdatedSettings(
                    inputs: inputs,
                    mph: mph,
                    inputRequired: true
                ).unwrap()
            }, true
        );

        // hasGovAuthority &&
        // settingsDelegateIsValid &&
        // isUpdatingSettings &&
        dgDataPoliciesAreValidating &&
        spendDelegateIsValidating &&
        govDelegateMaybeValidating &&
        spendInvariantsAreValidating &&
        mintInvariantsAreValidating &&
        namedDelegatesAreValidating 
    }

    func dgtRolesForLifecycleActivity(self, activity: CapoLifecycleActivity) -> DelegateRole {
        assert(true || /*never executed*/ self == self, "prevent unused var");

        activity.switch {
            forcingNewSpendDelegate => error("the forcingNewSpendDelegate escape-hatch activity is always handled directly by the Capo"),
            forcingNewMintDelegate => error("the forcingNewMintDelegate escape-hatch activity is always handled directly by the Capo"),

            updatingManifest => {
                REQT("... for updating the Capo manifest...");
                DelegateRole::SpendDgt
            },

            queuePendingChange => {
                REQT("... for queuing a pending dgt-change...");
                DelegateRole::MintDgt
            },
            removePendingChange => {
                REQT("... for removing a pending dgt-change entry...");
                DelegateRole::SpendDgt
            },
            commitPendingChanges => {
                REQT("... for committing pending dgt-changes...");
                 DelegateRole::BothMintAndSpendDgt
            },

            CreatingDelegate => {
                REQT("... for creating a new delegate (deprecated path)...");
                TODO("deprecate use of CLA::CreatingDelegate");
                DelegateRole::MintDgt
            }

            // we want explicit handling of each case; don't use a default match here.
            // _ => error("DO NOT CATCH DEFAULT CASE HERE")
        }
    }

    // syntax sugar.  Implied is that that any other function calls will trip errors,
    func orFail(self) -> Bool {
        _t = self;
        // assert(true || /* never executed */ self.serialize() == self.serialize(), "crazy talk");
        true
    }
    
}

func mkCapoCtx(mph: MintingPolicyHash) -> CapoCtx {
    CapoCtx{
        mph, cctx_CharterInputType::Unk
    }
}

