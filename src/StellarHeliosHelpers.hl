module StellarHeliosHelpers

// keep this as-is.  Make RealnumSettingsValueV2 or something else if it needs to change
struct RealnumSettingsValueV1 {
    name: String
    microInt: Int // "Real" semantics, times 1_000_000
}

func didSign(ctx : ScriptContext, a: Address) -> Bool {
    tx : Tx = ctx.tx;

    pkh : PubKeyHash = a.credential.switch{
        PubKey{h} => h,
        _ => error("trustee can't be a contract")
    };
    // print("checking if trustee signed: " + pkh.show());

    tx.is_signed_by(pkh)
}

func didSignInCtx(ctx: ScriptContext) -> (a: Address) -> Bool {
    (a : Address) -> Bool {
        didSign(ctx, a)
    }
}

func TODO(task: String) -> () {
    // red checkbox, face, sweat droplets
    print("  ðŸŸ¥    ðŸ˜³ðŸ’¦  TODO v ");
    print( task )
}

func REQT(reqt: String) -> () {
    // red exclamation mark
    print("â— "+ reqt)
}
func bREQT(reqt: String) -> Bool {
    REQT(reqt);
    true
}

//! represents the indicated token name as a Value
func mkTv(
    mph: MintingPolicyHash, 
    tn: String="", 
    tnBytes: ByteArray=tn.encode_utf8(),
    count : Int = 1
) -> Value {
    assert(tnBytes.length > 0, "missing reqd tn or tnBytes");
    Value::new(
        AssetClass::new(mph, tnBytes), 
        count
    )
}

//! returns the charter-token from our minter, as a Value
func tvCharter(mph: MintingPolicyHash)  -> Value {
    mkTv(mph, "charter")
}

func spendsAndReturns(value : Value, ctx : ScriptContext, input: TxInput) -> Bool {
    input.value.contains(value) &&
    ctx.tx.outputs.any( (txo : TxOutput) -> Bool {
        txo.address == input.address &&
        txo.value.contains(value)
    } )
}

func returnsValueToScript(value : Value, ctx : ScriptContext) -> Bool {
    input : TxInput = ctx.get_current_input();
    input.value.contains(value) &&
    ctx.tx.outputs.any( (txo : TxOutput) -> Bool {
        txo.address == input.address &&
        txo.value.contains(value)
    } )
}


func getOutputWithValue(ctx: ScriptContext, v : Value) -> TxOutput {
    ctx.tx.outputs.find((txo: TxOutput) -> { txo.value >= v })
}

struct outputAndDatum[T] {
    output: TxOutput
    datum: T
    rawData: Data
}

func getSingleAssetValue(input: TxInput) -> Value{
    inputMap : Map[MintingPolicyHash]Map[ByteArray]Int = input.value.get_assets().to_map();
    assert( inputMap.length == 1, 
        "multiple assets"
        // "getSingleAssetValue needs single-asset input"
    );

    inputTokens : Map[ByteArray]Int = inputMap.head_value;
    assert(inputTokens.length == 1, 
        "multiple tokens"
        // "getSingleAssetValue needs single-token input"
    );

    input.value.get_assets()
}

func outputDatum[T](newTxo : TxOutput) -> T {
    T::from_data(newTxo.datum.get_inline_data())
}

func getOutputForInput(ctx: ScriptContext, input: TxInput) -> TxOutput {
    inputValue : Value = getSingleAssetValue(input);

    getOutputWithValue(ctx, inputValue)
}

//! retrieves the redeemer for a specific input
func mustFindInputRedeemer(
    ctx : ScriptContext,
    txInput: TxInput    
) -> Data {
    targetId : TxOutputId = txInput.output_id;
    redeemers : Map[ScriptPurpose]Data = ctx.tx.redeemers;
    spendsExpectedInput : ScriptPurpose = redeemers.find_key( 
        (purpose : ScriptPurpose) -> { purpose.switch{ 
            sp: Spending => {
                // print ("oid: " + sp.output_id.show());
                sp.output_id == targetId
            }, 
            _ => false 
        } }
    );
    redeemers.get(spendsExpectedInput)
}

// XXX this doesn't work because using a field of this type
//   causes the compiler to believe there would be two enum wrappers,
//   one for this Solo variant, and another for the T type.
// Instead, the off-chain code needs to construct the wrapper,
// but the field needs to pretend there is no wrapper.

enum NestedTaggedStruct[T] {
    Solo{ thing: T }

    func unwrap(self) -> T {
        print("NestedTaggedStruct: unwrap");

        self.switch {
            Solo{ thing } => {
                print("NestedTaggedStruct: unwrapped thing");
                thing
            },
            _ => error("NestedTaggedStruct: unwrap: unknown variant")
        }
    }
}
 
// field-names style of struct, arbitrary & extensible
// field list, can be interpreted by any script that defines a 
// field-names style of struct with its own fields & data types.
struct AnyData {
    id: ByteArray "@id"  // same as the UUT name for this data
    type: String "tpe"

    // can have other fields; receiver will interpret their target types.
}

