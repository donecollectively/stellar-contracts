spending BasicDelegate

const rev : Int = 1
const instance : ByteArray = #67656e6572616c // -> "general"
const delegateName : String // = "💩  noName Delegate : ( "
const isMintDelegate : Bool = false
const isSpendDelegate : Bool = false
const isDgDataPolicy : Bool = false
const requiresGovAuthority : Bool = true

import {
    tx, 
    get_current_input,
    get_current_validator_hash
} from ScriptContext

import {
    DelegateRole,
    DelegationDetail,
    DgTknDisposition as DgTkn,
    ManifestActivity,
    PendingCharterChange,
    PendingDelegateChange,
    PendingDelegateAction,
    RelativeDelegateLink
} from CapoDelegateHelpers

// import {
//     ProtocolSettings
// } from ProtocolSettings

import {
    getTxCharterData,
    mkCapoCtx,
    CapoCtx,
    // mkTokenShow,
    CapoDatum,
    CapoManifestEntry,
    ManifestEntryType
    // CapoActivity
} from CapoHelpers

import {
    mkUutTnFactory,
    validateUutMinting
} from CapoMintHelpers

import {
    fromCip68Wrapper,
    outputAndDatum,
    returnsValueToScript,
    TODO,
    REQT,
    bREQT,
    logGroupStart,
    logGroupEnd,
    logGroup,
    logGroupUnit,
    REQTgroup,
    bREQTgroup,
    REQTgroupUnit
    // tvCharter
} from StellarHeliosHelpers

import {
    DelegateActivity,
    DelegateDatum,
    BurningActivity,
    MintingActivity,
    SpendingActivity
} from specializedDelegate

// formerly was in Capo core contract script
// func allDelegatesAreValidatingSettings() -> Bool {
//         // print( "  ...with activity updatingSettings\n");
//         // _isRelevantDatum : Bool = capoDatum.switch {
//         //     // SettingsData => true,
//         //     CharterData => true,
//         //     _ => error("wrong use of updatingSettings action; must use only on CharterData")
//         // };
//         // !!! move to SettingsDelegate?  or keep as a baseline check?
//         // it requires the govAuthority to be present 
//         REQT( "gov authority must be present to update settings");
//         hasGovAuthority : Bool = mustHaveGovAuthority(
//             mph: mph,
//             charterData: charterData // already resolved
//         );

//         CapoDatum::CharterData{
//             spendDelegate,
//             spendInvariants,
//             otherNamedDelegates,
//             mintDelegate,
//             mintInvariants,
//             govDelegate,
//             manifest
//         } = capoDatum;

//         //!!! note, this is a hard-coded version of requiring the settings policy script:
//         REQT("the current Settings must be spent and updated");
//         settingsDgtLink : RelativeDelegateLink = otherNamedDelegates.get_safe("settingsPol").switch {
//             None => error("'settings' delegate must be present to do updatingSettings activity"),
//             Some{dgt} => dgt
//         };

//         settingsDgtInput = settingsDgtLink.hasDelegateInput(
//             inputs: tx.inputs,
//             mph: mph
//         ).unwrap();
//         settingsDelegateIsValid : Bool = AbstractDelegateActivitiesEnum::from_data( 
//             mustFindInputRedeemer(settingsDgtInput)
//         ).switch {
//             SpendingActivities => true,
//             _ => assert("settings delegate must be updating the settings with its SpendingActivities variant")
//         };
//         _nextSettings : Data = cctx.getNextManifestedDatumRaw("settings");
//         isUpdatingSettings : Bool = true;
        
//         inputs: []TxInput = tx.inputs;

//         //!!! actually requiring delegates' SettingsValidation starts here.
//         REQT( "spend delegate must validate settings (wait, that's myself.  Call validate directly?");

//         spendDelegateIsValidating : Bool = 
//             spendDelegate.validatesUpdatedSettings(
//                 inputs: inputs,
//                 mph: mph,
//                 inputRequired: true
//             ).unwrap();

//         REQT("mint delegate must validate settings");
//         mintDelegateIsValidating : Bool = 
//             mintDelegate.validatesUpdatedSettings(
//                 inputs: inputs,
//                 mph: mph,
//                 inputRequired: true
//             ).unwrap();

//         // govAuthority is checking the settings
//         REQT( "govDelegate MAY contribute to settings validation");
//         govDelegateMaybeValidating : Bool = 
//             govDelegate.validatesUpdatedSettings(
//                 inputs: inputs,
//                 mph: mph,
//                 inputRequired: false
//             ).switch{
//                 Some => true,
//                 None => {
//                     print("  -- govAuthority isn't a script-based validator; doesn't validate new settings\n");
//                     true
//                 }
//             };
//         checkOneInvariant : (RelativeDelegateLink) -> Bool = 
//         (oneDgt: RelativeDelegateLink) -> Bool {
//             REQT( "invariant must validate settings");
//             oneDgt.validatesUpdatedSettings(
//                 inputs: inputs,
//                 mph: mph,
//                 inputRequired: true
//             ).unwrap()
//         };
//         // spendInvariants are checking the settings
//         REQT( "spend invariants must validate settings");
//         spendInvariantsAreValidating : Bool = spendInvariants.all( 
//             checkOneInvariant
//         );
//         // mintInvariants are checking the settings
//         REQT( "mint invariants must validate settings");
//         mintInvariantsAreValidating : Bool = mintInvariants.all( 
//             checkOneInvariant
//         );
//         // namedDelegates are checking the settings
//         REQT( "named delegates must validate settings");
//         namedDelegatesAreValidating : Bool = otherNamedDelegates.fold( 
//             REQT( "  - each named delegate must validate settings");
//             (ok: Bool, key: String, dgt: RelativeDelegateLink) -> Bool {
//                 print("  - named delegate: " + key);
//                 print("\n");
//                 ok && dgt.validatesUpdatedSettings(
//                     inputs: inputs,
//                     mph: mph,
//                     inputRequired: true
//                 ).unwrap()
//             }, true
//         );

//         isRelevantDatum &&
//         settingsDelegateIsValid &&
//         isUpdatingSettings &&
//         spendDelegateIsValidating &&
//         mintDelegateIsValidating &&
//         govDelegateMaybeValidating &&
//         spendInvariantsAreValidating &&
//         mintInvariantsAreValidating &&
//         namedDelegatesAreValidating &&
//         hasGovAuthority
// }

func checkOneActivity(
    dgtionDatum: DelegateDatum::IsDelegation, 
    activity: DelegateActivity,
    dd : DelegationDetail = dgtionDatum.dd,
    baseCctx: CapoCtx = mkCapoCtx(dd.mph),
    desc: String = "‹unspecified›"
) -> Bool {
    logGroup(group:"🏒 checking activity: "+desc, collapsed: false, callback: () -> {
        result = if (true) {
            checkNonDelegatedActivities: Bool = activity.switch {
                MultipleDelegateActivities{activities} => {
                    // NOTE: the Capo ensures that each SPENT UTxO is addressed by EXACTLY ONE SpendDgt activity.
                    // When executed in a mint/spend delegate, the policy below ensures 
                    // ... that each requested activity is matched by a UTxO in the transaction, 
                    // ... guaranteeing 1:1 coverage of activities & UTxOs.

                    // Those are executed in parts (one set of activities applicable to mintDgt-* token,
                    //   ... and the other governed by a spendDgt-* token.  It is common that the exact
                    //   ... same contract script executes both, unless it has a special need to
                    //   ... separate the code for those two; regardless, each is enforced in
                    //   ... a separate execution (different utxos, different activity/redeemer each).

                    // For now, only *DelegatedData activities are valid in mint/spend multi-activities.

                    // Special: DeletingDelegatedDatum requires a Spend validation as well as a Burn validation,
                    //   ... so it will be present in both the mintDgt and spendDgt multi-activities.

                    cctx : CapoCtx = baseCctx.withCharterRef();

                    actingAsMintDgt : Bool  = isMintDelegate 
                        && cctx.nowActingAsMintDgt(required: false)
                        && bREQT("Mint delegate: checks that all the indicated create/remove activities are valid");

                    actingAsSpendDgt : Bool = !actingAsMintDgt 
                        && isSpendDelegate 
                        && cctx.nowActingAsSpendDgt(required: false)
                        && bREQT("Spend delegate: checks that all the indicated record-update activities are valid");

                    notMintDgt : Bool = !actingAsMintDgt;
                    notSpendDgt : Bool = !actingAsSpendDgt;

                    mintDgtCheck : Bool = notMintDgt || activities.all( 
                        (rawActivity: Data) -> Bool {
                            a : DelegateActivity = DelegateActivity::from_data(rawActivity);

                            // probably can't fail here:
                            // assert(isMintDelegate, "ack! non-MintDelegate can't act as mintDgt");
                            print("  -- mintDgt checking multi-activity");
                            REQT("    -- validates nested activities: in the mint delegate, only {Create,Delete}DelegatedData activities are valid in multi-activities");

                            a.switch {
                                // in the Mint and Spend delegates, these nested activities are expected to re-delegate 
                                // to delegated-data controllers, which will use Mint/Spend/Burn activities on the data-controller tokens.
                                CreatingDelegatedData/*{TxOutputId{seedTxn, seedIdx}, dDataTypeName} */=> {
                                    // Note: CreatingDelegatedData activity doesn't involve the Capo at all!
                                    // Instead, the minter creates a UUT for the data, on authority of the mintDgt;
                                    // ... and the mintDgt requires the presence of the corresponding dgDataPolicy (with its MintingActivity);
                                    // ... then the dgDataPolicy checks the validity of the new data, and requires that
                                    // ... the new data is created as a DelegatedData record in the Capo address.

                                    // assert(isMintDelegate && cctx.nowActingAsMintDgt(),
                                    //     "CreatingDelegatedData only ok in mintDgt"
                                    //     // " ... use MintingActivities in a delegated-data controller"
                                    // );
                                    // recursion checks for the needed input/output and DgDataController MintingActivity
                                    checkOneActivity(
                                        dgtionDatum, a, dd, cctx, "one create is properly delegated"
                                    )
                                },
                                DeletingDelegatedData => {
                                    // assert(isMintDelegate, "DeletingDelegatedData only ok in mintDgt" ); // " ... use BurningActivities in a delegated-data controller"
                                    // cctx.nowActingAsMintDgt() &&
    
                                    // recursion checks for the needed input/burn                                
                                    checkOneActivity(
                                        dgtionDatum, a, dd, cctx, "one delete is properly delegated"
                                    )
                                },
                                UpdatingDelegatedData => error(
                                    "UpdatingDelegatedData only ok at level-1 spendDgt"
                                ),
                                DelegateLifecycleActivities => error("multi:DelegateLifecycleActivities not ok"),
                                CapoLifecycleActivities => error("multi:CapoLifecycleActivities not ok"),
                                MultipleDelegateActivities => error("multi:multi: nesting not ok"),
    
                                _ => error("multi:non-minting activities are invalid for mintDgt")
                            }
                        }
                    )

                    spendDgtCheck : Bool = notSpendDgt || bREQTgroup(                        
                        reqt: "validates nested activities: in the spend delegate, only {Updating,Deleting}DelegatedData activities are valid in multi-activities", 
                        collapsed: false,
                        callback: () -> Bool { activities.all( (rawActivity: Data) -> Bool {
                            a : DelegateActivity = DelegateActivity::from_data(rawActivity);
                            print("  -- spendDgt checking multi-activity");
                            a.switch {
                                // in the Mint and Spend delegates, these nested activities are expected re-delegate to delegated-data controllers,
                                // which will use Mint/Spend/Burn activities on the data-controller tokens.
                                UpdatingDelegatedData{_typeName, _recId} => {
                                    assert(isSpendDelegate && cctx.nowActingAsSpendDgt(),
                                        "UpdatingDelegatedData only ok at level-1 spendDgt"
                                        // " ... a delegated-data-controller will use one of its SpendingActivities to govern capoStoredData's spend"
                                    );
                                    // the recursion always checks for the input-datum, so we
                                    // don't need to check it here.
                                    // _inputDD = cctx.delegatedDataTxInput(recIdBytes: recId);
                                    checkOneActivity(
                                        dgtionDatum, a, dd, cctx, "one update is properly delegated"
                                    )
                                },
                                CreatingDelegatedData => error(
                                    "CreatingDelegatedData only ok in mintDgt"
                                ),
                                DeletingDelegatedData => {
                                    error("TODO: validate spending the datum for burn")
                                },
                                DelegateLifecycleActivities => error("multi:DelegateLifecycleActivities not ok"),
                                CapoLifecycleActivities => error("multi:CapoLifecycleActivities not ok"),
                                MultipleDelegateActivities => error("multi:multi: nesting not ok"),
                                _ => error("multi: non-spending activities are invalid for spendDgt")
                            }
                        }
                    )});
                
                    dgDataPolicyCheck : Bool = if (isMintDelegate || isSpendDelegate) {
                        assert(!isDgDataPolicy, "ack! mint/spend delegate can't be a delegated-data policy!");
                        true 
                    } else {
                        bREQTgroup(reqt: "multi-activity: in DgDataPolicy, only Minting/Burning/Spending activities are valid",
                        collapsed: false,
                        callback: () -> Bool { activities.all( (rawActivity: Data) -> Bool {
                            a : DelegateActivity = DelegateActivity::from_data(rawActivity);

                            // WHEN this code is supporting a DgDataPolicy (with its own specializedDelegate module),
                            //   the multi-activity expects Minting/Spending/Burning activities, not *DelegatedData activities.
                            a.switch {
                                UpdatingDelegatedData => error(
                                    "UpdatingDelegatedData only ok at level-1 spendDgt (use a SpendingActivity in dgDataPolicy)"
                                ),
                                CreatingDelegatedData => error(
                                    "CreatingDelegatedData only ok in mintDgt (use a MintingActivity in dgDataPolicy)"
                                ),
                                DeletingDelegatedData => error(
                                    "DeletingDelegatedData only ok at mint/spend dgt (use BurningActivity in dgDataPolicy)"
                                ),
                                // in the delegated-data controllers, we have to support these multi-activities.
                                // this will pass through the individual activity to be individually validated by the specialized delegate 
                                // module that governs the data-controller's UUT, in its additionalDelegateValidation() function.
                                SpendingActivities => checkOneActivity(dgtionDatum, a, dd, cctx, "biz-logic for one record update"),
                                MintingActivities => checkOneActivity(dgtionDatum, a, dd, cctx, "biz-logic for one record create"),
                                BurningActivities => {
                                    assert(false, "TODO: support multi:BurningActivities for dgDataPolicy or other delegate") ;
                                    checkOneActivity(dgtionDatum, a, dd, cctx, "biz-logic for one record delete")
                                },
                                DelegateLifecycleActivities => error("multi:DelegateLifecycleActivities not ok"),
                                CapoLifecycleActivities => error("multi:CapoLifecycleActivities not ok"),
                                MultipleDelegateActivities => error("multi:multi: nesting not ok")
                                // _ => error("multi: invalid other activity for non-mint/spend delegate")
                            }
                        })
                    })
                    };

                    mintDgtCheck && spendDgtCheck && dgDataPolicyCheck
                },
                //   guards that the authority token is returned to this script.
                // specialized minting delegates should likely perform additional checks.
                DelegateLifecycleActivities{innerActivity} => innerActivity.switch {
                    // reassigning the authority token to a new minting delegate
                    ReplacingMe{seed, purpose} => {
                        // should burn the old UUT, mint the new UUT, and update the Charter
                        // with the new mint authority

                        //xxx -   tx.minted.get_safe( dd.acAuthorityToken() ) == 0 &&
                        //xxx -   !returnsValueToScript( dd.tvAuthorityToken())

                        BURNED: Int = -1;
                        otherMintedValue: Value = Value::new(
                            AssetClass::new(dd.mph, dd.tn), 
                            BURNED
                        );
                    
                        tnStr : String = dd.tn.decode_utf8_safe();
                        print("checking ReplacingMe on "+purpose + ": "+ tnStr);
                        REQT("needs the charter to be approving the the new mint-delegate");
                        TODO("  ^^^ should queue the new delegate in pendingChanges");

                        cctx : CapoCtx = baseCctx.withCharterInput();
                        isUpdatingCharter : Bool = cctx.getCharterRedeemer().switch {
                            // THE CHARTER UPDATE ITSELF WILL CHECK THAT THERE'S A VALID DELEGATE OUTPUT FOR THE NEW DELEGATE
                            updatingCharter => true,
                            _ => false
                        };

                        isMintingOk : Bool = validateUutMinting(
                            mph: dd.mph,
                            seed: seed,
                            purposes: []String{purpose}, 
                            otherMintedValue: otherMintedValue,
                            needsMintDelegateApproval: false,
                            extraMintDelegateRedeemerCheck: false
                        );

                        isMintingOk && isUpdatingCharter

                    },

                    // the token is being burned, retiring the authority token for this minting delegate
                    // as a result, this minting delegate will no longer be consulted.  This could be combined
                    // with the creation of a new minting delegate with a new authority token, registered
                    // with the Capo in place of this one (or Reassigning could be used for such a case).
                    // If there is no replacement minting delegate, then the Capo will not be able to perform 
                    // any further minting activities.
                    //
                    // Retiring is not suitable for authorizing token-burning.
                    Retiring => {
                        REQT("... Retiring delegate authority token");
                        REQT("   -- must burn the indicated authority token");
                        tx.minted.get(dd.acAuthorityToken()) == -1
                    },

                    ValidatingSettings => {
                        _charter : CapoDatum::CharterData = getTxCharterData(dd.mph);

                        // each application-specific delegate must validate the settings
                        // for itself?
                        // OR: import the settings type, and trigger the validation here
                        // ... so delegate authors can have fewer hoops to jump through
                        TODO("import settings from delegate and validate them");

                        // _foundSettings = ProtocolSettings::from_data(cctx.getManifestedData("settings"));

                        //xxx foundSettings : outputAndDatum[CapoDatum::SettingsData] = 
                        //xxx     charter.mustFindSettingsOutput(dd.mph, dd.capoAddr);
                        //xxx customSettings = fromCip68Wrapper[ProtocolSettings](foundSettings.rawData);

                        // print("\n" + delegateName + ": delegate TRYING TO VALIDATE SETTINGS\n");
                        // validated : Bool = customSettings.validate();
                        // print("HURRAY\n");

                        // TODO: also validate any typeMap (can do this later and adopt the new delegate 
                        // into the Capo when this code is written)

                        assert( false && 
                            // validated && 
                            // isValid : Bool = 
                            //     ((isTest && throwIfBadSettings(dgtionDatum, settings)) || true) &&
                            //     dgtionDatum.validateSettings(settings);
                            // isValid
                            true,
                            "ValidateSettings temporarily disabled"
                        );
                        false
                    }
                },
                CapoLifecycleActivities{dCLA} => {
                    REQT("... with any CapoLifecycle activity: ");
                    cctx = mkCapoCtx(dd.mph).
                        withCharterInput().
                        requiresGovAuthority();                    

                    // the Capo policy already requires that this activity is identical
                    // to the capo's own triggered lifecycle activity, given that the
                    // capoLifecycleActivity is what's involved on that end.  We
                    // ensure that is true here:
                    REQT("requires the Capo's CharterData activity to match this delegate's activity");
                    cctx.getCharterRedeemer().switch {
                        capoLifecycleActivity{cCLA} => {
                            assert(
                                cCLA == dCLA,
                                "activity mismatch with Capo's CharterData activity"
                            );
                            print("  -- ok, CharterData capoLifecycleActivity matches ours\n")

                        },
                        updatingCharter => {
                            dCLA.switch {
                                CreatingDelegate => {
                                    print("ok, Capo:updatingCharter works for now with CreatingDelegate\n")
                                },
                                _ => error("when Capo is UpdatingCharter, the mintDelegate must be CreatingDelegate")
                            }
                        },
                        _ => error("this activity must match the capo's own CharterData activity")
                    };

                    // wantsRole : DelegateRole = CLA.switch {
                    //     forcingNewSpendDelegate => error("the forcingNewSpendDelegate escape-hatch activity is always handled directly by the Capo"),
                    //     forcingNewMintDelegate => error("the forcingNewMintDelegate escape-hatch activity is always handled directly by the Capo"),
                    //     removePendingChange => DelegateRole::SpendDgt,
                    //     commitPendingChanges => DelegateRole::BothMintAndSpendDgt,
                    //     updatingManifest => DelegateRole::SpendDgt,

                    //     CreatingDelegate => {
                    //         TODO("deprecate use of CLA::CreatingDelegate");
                    //         DelegateRole::MintDgt
                    //     },

                    //     queuePendingChange => DelegateRole::BothMintAndSpendDgt
                    //     // we want explicit handling of each case; don't use a default match here.
                    //     // _ => error("DO NOT CATCH DEFAULT CASE HERE")
                    // };
                    // wantsRole.switch {
                    neededRole = cctx.dgtRolesForLifecycleActivity(dCLA);
                    myCurrentRole : DelegateRole = neededRole.switch {
                        HandledByCapoOnly => {
                            error("delegate invoked with invalid escape-hatch activity (always handled directly by the Capo)")
                        },
                        SpendDgt => {
                            REQT(
                                "... this Capo lifecycle activity is only valid on spend delegate",
                                isSpendDelegate 
                            );
                            assert(cctx.nowActingAsSpendDgt(), "<----- that can fail, this can't");                            
                            print("  -- ok: spendDgt checking CapoLifecycleActivity");
                            neededRole
                        },
                        MintDgt => {
                            REQT(
                                "... this Capo lifecycle activity is only valid on mint delegate",
                                isMintDelegate
                            );
                            assert(cctx.nowActingAsMintDgt(), "<----- that can fail, this can't");
                            print("  -- ok: mintDgt checking CapoLifecycleActivity");
                            neededRole
                        },
                        BothMintAndSpendDgt => {
                            REQT("It EXPECTS the Capo to enforce the presence of the mintDgt (to check the right mint) and spendDgt (to validate the charter-update logic)");
                            // REQT("  ... it needs the mintDgt to check mints & burns");// the new dgTkn creation");
                            // REQT("  ... it uses the spendDgt to verify the correct charterData update");
                            if (cctx.nowActingAsMintDgt(required:false)) {
                                DelegateRole::MintDgt
                            } else if (cctx.nowActingAsSpendDgt(required:false)) {
                                DelegateRole::SpendDgt
                            } else {
                                error("this Capo lifecycle activity is only valid on mint/spend delegate, not "+ delegateName)
                            }
                        },
                        _ => error("no way k") // unreachable
                    };


                    dCLA.switch {
                        // the mint delegate is validating a mint that CREATES A NEW DELEGATE
                        // FOR APPLICATION-SPECIFIC PURPOSES. This can affect the structure of the Capo
                        // it defers to the specialized minting delegate, if any; the unspecialized mint delegate
                        // rejects all delegate-creation.
                        CreatingDelegate{seed, purpose} => {
                            // print("🐞🐞🐞🐞🐞🐞🐞🐞🐞🐞🐞🐞 !!!!!!!!!!!!!!!!!!! todo: fix this\n");
                            // assert(false, "obsolete CLA::CreatingDelegate?");
                            TODO("XXX it should output the new delegate token to the Capo as a PendingDelegate datum");
                            REQT("... here in the MintDgt: validates creation of UUT for the new delegate, aligned to the purpose indicated");

                            mkTn = mkUutTnFactory(seed);
                            myCurrentRole.switch {
                                MintDgt => {
                                    REQT(
                                        "validates the new delegate's UUT is minted"
                                    );
                                    if (validateUutMinting(
                                        mph: dd.mph,
                                        seed: seed,
                                        purposes: []String{purpose},
                                        // otherMintedValue: ()
                                        mkTokenName: mkTn,
                                        // WE ARE the mint delegate.
                                        needsMintDelegateApproval: false 
                                    )) {
                                        print("  -- ok, minted the new delegate's UUT\n") 
                                    };
                                    REQT(
                                        "the UUT must have the right disposition (is it checked somewhere else?!?)"
                                    );
                                    cctx.getNextCharterData().otherNamedDelegates.get_safe(purpose).switch {
                                        None => error("the new delegate is not present in the Capo's named-delegates list"),
                                        Some{dgtLink} => {
                                            assert(dgtLink.uutName == mkTn(purpose), "uutName mismatch");

                                            dgtLink.hasValidOutput(
                                                mph: dd.mph, 
                                                required: true,
                                                createdOrReturned: DgTkn::Created
                                            )
                                        }
                                    }
                                },
                                _ => error("unreachable wrong role for CreatingDelegate")
                            }
                        },

                        queuePendingChange => {
                            REQT("... for the addingPendingDgt activity:");

                            charterData : CapoDatum::CharterData = cctx.getCharterData();
                            nextCharterData = cctx.getNextCharterData();

                            oldPendingChanges = charterData.pendingChanges;
                            nextChangeList = nextCharterData.pendingChanges;
                            newChange = nextChangeList.head;

                            TODO("support otherManifestChange here");
                            PendingCharterChange::delegateChange{
                                PendingDelegateChange{
                                    action, // PendingDelegateAction
                                    role, // : DelegateRole
                                    OdgtLink //: Option[RelativeDelegateLink]
                                }
                            } = newChange;
                            newDgtRoleName = role.switch {
                                DgDataPolicy{dgtName} => dgtName,
                                _ => error("only DgDataPolicy is yet supported in queuePendingChange")
                            };

                            REQTgroupUnit(
                                reqt: "The new pending-delegate action must be found at the head of the new change-list",
                                collapsed: false,
                                callback: () -> {
                                    action.switch {
                                        Remove => {
                                            print("   -- another delegate-role check would be redundant.");

                                            myCurrentRole.switch {
                                                SpendDgt => {
                                                    REQT("verifies that the delegate queued for removal is present in the Capo's charterData");
                                                    error("implement me")
                                                },
                                                _ => error("unreachable")
                                            }
                                        }, 
                                        _ => assert(true, "no way l")

                                    };
                                }
                            )

                            REQT("the remainder of the change-list should be unchanged");
                            assert(
                                nextChangeList.tail == oldPendingChanges, 
                                "invalid update of pendingChanges; the new action must be prepended to the existing list."
                            );
                            (
                                seed: TxOutputId, 
                                purpose: String,
                                pendingActionIdPrefix: String
                                // uutName: String, 
                                // dvh : Option[ValidatorHash], 
                                // config : ByteArray
                            ) = action.switch { 
                                Remove => error("unreachable"), 
                                Add{seed, purpose, idPrefix} => {
                                    (seed, purpose, idPrefix) 
                                },
                                Replace{seed, purpose, idPrefix, _replacesDgt } => { 
                                    (seed, purpose, idPrefix ) 
                                }
                            };

                            possibleMintDgtVerifications : Bool = myCurrentRole.switch {
                                SpendDgt => /* no-op */ true,
                                MintDgt => bREQT(
                                    "(general) the mintDgt checks everything about the mint"
                                ) && action.switch {
                                    Remove => {
                                        role.switch {
                                            MintDgt => error("cannot Remove role: MintDgt"),
                                            SpendDgt => error("cannot Remove role: SpendDgt"),
                                            MintInvariant => error("cannot Remove role: MintInvariant"),
                                            SpendInvariant => error("cannot Remove role: SpendInvariant"),
                                            DgDataPolicy => {
                                                assert(false, "todo")
                                            },
                                            OtherNamedDgt => {
                                                assert(false, "todo")
                                            },
                                            BothMintAndSpendDgt => error(
                                                "DelegateRole::BothMintAndSpend not applicable in queuePendingChange activity"
                                            )
                                        };
                                        REQT("doesn't allow a Remove to duplicate an Add or Replace or Remove entry");
                                        TODO("^^^");

                                        assert(false, "what else should be checked here?");
                                        false
                                    },
                                    _ => { // Replace or Add
                                        if(false/*redundant*/) { assert(cctx.nowActingAsMintDgt(), "<----- that can fail, this can't") };

                                        mkTokenName = mkUutTnFactory(seed);
                                        dgTknName = mkTokenName(purpose);
                        
                                        mintedDgTkn = bREQT("the new delegate is created with the indicated authority token")
                                        && validateUutMinting(
                                            mph: dd.mph,
                                            seed: seed,
                                            // "dgtPol", until/unless we get fancy like "settingsPol", "reqtsPol", "mktSalePol", etc:
                                            purposes: []String{purpose}, 
                                            // otherMintedValue: ()
                                            mkTokenName: mkUutTnFactory(seed),
                                            // WE ARE the mint delegate.
                                            needsMintDelegateApproval: false 
                                        );
                                        
                                        REQT("The new policy-token must match the seed");
                                        dgtLink = OdgtLink.switch {
                                            None => error("missing required delegate link in pending dgt change"),
                                            Some{dl} => dl
                                        };
                                        assert(
                                            dgtLink.uutName == dgTknName,
                                            "uutName mismatch; expected "+dgTknName+" but found "+dgtLink.uutName
                                        );

                                        delegateTakesOwnership = bREQT("the new policy-delegate-script must take ownership of the dgTkn",
                                            dgtLink.hasValidOutput(
                                                mph: dd.mph, 
                                                required: true,
                                                createdOrReturned: DgTkn::Created
                                        ));

                                        possibleExtraReplacementCheck = action.switch {
                                            Replace => {
                                                REQT("Replace: the queued change must match the idPrefix of the current delegate ");
                                                TODO("VALIDATE this through a unit-test ^");
                                                charterData.manifest.get_safe(newDgtRoleName).switch {
                                                    Some{dde} => {
                                                        CapoManifestEntry{entryType, _tn, _mph} = dde;
                                                        entryType.switch {
                                                            DgDataPolicy{_polLink, idPrefix, _refCount} => {
                                                                REQT("expects the queued idPrefix to match the existing policy's idPrefix");
                                                                print("   -- expected: " + idPrefix);
                                                                print("   --   actual: "+pendingActionIdPrefix);
                                                                assert(
                                                                    idPrefix == pendingActionIdPrefix,
                                                                    "idPrefix mismatch"
                                                                )
                                                            },
                                                            _ => error("invalid Replace; the matching manifest entry for '"+newDgtRoleName+"' isn't a DgDataPolicy.")
                                                        }
                                                    },
                                                    None => error("no existing dgDataPolicy found with key: "+newDgtRoleName)
                                                };
                                                true
                                            },
                                            _ => true
                                        };
                                        mintedDgTkn && delegateTakesOwnership && possibleExtraReplacementCheck
                                    }
                                },
                                _ => error("unreachable") // other DelegateRoles 
                            }; // -> possibleMintDgtVerifications

                            otherPossibleVerifications : Bool = myCurrentRole.switch { 
                                SpendDgt => /* no-op */ error(
                                    "this block had been run by spendDgt, but\n"+
                                    "... it's much cheaper to let the MintDgt do it ...\n"+
                                    "... since it's already involved anyway"
                                ),
                                MintDgt => {
                                    // REQT("(general) the spendDgt checks everything about the charterData update");

                                    REQT("doesn't allow a queued change to duplicate any other pending entry for the same delegate name");
                                    isNotADuplicate = charterData.pendingChanges.all( 
                                        (pdChange: PendingCharterChange) -> Bool {
                                            pdChange.switch {
                                                delegateChange{
                                                    PendingDelegateChange{_pendingAction, pendingRole, _odgtLink}
                                                } => {
                                                    pendingRole.switch {
                                                        DgDataPolicy{changingDgtName} => {
                                                            changingDgtName != newDgtRoleName
                                                        },
                                                        _ => error("only DgDataPolicy is yet supported in queuePendingChange")
                                                    }
                                                },
                                                _ => error("otherManifestChange not yet supported")
                                            }
                                    });
                                    assert(isNotADuplicate, "already has a pending change for this delegate: "+newDgtRoleName);

                                    existingRoleEntryMaybe : Option[CapoManifestEntry] = charterData.manifest.get_safe(newDgtRoleName);
                                    possibleReplacementIsCorrect: Bool = action.switch {
                                        Add => {
                                            REQT("doesn't allow an Add for an existing policy name");
                                            existingRoleEntryMaybe.switch {
                                                Some =>  error(
                                                    "queuing Add failed: already has a delegate for policy name: "+ 
                                                    newDgtRoleName
                                                )
                                            };

                                            true
                                        },
                                        Replace{_seed, _purpose, _idPrefix, replacesDgt} => {
                                            REQT("For Replace on an existing delegate... ");

                                            REQT("  -- Replace: invariants cannot be replaced");
                                            role.switch {
                                                MintInvariant => error("cannot Replace role: MintInvariant"),
                                                SpendInvariant => error("cannot Replace role: SpendInvariant"),
                                                HandledByCapoOnly => error("HandledByCapoOnly role is not applicable in delegate context"),
                                                _ => print("  -- ok (not trying to replace an invariant)")
                                            };
    
                                            REQT("  -- doesn't allow a Replace if the policy-name doesn't already exist");

                                            existingDgtLink : RelativeDelegateLink = existingRoleEntryMaybe.switch {
                                                None => error("queuing Replace failed: the policy-name doesn't exist: "+ 
                                                    newDgtRoleName
                                                ),
                                                Some{CapoManifestEntry{entryType, _tn, _mph}} => {
                                                    entryType.switch {
                                                        DgDataPolicy{existingDgtLink, _idp, _refCount} => existingDgtLink,
                                                        _ => error("invalid Replace; the matching manifest entry for '"+newDgtRoleName+"' isn't a DgDataPolicy.")
                                                    }
                                                }
                                            };
                                            // RelativeDelegateLink{existingUutName, _dvh, _cfg} = existingDgtLink;

                                            REQT("  -- Replace: the PendingDelegateAction's role + replacesDgt must match the existing delegate's authority token");
                                            existingDgTkn : Option[AssetClass] = role.switch {
                                                MintDgt => Option[AssetClass]::Some{
                                                    charterData.mintDelegateLink.acAuthorityToken(dd.mph)
                                                },
                                                SpendDgt => Option[AssetClass]::Some{
                                                    charterData.spendDelegateLink.acAuthorityToken(dd.mph)
                                                },                                                
                                                DgDataPolicy{_policyName} /* DelegateRole::DgDataPolicy */ => {
                                                    REQT("  -- Replace: dgDataPolicy: the named policy must be present in the Capo manifest");

                                                    Option[AssetClass]::Some{
                                                        existingDgtLink.acAuthorityToken(dd.mph)
                                                    }
                                                },
                                                OtherNamedDgt => {
                                                    error("unreachable: OtherNamedDgt deprecated")
                                                    // REQT("  -- Replace: OtherNamedDgt: the named delegate must already be present");
                                                    // error("todo: get authority-token for this named delegate")
                                                },
                                                BothMintAndSpendDgt => error(
                                                    "DelegateRole::BothMintAndSpend not applicable in queuePendingChange activity"
                                                ),
                                                MintInvariant => error("unreachable"),
                                                SpendInvariant => error("unreachable"),
                                                HandledByCapoOnly => error("unreachable")
                                            };
                                            assert(
                                                replacesDgt == existingDgTkn.unwrap(),
                                                "the current "+role.switch{
                                                    MintDgt => "mint", SpendDgt => "spend", 
                                                    DgDataPolicy => "dgDataPolicy", OtherNamedDgt => "named",
                                                    _ => "‹incontheeiieivable›"
                                                }+" delegate's authority token doesn't match the queued action's token name "+replacesDgt.show()
                                            );

                                            true    
                                        },
                                        Remove => {
                                            REQT("doesn't allow a Remove if the policy-name doesn't already exist");
                                            existingRoleEntryMaybe.switch {
                                                None => error(
                                                    "queuing Remove failed: the policy-name doesn't exist: "+ 
                                                    newDgtRoleName
                                                )
                                            };
                                            error("unreachable: Remove not yet supported")
                                        }
                                    }; // -> possibleReplacementIsCorrect

                                    true
                                    && isNotADuplicate 
                                    && possibleReplacementIsCorrect
                                }, 
                                _ => error("unreachable") // other DelegateRoles 
                            }; // -> possibleSpendDgtVerifications
                        
                            REQT("TEMPORARY: only one pending change is allowed");
                            assert(oldPendingChanges.length == 0, "only one pending change is allowed for now (avoids resource-exhaustion)");

                            true
                            && possibleMintDgtVerifications 
                            && otherPossibleVerifications
                        },
                        removePendingChange{_role} => {
                            // this code-path is only found in the spend-delegate
                            TODO("implement removePendDgt");
                            REQT("allows the removal of a queued pending-delegate-change that can't be completed");
                            assert(false, "not yet implemented");
                            false
                        },
                        commitPendingChanges => {
                            REQT("... To commit pending changes:");
                            // this code-path has one leg in the spend-delegate
                            // and one leg in the mint-delegate
                            REQT("invariants cannot be replaced");
                            pendingChangesList : []PendingCharterChange = cctx.getCharterData().pendingChanges;
                            previousManifest : Map[String]CapoManifestEntry = cctx.getCharterData().manifest;
                            nextCharterData = cctx.getNextCharterData();
                            nextManifest : Map[String]CapoManifestEntry = nextCharterData.manifest;

                            assert(
                                bREQT("the next-changes list must be empty") &&
                                nextCharterData.pendingChanges.length == 0,
                                "pendingChanges must be emptied"
                            );

                            spendDgtCheck: Bool = if (!isSpendDelegate) {
                                true
                            } else {
                                if (!cctx.nowActingAsSpendDgt(required: false)) {
                                    true
                                } else {
                                    REQT("...spendDgt: validates that all the pending delegates are installed");
                                    // the pending changes are moved into the nextManifest

                                    // walks through the pending changes and next-manifest entries
                                    // ... and also holds a temporary picture of previous-manifest entries.
                                    //  - verifies that each next change is reflected in the next-manifest's next entry
                                    //  - verifies at the end that the remainder of the next-manifest-tail (after verifying changes added in its "head" section) 
                                    //    ... contains all the entries expected (from the previous-manifest-remainder,
                                    //    ...   == previous-manifest, when no Remove/Replace actions are present);
                                    //  - verifies that any Removed entries are missing from the next-manifest-map
                                    //    ... while removing them from the previous-manifest-remainder's "expected remaining entries"
                                    //  - verifies any Replaced entries have been added at the next-manifest's next entry
                                    //    ... AND that they're removed from the remainder of the next-manifest-map,
                                    //    ... while removing them from the "expected remaining entries" in the previous-manifest-remainder.
                                    // At the end, it verifies that the two remaining partial-maps are identical.
                                    (
                                        prevManifestRemainder, nextManifestRemainder: Map[String]CapoManifestEntry
                                    ) = pendingChangesList.fold2[ Map[String]CapoManifestEntry, Map[String]CapoManifestEntry ]( 
                                        (
                                            prevManifestRemainder : Map[String]CapoManifestEntry, 
                                            nextCMEs: Map[String]CapoManifestEntry, 
                                            pcChange: PendingCharterChange
                                        ) -> ( Map[String]CapoManifestEntry, Map[String]CapoManifestEntry ) {
                                            pdChange : PendingDelegateChange = pcChange.switch {
                                                delegateChange{dgtChange} => dgtChange,
                                                otherManifestChange => error("otherManifestChange not yet supported")
                                            };
                                            pendingTypeName = pdChange.role.switch {
                                                DgDataPolicy{typeName} => {
                                                    print("  -- ok: DgDataPolicy in commitPendingChanges");
                                                    typeName
                                                },
                                                _ => error("invalid delegate-change role (for now) in commitPendingChanges")
                                            };
                                            //void
                                            pdChange.action.switch {
                                                Remove => {
                                                    REQT("  -- Remove: verifies that the delegate queued for removal is now removed from the Capo manifest");
                                                    nextCMEs.get_safe(pendingTypeName).switch { 
                                                        Some => error(
                                                            "queued Remove failed: name still present in next-manifest item: "+ 
                                                            pendingTypeName
                                                        )
                                                    }
                                                },
                                                _ => {
                                                    REQT("   -- verifies that added & replaced entries are present in the updated map (at its next position)");
                                                    if (nextCMEs.length == 0) {
                                                        error("queued Add/Replace failed: no more items in next-manifest map")
                                                    };
                                                    ( CME_key : String, CapoManifestEntry{ME_type, _tn, _mph} ) = nextCMEs.head;
                                                    print("vv @CME entry: "+CME_key);
                                                    ManifestEntryType::DgDataPolicy{ME_policyLink, ME_idPrefix, refCount} = ME_type;
                                                    TODO("support minting multiple threads of a dgDataPolicy");
                                                    assert(refCount == 1, "refCount must be 1 when adding a new dgDataPolicy");
                                                    assert(pendingTypeName == CME_key,
                                                        "queued change: name mismatch with next-manifest item"
                                                    );
                                                    ME_name = ME_policyLink.uutName.show()
                                                    print("    -- ME policy link " + ME_name);
                                                    pendingLink = pdChange.dgtLink.unwrap();
                                                    pendingName = pendingLink.uutName.show()
                                                    print("    -- pdChange policy link " + pendingName);

                                                    assert(ME_policyLink == pendingLink,
                                                        "queued change: policyLink mismatch with next-manifest item"
                                                    );

                                                    nextIdPrefix = pdChange.action.switch {
                                                        Replace{_,_,idPrefix,_} => {
                                                            REQT("    -- Replace: verifies that the next-manifest no longer has the replaced entry");

                                                            nextCMEs.tail.get_safe(pendingTypeName).switch {
                                                                Some => error(
                                                                    "queued Replace failed: duplicate name remaining in next-manifest map: "+ 
                                                                    pendingTypeName
                                                                )
                                                            };
                                                            idPrefix
                                                        },
                                                        Add{_,_,idPrefix} => idPrefix,
                                                        _ => error( "unreachable")
                                                    };
                                                    REQT("    -- @each manifest entry: next-manifest's idPrefix must match the queued change");
                                                    assert(nextIdPrefix == ME_idPrefix,
                                                        "idPrefix mismatch with next-manifest's dgDataPolicy"
                                                    )
                                                }
                                            }; // void assertions; all needed checks are done ^^^^

                                            // traverses to next state for the reducer:
                                            pdChange.action.switch {
                                                Add => {
                                                    ( prevManifestRemainder, nextCMEs.tail )
                                                },
                                                _ => { // Remove, Replace => {
                                                    ( prevManifestRemainder.delete(pendingTypeName), nextCMEs.tail )
                                                }
                                            }
                                        }, // reducer
                                        previousManifest, // init1
                                        nextManifest // init2
                                    );
                                    nextManifestRemainder == prevManifestRemainder
                                } // spendDgt
                            };

                            mintDgtCheck = if (!isMintDelegate) {
                                true
                            } else if (!cctx.nowActingAsMintDgt(required: false)) {
                                true
                            } else {
                                REQT("... mintDgt: validates that all the removed dgTkns are burned");
                                
                                REQT("the txn must have all the expected burns");
                                mint = tx.minted.to_map();
                                mintThisPolicy = mint.get_safe(dd.mph);
                                len = mint.length - 1; // ignores the "0 ada minted" that's always present
                                if ( len > 1) {
                                    print(tx.minted.show());
                                    error("currently supporting only one minting policy being burned in the tx " + len.show())
                                };
                                observedTokenBurn = mintThisPolicy.switch {
                                    Some{minted} => minted,
                                    None => Map[ByteArray]Int{} // no burns expected
                                };

                                remainingMint: Map[ByteArray]Int = pendingChangesList.fold[ Map[ByteArray]Int ]( 
                                    (foldingBurn: Map[ByteArray]Int, pcChange: PendingCharterChange) -> Map[ByteArray]Int {
                                        REQT("EXPECTS the spendDgt to check details of Replace activities");
                                        // ignores the dgtLink details if present in a Replace activity
                                        pdChange : PendingDelegateChange = pcChange.switch {
                                            delegateChange{dgtChange} => dgtChange,
                                            otherManifestChange => error("otherManifestChange not yet supported")
                                        };
                                        pdChange.role.switch {
                                            DgDataPolicy{typeName} => {
                                                print("  -- ok: DgDataPolicy in commitPendingChanges: "+typeName);
                                                pdChange.action.switch {
                                                    Add => {
                                                        // doesn't accumulate any expected mints or burns for Add 
                                                        // (the mint happens in a previous transaction while queueing the change
                                                        foldingBurn
                                                    },
                                                    _ => { // Replace, Remove => {
                                                        REQT("verifies that a delegate queued for removal or replacement is burned");
                                                        previousManifest.get_safe(typeName).switch {
                                                            None => error("queued Remove failed: not present in previous-manifest map: "+ typeName),
                                                            Some{CapoManifestEntry{ME_type, tn, mph}} => {
                                                                mph.switch {
                                                                    Some => {
                                                                        print( "    -- TODO: manifest entry with other-mph: allow optional burn");
                                                                        // doesn't accumulate any additional expected burns
                                                                        foldingBurn
                                                                    },
                                                                    _ => {
                                                                        REQT("each pending change must have a name recognized by the manifest");
                                                                        ManifestEntryType::DgDataPolicy{_ME_policyLink, _ME_recPrefix, refCount} = ME_type;
                                                                        tnStr = tn.decode_utf8_safe();
                                                                        foldingBurn.get_safe(tn).switch {
                                                                            None => error("queued Remove/Replace failed: no burn, or double-burn: "+ tnStr),
                                                                            Some{burningCount} => {
                                                                                print("    -- ok: BURN 🔥"+ burningCount.show() + "×💴 "+ tnStr);
                                                                                if (0 - refCount != burningCount) { // negative = burning
                                                                                    error("queued Remove/Replace failed: expected burn of " + 
                                                                                        refCount.show() + "×💴 "+ tnStr
                                                                                    )
                                                                                };
                                                                                foldingBurn.delete(tn)
                                                                            } // burningCount
                                                                        } // check burn quantity
                                                                    }
                                                                } // mph
                                                            }
                                                        }
                                                    } // Remove/Replace
                                                } // action
                                            }, // DgDataPolicy
                                            _ => error("invalid delegate-change role (for now) in commitPendingChanges")
                                        } // role
                                    },  // reducer
                                    observedTokenBurn // initial value for 'foldingBurn'
                                );

                                REQT("requires all the burns of our policy-id to be accounted for");
                                assert(remainingMint.length == 0, 
                                    "extra burns found in the transaction: \n"+remainingMint.show());
                                REQT("... -- end of commitPendingChanges");
                                true
                            }; /* mintDgt */ 

                            if(!isMintDelegate && !isSpendDelegate) {
                                error("unreachable? not mintDgt or spendDgt")
                            };

                            mintDgtCheck && spendDgtCheck
                        }, // commitPendingChanges

                        updatingManifest{manifestActivity} => {
                            REQT("doesn't allow updating anything except the manifest");
                            manifestActivity.switch{
                                retiringEntry{_key} => {
                                    assert(false, "TODO: support retirement activity");
                                    REQT("doesn't remove a dgDataPolicy entry from the manifest (use queuePendingChange instead)");
                                    REQT("removes the indicated key from the manifest");
                                    REQT("delegates MUST be allowed to validate that this doesn't drop something they need")
                                },
                                updatingEntry{_key, _tokenName} => {
                                    TODO("if delegates need a hook to validate that the updte is acceptable, that might be enforced here");
                                    assert(false, "TODO: support updatingEntry activity");
                                    REQT("the indicated token MUST be referenced in the transaction")
                                },
                                addingEntry{key, tokenName} => {
                                    charterData : CapoDatum::CharterData = cctx.getCharterData();
                                    nextCharterData = cctx.getNextCharterData();
                                    REQT("the indicated token MUST be referenced in the transaction");
                                    refInput = cctx.delegatedDataRef(recIdBytes: tokenName);
                                    assert(
                                        (refInput == refInput).trace(
                                            "  -- found refInput: "+tokenName.decode_utf8_safe()+"?"
                                        ), 
                                        "refInput must be found"
                                    );

                                    REQT("the new entry MUST be found in the new manifest");
                                    nextCharterData.manifest.get_safe(key).switch {
                                        None => error("the new manifest entry is missing: "+key),
                                        Some{CapoManifestEntry{entryType, tn, mph}} => {
                                            print("   -- ok, found the manifest entry for "+ key);
                                            REQT("the new entry must have the right token-name");
                                            assert(tn == tokenName, "token-name mismatch");
                                            mph.switch { Some => error("other-mph not yet supported") };
                                            entryType.switch {
                                                NamedTokenRef => print("   -- ok: matching name, with NamedTokenRef added in updatingManifest"),
                                                _ => error("addingEntry: the new manifest entry must be a NamedTokenRef for now")                                                
                                            }
                                        }
                                    };
                                    REQT("the remainder of the manifest must be unchanged");
                                    // NOTE if you're troubleshooting a txn-building functoin, that the order 
                                    //   of elements is significant.
                                    assert(charterData.manifest == nextCharterData.manifest.delete(key),
                                        "manifest modified in an unexpected way"
                                    );
                                    print("  -- ok! new manifest as expected")
                                },
                                forkingThreadToken{_key, _newThreadCount} => {
                                    assert(cctx.nowActingAsMintDgt(), "<----- that can fail, this can't");
                                    assert(false, "TODO: support forkingThreadToken activity");
                                    REQT("the indicated token MUST be referenced in the transaction");
                                    REQT("validates that another copy of the token name is minted");
                                    REQT("when the key is a DgDataPolicy, the existing manifest entry is updated");
                                    REQT("for mint/spend delegates and otherNamedDelegates, a new manifest entry is created with refCount=1+newThreadCount, if it doesn't exist");
                                    REQT("when the manifest already has the entry, the refCount is incremented by newThreadCount")

                                }
                            }; // void assertions;
                            true
                        },
                        forcingNewMintDelegate => {
                            REQT("a forced delegate change is an escape-hatch only involving the minter and the Capo");
                            error("the mint/spend delegate never is involved when the minter is instructed to force a new delegate")
                        },
                        forcingNewSpendDelegate => {
                            REQT("a forced delegate change is an escape-hatch only involving the minter and the Capo");
                            error("the mint/spend delegate never is involved when the spender is instructed to force a new delegate")
                        }
                    } && if (true) { 
                        print("BasicDelegate harness deferring to specialization for CapoLifecycleActivities\n");
                        true
                    } else { false }
                },

                // NOTE: this is a mint delegate activity on the mintDgt-* token,
                // ... used only in a Capo's MINT delegate.  Once the specialized mint delegate includes
                // ... the delegated-data controller's UUT through the re-delegation pattern,
                // ... the delegated-data controller  picks up the thread of enforcement, via Its specialized 
                // ... delegate module's additionalDelegateValidation(), by handling the 
                // ... MintingActivities variant indicated in the *Ctrl-* token's activity/redeemer.  
                // It can be tricky to recognize that this code module serves the mint delegate, 
                // ... and that it ALSO serves the data-controller delegate separately, in that completely different
                // ... context and using its separate specialization module.
                // In each of those cases, it follows the same high-level logic, hitting different paths through this file, 
                // ... while processing different tokens for each zone of authority/responsibility.
                CreatingDelegatedData{seed, dDataTypeName} => if (!isMintDelegate) {
                    error("CreatingDelegatedData activity is only allowed in the mint delegate")
                } else {
                    cctx : CapoCtx = baseCctx.withCharterRef();
                    assert(cctx.nowActingAsMintDgt(), "<---- fails in there, not here");
                    REQT("context: CreatingDelegatedData");

                    REQT("  -- ensures the data-controller is invoked with its minting activity for the indicated recId");
                    policyDelegateInput = cctx.
                        requiresDgDataPolicyInput(dDataTypeName);

                    tnFactory : (String) -> String = mkUutTnFactory(seed);
                    purpose = policyDelegateInput.idPrefix.unwrap();
                    newDataId : ByteArray = tnFactory( purpose ).encode_utf8();
                    // as a mint delegate, we should see to it that any minting does play by the rules
                    //   ... however, this module is generic, so we can only perform generic checks here.
                    //   ... we additionally call application-provided validation (provided by a specialization)
                    //       (we haven't fully implemented generic data-controller registration, so that's a key limitation for now)
                    // xxx WE are the mint delegate : ) -  cctx.requiresMintDelegateInput().requiresValidOutput() 
                    // this needs to be done by the speciization for now
                    // && cctx.requiresDelegatedDataController(dDataTypeName).requiresDataMinting()                    

                    // dgDataPolicy = cctx.findManifestEntry(dDataTypeName).switch {
                    //     None => error(
                    //         "can't create delegatedData without a matching '"+
                    //         dDataTypeName+"' dgDataPolicy entry in the capo manifest"),
                    //     Some{mEntry} => {
                    //         mEntry.entryType.switch {
                    //             DgDataPolicy{policyLink, _refCount} => policyLink,
                    //             _ => error(
                    //                 "can't create delegatedData type '"+
                    //                 dDataTypeName+
                    //                 "'; its Capo manifest entry is not a DgDataPolicy"
                    //             )
                    //         }
                    //     }
                    // };

                    true
                    && validateUutMinting(
                        mph: dd.mph,
                        seed: seed,
                        purposes: []String{purpose},
                        // otherMintedValue: ()
                        mkTokenName: tnFactory,
                        // WE ARE the mint delegate.
                        needsMintDelegateApproval: false 
                    // ).trace(
                    //     " ✅ checked basic UUT minting "
                    )
                    && cctx.mustOutputDelegatedData(
                        newDataId, dDataTypeName
                    )
                    && bREQT("ensures the data-controller is invoked with ONE minting activity for the indicated recId")
                    && policyDelegateInput.
                        withUniqueSeededMintingActivity(seed).
                        orFail()

                    // assert(false, "^^^ does it implement the generic data-controller re-delegation convention? ^^");
                },
                // This is a Spend delegate activity on the spendDgt-* token, 
                // ... used within a Capo's SPEND delegate (which code may also govern 
                // ... its mintDgt- token, under separate utxo cover).
                // Once the specialized spend delegate includes the delegated-data controller UUT through the re-delegation pattern,
                // ... the spend delegate's specialized module picks up the thread of enforcement via its
                // ... additionalDelegateValidation(), by handling the SpendingActivities variant indicated in the *Pol-* token's activity/redeemer.
                // That controller activity may alternatively be a MultiActivity, one of whose nested activities provides 
                // ... the needed SpendingActivities variant.
                // It can be tricky to recognize that this code module serves the spend delegate and the mint delegate,
                // ... and that it ALSO serves the data-controller delegate separately, in that completely different context 
                // ... and using its separate specialization module.
                // In each of those cases, it follows the same high-level logic, hitting different paths through this file, 
                // ... while processing different tokens for each zone of authority/responsibility.
                UpdatingDelegatedData{dDataTypeName, recId} => if (!isSpendDelegate) {
                    error("UpdatingDelegatedData activity is only allowed in the spend delegate")
                } else {
                    cctx : CapoCtx = baseCctx.withCharterRef();
                    assert(cctx.nowActingAsSpendDgt(), "<---- fails in there, not here");
                    REQT("EXPECTS j6bmfv: all and ONLY DelegatedData datums must be spent with the Capo's spendingDelegatedData activity");

                    REQT("implements a generic data-controller re-delegation convention based on the capo's manifest (those with type= DgDataPolicy)");

                    REQT("ensures the data-controller is invoked with ONE spending activity for the indicated recId");
                    assert( cctx.
                        requiresDgDataPolicyInput(dDataTypeName).
                        withUniqueDDSpendingActivity(recId).
                        orFail(),
                         "^^^ those can fail, this assert won't."
                    );

                    inputDD : TxInput = cctx.delegatedDataTxInput(recIdBytes: recId);
                    assert(inputDD == inputDD, "no way m");
                    // ^^ same as vv
                    // hasDDofType : (TxInput) -> Bool = cctx.mkDelegatedDataPredicate(dDataTypeName);
                    // simply finding the input is enough to imply that the that those utxos are spend-governed by the Capo 
                    // ... which at j6bmfv, explicitly requires the token that leads to this code path
                    // ddInputs : []TxInput = ctx.tx.inputs.filter(hasDDofType);
                    // assert(ddInputs.length == 1, "extra DD input(s)");


                    if ("settings" == dDataTypeName) {
                        curSettingsId = cctx.getSettingsId(required: true).unwrap();
                        TODO(
                            "when updating the current Capo settings, the delegates must all "+
                            "have a chance to ensure the settings are valid for their needs"

                            // NOTE that requiring all policies to validate the settings update
                            // in a single transaction carries a risk of requiring a transaction that
                            // will be over-limit in some dimension.  To address this, the data structure
                            // for a pending update should be able to include a list of policies that
                            // haven't yet validated the settings; each one can validate and remove itself
                            // from the list; then, the commit can happen when the list becomes empty.

                            // ... as a special case, a single transaction that commits the changes AND
                            // involves all the remaining policies from the list doing the validation can
                            // be used to commit the changes, reducing transaction count needed to 
                            // complete the update.
                        );
                        if( false ) {
                            if (curSettingsId == recId) {
                                print(" -> ");
                                assert(
                                    // fails if the delegates aren't all validating settings:
                                    cctx.allDelegatesAreValidatingSettings(),
                                    // can't fail:
                                    "no way jose"
                                );
                                print( " <- ")
                            } else {
                                recIdStr = recId.decode_utf8_safe();
                                curSettingsIdStr = curSettingsId.decode_utf8_safe();
                                print("  -- NOTE: updating "+ recIdStr +", which isn't currentSettings="+curSettingsIdStr)
                            }
                        }
                    };

                    cctx.mustOutputDelegatedData(recId, dDataTypeName).trace("  -- did output delegated data? ")
                    && true
                },

                // only used in mint/spend Delegate, not the delegated-data policy
                DeletingDelegatedData {_dataType, recId} => if (!isMintDelegate) {
                    error("DeletingDelegatedData activity is only allowed in the mint delegate")
                } else {
                    cctx : CapoCtx = baseCctx.withCharterRef();
                    assert(cctx.nowActingAsMintDgt(), "<---- fails in there, not here");

                    REQT("this code is triggered by both the mintDgt and spendDgt, with each doing their parts of the job");
                    REQT("the spendDgt allows the spending of the utxo");
                    REQT("the mintDgt requires the burning of its UUT");
                    REQT("it must not delete a record that's still referenced by the Capo manifest");
                    REQT("a matching manifest entry has to be changed or removed prior to deletion");

                    _inputDD : TxInput = cctx.delegatedDataTxInput(recIdBytes: recId);
                    // the mintDelegate should be triggered with 
                    TODO("verify the input was found ^");

                    assert(false, "Delete not supported yet");

                    TODO("implement the generic data-controller re-delegation convention here");
                    TODO("ensure that the right delegate is consulted with its BurningActivities.*");

                    false
                },
                // the following activities are NOT done in the mint/spend delegate,
                //     ... but only in the data-controller delegate.
                // We made these explicit so they're functionally required of every specialized delegate.
                // All of the mint/spend/burn activities must be handled by the specialized delegate.  
                // Note that this code module is generic, so it can't know the internal semantics of those activities,
                // ... or even what their nested variants will be.  It's up to the specialization to handle them.
                // Each of these indicates plural "activities", but they're actually each an individual, discrete, single activity
                // ... with an Enum allowing ONE of various possible specialization-specific activities at that spot.
                // ... MultipleActivities would be used to express "it does multiple separate activities on different utxos")
                SpendingActivities => true, // handled by the specialized delegate
                MintingActivities => true,  // handled by the specialized delegate
                BurningActivities => true // handled by the specialized delegate
            };
            assert(checkNonDelegatedActivities, "checkNonDelegatedActivities failed");

            // This point in the execution serves every type of delegate, which 
            // can be a bit confusing.  Each delegate type takes its own handoff here.'
            //
            // One of the most interesting cases is for delegated-data policies, which
            // either have add'l validation called one time (for single-record creation/update)
            // or multiple times (when there's a multi-activity, we hit this spot once for
            // each nested activity)

            bREQTgroup(
                callback: () -> {
                    activity.additionalDelegateValidation(dgtionDatum, baseCctx.needsCharter())
                },
                collapsed: false,
                reqt: if (isMintDelegate && baseCctx.nowActingAsMintDgt(required: false)) {
                    "mintDgt: additionalDelegateValidation in "+delegateName
                } else if (isSpendDelegate && baseCctx.nowActingAsSpendDgt(required: false)) { 
                    "spendDgt: additionalDelegateValidation in "+delegateName
                } else {
                    delegateName+": additionalDelegateValidation()"
                }
            )
        } else { false }
        result
        // result.trace("  -- activity 🥅: "+desc+": ok? ");
    })
}

func main(
    mdd: DelegateDatum, 
    activity: DelegateActivity
) -> Bool {
    print(" 🚥❓delegate: "+delegateName + "\n");

    result :Bool = mdd.switch{
        //! performs essential checks of policy for spending the minting delegate's authority token "mintDgt-*"
        // ... it also calls any additionalDelegateValidation() defined in a specialized minting delegate,
        // ... governing the minting of application-specific tokens (including UUTs, fungible tokens, 
        // ... or other sorts of tokens under our minting policy).
        //! Ditto, for our spendDgt-* token, for governing the spend of any utxos in the Capo address.
        capoStoredData => error("Data Delegates must never store the capoStoredData variant in the script; used only for data-structuring capo-stored utxo datum"),
        // todo: ensure that the utxo-creation path also does not store IsDelegatedData variants in the script

        //! This code path is also used for other authority-bearing tokens in other specialized delegates,
        //  ... such as named delegates that the mintDgt- or spendDgt- policies defer to.
        //  ... each of those cases has separate execution through this base logic, with specialization 
        //  ... applicable for each (see references to "nowActingAs").
        isD : IsDelegation{dd} => {
             // MintDelegateDatum::IsDelegation{dd, cfg} = isD;
             assert(dd.tn != rev.serialize(), "param/script-hash uniqueness");
             assert(dd.tn != instance, "param/script-hash uniqueness");
             assert(dd.tn != delegateName.encode_utf8(), "param/script-hash uniqueness");
              
             logGroupUnit(group: "delegate: spending dgTkn", 
             collapsed: false, callback: () -> {
                 // showMyTokens : (Value) -> String = mkTokenShow(dd.mph);
                 // showMyTokens(get_current_input().value);
                 print(get_current_input().value.show())
             });

             cctx : CapoCtx = mkCapoCtx(dd.mph).needsCharter();
             govAuthorityCheck : Bool = if (!isDgDataPolicy) { true } else {
                if (!requiresGovAuthority) {
                    // "📝" - note  emoji
                    print("📝 "+delegateName+": requiresGovAuthority is overridden to false in the delegate's .hlb.ts")
                    print("   -- the policy can still choose to situationally enforce gov-authority");
                    true
                } else {
                    cctx.requiresGovAuthority().orFail()
                }
            }

            govAuthorityCheck
            && checkOneActivity(isD, activity, dd, cctx, "delegate "+delegateName+"'s overall policy")
        },
        _ => {
            // allows a delegate to also control OTHER utxo/datum types
            // in its own address, for special cases where that could be important.
            //   (so far, it's never been used - please open a discussion if you think
            //    it it's needed for your special case)

            // to trigger an invalid redeemer, call this function
            kaboomInvalidRedeemer = () -> {  error("wrong Actvy/dtm") }; // Activity custom datum must not use Activities reserved for IsDelegation datum.") };

            activity.switch{
                DelegateLifecycleActivities => kaboomInvalidRedeemer(), 
                CapoLifecycleActivities => kaboomInvalidRedeemer(),
                _ => activity.otherDatumValidation(mdd)
            }
        }
    }            

    print ("🚥🟢 delegate: "+ delegateName + ": ok!\n");
    // always true:
    result
}