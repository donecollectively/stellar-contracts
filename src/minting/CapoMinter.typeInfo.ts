// generated by StellarHeliosProject using Stellar heliosRollupTypeGen()
// recommended: CHECK THIS FILE INTO YOUR VERSION CONTROL SYSTEM
//   ... and keep checking in the changes as your on-chain types evolve.
//
// NOTE: this file is auto-generated; do not edit directly

import type { UplcData } from "@helios-lang/uplc";
import type {
    Address,
    AssetClass,
    DatumHash,
    MintingPolicyHash,
    PubKey,
    PubKeyHash,
    ScriptHash,
    SpendingCredential,
    StakingCredential,
    StakingValidatorHash,
    TimeRange,
    TxId,
    TxInput,
    TxOutput,
    TxOutputId,
    InlineTxOutputDatum,
    ValidatorHash,
    Value,
} from "@helios-lang/ledger";
import type { Cast } from "@helios-lang/contract-utils";
import type { 
    IntLike,
    // BytesLike,
 } from "@helios-lang/codec-utils";

 type TimeLike = IntLike;
 

import {HeliosScriptBundle} from "../helios/scriptBundling/HeliosScriptBundle.js"
import type { 
    tagOnly, 
    EnumTypeMeta, 
    singleEnumVariantMeta
} from "../helios/HeliosMetaTypes.js"
import type { minimalData } from "../delegation/DelegatedData.js"
import type { IntersectedEnum } from "../helios/typeUtils.js"
                


/**
 * A strong type for the canonical form of MinterActivity$CreatingNewSpendDelegate
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see MinterActivity$Ergo$CreatingNewSpendDelegate instead.
 * @public
 */
export interface MinterActivity$CreatingNewSpendDelegate {
    seed: TxOutputId  /*minVariantField*/ ,
    replacingUut: number[] | undefined  /*minVariantField*/ 
}


/**
 * An ergonomic, though less strictly-safe form of MinterActivity$CreatingNewSpendDelegate
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the MinterActivity$CreatingNewSpendDelegateLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type MinterActivity$Ergo$CreatingNewSpendDelegate = MinterActivity$CreatingNewSpendDelegate  /*ergo like-canonical-this-variant*/

/**
 * A strong type for the permissive form of MinterActivity$CreatingNewSpendDelegate
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface MinterActivity$CreatingNewSpendDelegateLike {
    seed: TxOutputId | string  /*minVariantField*/ ,
    replacingUut: number[] | undefined  /*minVariantField*/ 
}



export type MinterActivityMeta = EnumTypeMeta<
    {module: "CapoMintHelpers", enumName: "MinterActivity"}, {
        mintingCharter: singleEnumVariantMeta<MinterActivityMeta, "mintingCharter",
            "Constr#0", "singletonField", /* implied wrapper { owner: ... } for singleVariantField */ 
			Address   , "noSpecialFlags"
        >,
        mintWithDelegateAuthorizing: singleEnumVariantMeta<MinterActivityMeta, "mintWithDelegateAuthorizing",
            "Constr#1", "tagOnly", tagOnly, "noSpecialFlags"
        >,
        addingMintInvariant: singleEnumVariantMeta<MinterActivityMeta, "addingMintInvariant",
            "Constr#2", "singletonField", /* implied wrapper { seed: ... } for singleVariantField */ 
			TxOutputId   , "isSeededActivity"
        >,
        addingSpendInvariant: singleEnumVariantMeta<MinterActivityMeta, "addingSpendInvariant",
            "Constr#3", "singletonField", /* implied wrapper { seed: ... } for singleVariantField */ 
			TxOutputId   , "isSeededActivity"
        >,
        forcingNewMintDelegate: singleEnumVariantMeta<MinterActivityMeta, "forcingNewMintDelegate",
            "Constr#4", "singletonField", /* implied wrapper { seed: ... } for singleVariantField */ 
			TxOutputId   , "isSeededActivity"
        >,
        CreatingNewSpendDelegate: singleEnumVariantMeta<MinterActivityMeta, "CreatingNewSpendDelegate",
            "Constr#5", 
            "fields", MinterActivity$CreatingNewSpendDelegate, "isSeededActivity"
        >
    }
>;


/**
 * MinterActivity enum variants
 * 
 * @remarks - expresses the essential raw data structures
 * supporting the **6 variant(s)** of the MinterActivity enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `MinterActivityHelper` class
 *     for generating UPLC data for this enum type
 * @public
 */
export type MinterActivity = 
        | { mintingCharter: /* implied wrapper { owner: ... } for singleVariantField */ 
			Address    /*minEnumVariant*/ }
        | { mintWithDelegateAuthorizing: tagOnly /*minEnumVariant*/ }
        | { addingMintInvariant: /* implied wrapper { seed: ... } for singleVariantField */ 
			TxOutputId    /*minEnumVariant*/ }
        | { addingSpendInvariant: /* implied wrapper { seed: ... } for singleVariantField */ 
			TxOutputId    /*minEnumVariant*/ }
        | { forcingNewMintDelegate: /* implied wrapper { seed: ... } for singleVariantField */ 
			TxOutputId    /*minEnumVariant*/ }
        | { CreatingNewSpendDelegate: MinterActivity$CreatingNewSpendDelegate /*minEnumVariant*/ }

/**
 * ergonomic type enabling easy access to values converted from the on-chain form
 * @remarks
 * The data will be expressed in canonical form, and enum variants are merged to a single type with optional fields.
 * Nested enums are also merged in this ergonomic way.
 * @public
 */
export type ErgoMinterActivity = IntersectedEnum<
        | { mintingCharter: /* implied wrapper { owner: ... } for singleVariantField */ 
			Address    /*minEnumVariant*/ }
        | { mintWithDelegateAuthorizing: tagOnly /*minEnumVariant*/ }
        | { addingMintInvariant: /* implied wrapper { seed: ... } for singleVariantField */ 
			TxOutputId    /*minEnumVariant*/ }
        | { addingSpendInvariant: /* implied wrapper { seed: ... } for singleVariantField */ 
			TxOutputId    /*minEnumVariant*/ }
        | { forcingNewMintDelegate: /* implied wrapper { seed: ... } for singleVariantField */ 
			TxOutputId    /*minEnumVariant*/ }
        | { CreatingNewSpendDelegate: MinterActivity$Ergo$CreatingNewSpendDelegate /*minEnumVariant*/ }
>

/**
 * MinterActivity enum variants (permissive)
 * 
 * @remarks - expresses the allowable data structure
 * for creating any of the **6 variant(s)** of the MinterActivity enum type
 * 
 * - **Note**: Stellar Contracts provides a higher-level `MinterActivityHelper` class
 *     for generating UPLC data for this enum type
 *
 * #### Permissive Type
 * This is a permissive type that allows additional input data types, which are 
 * converted by convention to the canonical types used in the on-chain context.
 * @public
 */
export type MinterActivityLike = IntersectedEnum<
        | { mintingCharter: /* implied wrapper { owner: ... } for singleVariantField */ 
			Address | string    /*minEnumVariant*/ }
        | { mintWithDelegateAuthorizing: tagOnly /*minEnumVariant*/ }
        | { addingMintInvariant: /* implied wrapper { seed: ... } for singleVariantField */ 
			TxOutputId | string    /*minEnumVariant*/ }
        | { addingSpendInvariant: /* implied wrapper { seed: ... } for singleVariantField */ 
			TxOutputId | string    /*minEnumVariant*/ }
        | { forcingNewMintDelegate: /* implied wrapper { seed: ... } for singleVariantField */ 
			TxOutputId | string    /*minEnumVariant*/ }
        | { CreatingNewSpendDelegate: MinterActivity$CreatingNewSpendDelegateLike /*minEnumVariant*/ }
>

/**
 * A strong type for the canonical form of RelativeDelegateLink
 * @remarks
 * Note that any enum fields in this type are expressed as a disjoint union of the enum variants.  Processing
 * enum data conforming to this type can be a bit of a pain.
 * For a more ergonomic, though less strictly-safe form of this type, see ErgoRelativeDelegateLink instead.
 * @public
 */
export interface RelativeDelegateLink {
    uutName: /*minStructField*/ string
    delegateValidatorHash: /*minStructField*/ ValidatorHash | undefined
    config: /*minStructField*/ number[]
}


/**
 * An ergonomic, though less strictly-safe form of RelativeDelegateLink
 * @remarks
 * This type can use enums expressed as merged unions of the enum variants.  You might think of this type
 * as being "read-only", in that it's possible to create data with this type that would not be suitable for
 * conversion to on-chain use.  For creating such data, use the RelativeDelegateLinkLike type,
 * or the on-chain data-building helpers instead.
 * @public
 */
export type ErgoRelativeDelegateLink = RelativeDelegateLink/*like canon-other*/

/**
 * A strong type for the permissive form of RelativeDelegateLink
 * @remarks
 * The field types enable implicit conversion from various allowable input types (including the canonical form).
 * @public
 */
export interface RelativeDelegateLinkLike {
    uutName: /*minStructField*/ string
    delegateValidatorHash: /*minStructField*/ ValidatorHash | string | number[] | undefined
    config: /*minStructField*/ number[]
}



