minting CapoMinter

import {
    tx, 
    get_current_input,
    get_current_validator_hash,
    get_current_minting_policy_hash,
    get_cont_outputs
} from ScriptContext

import { 
    hasSeedUtxo, 
    mkUutTnFactory,
    requiresMintDelegateApproval,
    validateUutMinting, 
    MinterActivity
} from CapoMintHelpers

import {
    CapoDatum,
    CapoActivity,
    getRefCharterUtxo,
    mkCapoCtx
} from CapoHelpers

import {
    DgTknDisposition as DgTkn,
    RelativeDelegateLink
} from CapoDelegateHelpers

import {
    mustFindInputRedeemer,
    TRACE,
    REQT,
    logGroupUnit,
    logGroupEnd,
    logGroupStart,
    logGroup,
    REQTgroup,
    TODO,
    mkTv,
    outputAndDatum,
    tvCharter
} from StellarHeliosHelpers

// seed parameters provide uniqueness for the script validator hash:
const seedTxn : TxId = TxId::new(#1234)
const seedIndex : Int = 42
const rev : Int = 1

func hasContractSeedUtxo(tx: Tx) -> Bool {
    hasSeedUtxo(
        reqt: "the minter's unique seed-utxo MUST be spent",
        tx: tx, 
        seedUtxo: TxOutputId::new(seedTxn, seedIndex)
    )
}

func main(r : MinterActivity) -> Bool {
    mph: MintingPolicyHash = get_current_minting_policy_hash();
    value_minted: Value = tx.minted;
    assert(true || (/* never evaluated */ rev.serialize() == rev.serialize()), "no");
    assert(true || (/* never evaluated */ seedTxn.serialize() == seedTxn.serialize()), "no");
    print(" 🚥❓ Capo minter");
    print("  -- minter policy id: " + get_current_minting_policy_hash().show());

    ok : Bool = r.switch {
        charter: mintingCharter => REQTgroup[Bool](reqt: "Creates the capo charter", 
        collapsed: false, callback: () -> Bool {
            charterVal : Value = mkTv(mph: mph, tn: "charter");

            // these must be sorted BY LENGTH FIRST, then lexicographically
            //   (actually byte-wise, but ~same diff)
            // settingsTnBase: String = "set";
            authTnBase : String = "capoGov";
            mintDgtTnBase : String = "mintDgt";
            spendDgtTnBase: String = "spendDgt";
            purposes = []String{
                // settingsTnBase,
                authTnBase, 
                mintDgtTnBase, 
                spendDgtTnBase
            };
            // settingsDgtTnBase: String = "settingsDgt"
            // if (charter.withSettings) purposes = purposes + []String{ settingsDgtTnBase, "settings" }

            minterSeed: TxOutputId = TxOutputId::new(seedTxn, seedIndex);
            mkUutName: (String) -> String = mkUutTnFactory(
                minterSeed  
            );
            REQT(reqt: "the charter token MUST be minted", 
                assertion: value_minted >= charterVal, 
                onError: "charter token not minted",
                showSuccess: true
            );
            hasSeed: Bool = hasContractSeedUtxo(tx)
            print ("  -- mints the uuts for the Capo using the same seed");
            mintsUuts: Bool = validateUutMinting(
                mph: mph,
                seed: minterSeed,
                purposes: purposes, 
                mkTokenName: mkUutName,
                bootstrapCharter: charterVal
            );
            // charterOutput = REQTgroup(
            charterOutput = REQTgroup[TxOutput](
                reqt: "the charter MUST be saved at the new Capo address",
                collapsed: false,
                callback: () -> TxOutput {
                    tx.outputs.find( (output: TxOutput) -> Bool {
                        output.address == charter.owner &&
                        output.value.contains(charterVal)
                    })
                }
            )
            // ^^ fails if there's no charter output to the right address

            // print("defaultMinter @C");
            rawCharterData : Data = charterOutput.datum.inline;
            charterData = CapoDatum::CharterData::from_data(rawCharterData);
            CharterData{
                spendDgt, 
                spendInvariants,
                namedDelegates,
                mintDgt, 
                mintInvariants, 
                authDgt,
                manifest,
                pendingDelegates
            } = charterData;
            // settings are not essential to a Capo.
            // ... some Capos could use settings, and it would be
            // ... up to its mint/spend delegate to enforce their presence.
            // Also, their verification by other delegates, in case of updating
            // the settings.  This gives settings a slightly special role,
            // but much less than the special status they had when Settings
            // were a separate datum type.

            logGroupUnit(
                group: "validating charter data", collapsed: true, 
                callback: () -> () {
                    TODO("support initializing with some of these pre-defined:");
                    print("  -- empty mint invariants for now");
                    assert(mintInvariants.length == 0, "TEMP: no mint invariants allowed at charter creation");
                    print("  -- empty spend invariants for now");
                    assert(spendInvariants.length == 0, "TEMP: no spend invariants allowed at charter creation");
                    print("  -- empty manifest for now");
                    assert(manifest.length == 0, "TEMP: no manifest entries allowed at charter creation");
                    print("  -- empty pending-delegate-actions for now");
                    assert(pendingDelegates.length == 0, "TEMP: no pending-delegate-actions allowed at charter creation");

                    // named delegates are probably obsolete.
                    assert(namedDelegates.length == 0, "no named delegates allowed at charter creation");
                }
            )

            true 
            && hasSeed
            && mintsUuts
            && REQTgroup[Bool](reqt: "the new charter MUST have mintDgt, spendDgt, and authDgt tokens, each at their respective destinations",
            collapsed: false, callback: () -> Bool {
                true
                    && authDgt.hasValidOutput(mph, true, DgTkn::Created) 
                    && mintDgt.hasValidOutput(mph, true, DgTkn::Created)
                    && spendDgt.hasValidOutput(mph, true, DgTkn::Created)
                    // check mark:
                .trace("✅ delegate tokens sent to their separate destinations")
    
                // if (charter.withSettings) {
                //     REQT("when 'withSettings' is true, there must be a settings-policy delegate created");
                //     assert(namedDelegates.length == 1, "only settingsDgt allowed at charter creation");
                    
                //     settingsDgt = namedDelegates.get_safe("settingsPolicy").switch {
                //         None => error("missing required named delegate 'settingsPolicy'"),
                //         Some{dgt} => dgt
                //     };
                //     settingsDgt.hasValidOutput(mph, true, DgTkn::Created)

                //     REQT("with settings, there must be a settings datum stored in the Capo");
                //     cctx = mkCapoCtx(mph).nowMinting(charter.owner, charterOutput);
                //     foundSettingsOutput : TxOutput = cctx.delegatedOutputData(
                //         mkUutName(settingsTnBase)
                //     );
                
                //     // tx.outputs.find_safe( (output: TxOutput) -> Bool {
                //     //     output.address == charter.owner &&
                //     //         output.value.contains(mkTv(mph: mph, tn: mkUutName(settingsTnBase))
                //     // }).switch {
                //     //     None => error("missing required settings data"),
                //     //     Some{output} => output
                //     // };
                                    
                //     outputAndDatum[CapoDatum::DelegatedData] = 
                //         charterData.mustFindSettingsOutput(mph: mph, inAddr: charter.owner);
                //     assert(foundSettings == foundSettings, "no way, no");

                //     true
                // } else { 
                //     assert(namedDelegates.length == 0, "no named delegates allowed at charter creation");
                //     true
                //  };
    
                }
            )
        }),

        // ------------------------- MOST MINTING ACTIVITIES USE THIS CODE PATH --------------------
        mintWithDelegateAuthorizing => {
            print("mintWithDelegateAuthorizing\n");
            requiresMintDelegateApproval(mph)
            // -------------------------  ^^^ deferring to the Capo's current minting delegate --------------------
        },
        _ => {
            cctx = mkCapoCtx(mph).withCharterInput();
            r.switch {
                mintingCharter => error("unreachable"),
                mintWithDelegateAuthorizing => error("unreachable"),
                addingMintInvariant{_seed} => {
                    print("checking for addingMintInvariant\n");
                    assert(false, "should be handled by the mintDelegate!");
                    false
                },

                addingSpendInvariant{_seed} => {
                    print("checking for addingSpendInvariant\n");
                    assert(false, "should be handled by the mintDelegate!");
                    false
                },

                forcingNewMintDelegate{seed} => {
                    print("checking for forcingNewMintDelegate\n");
                    badCharterActivity = "when forcingNewMintDelegate, capo charter must be spent with its capoLifecycleActivity.forcingNewMintDelegate activity";
                    REQT("Ensures the Capo charter is also forcingNewMintDelegate");
                    cctx.getCharterRedeemer().switch {
                        capoLifecycleActivity{activity} => activity.switch {
                            forcingNewMintDelegate{seedToCapo, purpose} => {
                                print("WARNING: capo lifecycle activity is forcing a new mint-delegate with its Escape-hatch activity");
                                print("NOTE: the normal lifecycle is to use minter:mintWithDelegateAuthorizing, \n"+
                                    "  ... which defers to the Capo's current minting delegate and allows \n"+
                                    "  ... queuePendingChange(role: MintDgt) to queue the new mint delegate for installation"
                                );
                                REQT("Ensures the new mintDgt-* uut is minted with a seed");
                                assert(seed == seedToCapo, "seed mismatch:"+
                                    "\n  - Capo activity seed: "+seedToCapo.show()+
                                    "\n  - Minter seed: "+seed.show()
                                );
                                assert("mintDgt" == purpose, "wrong Capo purpose '"+purpose+"'; should be 'mintDgt'");
                                validateUutMinting(
                                    mph: mph,
                                    seed: seed,
                                    purposes: []String{purpose},
                                    // forcing the new dgt; don't involve the current mintDgt
                                    needsMintDelegateApproval: false 
                                )
                            }, 
                            _ => error(badCharterActivity)
                            
                            // queuePendingChange{capoActivitySeed, purpose, role, name} => {
                            //     assert(purpose == "mintDgt", "wrong purpose");
                            //     role.switch {
                            //         MintDgt => {
                            //             print("ok: capo lifecycle activity is adding a (pending) mint-delegate");
                            //             true
                            //         }, 
                            //         _ => error("wrong role in capo lifecycle activity")
                            //     }
                            // }
                        },
                        _ => error(badCharterActivity)
                    }
                },

                CreatingNewSpendDelegate{seed, replaceExisting} => {
                    print("checking for CreatingNewSpendDelegate\n");

                    needsCapoForcedInstall = replaceExisting.switch {
                        Some => false,
                        None => true
                    };

                    otherMintedValue : Value = replaceExisting.switch {
                        Some{oldTokenName} => {
                            BURNED: Int = -1;
                            Value::new(
                                AssetClass::new(mph, oldTokenName), 
                                BURNED
                            )
                        },
                        None => Value::ZERO
                    };
                    mkTokenName = mkUutTnFactory(seed);
                    spendDgtTn = mkTokenName("spendDgt");

                    hasCapoApproval = if (!needsCapoForcedInstall) {
                        cctx.getCharterRedeemer().switch {
                            updatingCharter => {
                                TODO("the minter should see that the new spend delegate is QUEUED for installation by the Capo");
                                TODO("this essential logic vvvv will move to the installation moment");
                                REQT("the updated charter must reference the new spend delegate");
                                RelativeDelegateLink{uutName, _dvh, _config} = cctx.getNextCharterData().spendDelegateLink;
                                print("expected uutName: "+uutName);
                                print("spendDgtTn in charter: "+spendDgtTn);
                                assert(uutName == spendDgtTn, "new spend delegate not referenced in updated charter");
                                
                                REQT("EXPECTS the Capo to validate that only the one thing is updated, and that the new UUT is deposited where it's expected");
                                true
                            },
                            // capoLifecycleActivity{activity} => activity.switch {                                
                            // queuePendingChange{capoActivitySeed, purpose, role, name} => {
                            //     assert(!replaceExisting, "queuePendingChange can't use replaceExisting option");

                            //     assert(purpose == "spendDgt", "wrong purpose");
                            //     role.switch {
                            //         SpendDgt => {
                            //             print("ok: capo lifecycle activity is adding a (pending) spend-delegate");
                            //             true
                            //         }, 
                            //         _ => error("wrong role in capo lifecycle activity")
                            //     }
                            // },
                            _ => error("capo charter must be spent with its updatingCharter activity")
                        }
                    } else {
                        REQT("When the old dgTkn isn't replaced, it ensures the Capo charter is also forcingNewSpendDelegate");
                        badCharterActivity = "when forcingNewSpendDelegate, capo charter must be spent with its capoLifecycleActivity.forcingNewSpendDelegate activity";
                        cctx.getCharterRedeemer().switch {
                            capoLifecycleActivity{activity} => activity.switch {
                                forcingNewSpendDelegate{seedToCapo, purpose} => {
                                    print("WARNING: capo lifecycle activity is forcing a spend-delegate with its Escape-hatch activity");
                                    print("NOTE: the normal lifecycle is to use minter:mintWithDelegateAuthorizing, \n"+
                                        "  ... which defers to the Capo's current minting delegate and allows \n"+
                                        "  ... queuePendingChange(role: SpendDgt) to queue the new spend delegate for installation"
                                    );

                                    REQT("Ensures the Capo activity's seed matches the minter's seed");
                                    assert(seed == seedToCapo, "seed mismatch: "
                                        + "\n  - Capo activity seed: " + seedToCapo.show()
                                        + "\n  - Minter seed: " + seed.show()
                                    );
                                    assert("spendDgt" == purpose, "wrong Capo purpose '"+purpose+"'; should be 'spendDgt'");
                                    true
                                },
                                _ => error(badCharterActivity)
                            },
                            _ => error(badCharterActivity)
                        }
                    };

                    REQT("Ensures the new spendDgt-* uut is uniquely minted using the seed");
                    didMintUuts = validateUutMinting(
                        mph: mph,
                        seed: seed,
                        purposes: []String{ "spendDgt" },
                        mkTokenName: mkTokenName,
                        otherMintedValue: otherMintedValue,
                        // forcing the new dgt; don't involve the current mintDgt
                        needsMintDelegateApproval: false 
                    );

                    didMintUuts && hasCapoApproval
                }        
            }
            // _ => true // don't catch other variants, for complete coverage above.
        }
    };

    // print("defaultMinter: minting value: " + value_minted.show());
    print("\n\n🚥🟢 Capo minter: ok!\n");
    // assert(false, "barfola");
    ok
}

